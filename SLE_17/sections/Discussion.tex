\section{More Features}

The use of inheritance-based approach and Object Algebras enables us
to build modular parsers, which are able to evolve with
syntax together. This section explores more interesting features, including
parsing multi-sorted syntax, overriding existing parsing rules,
language components for abstracting language features, and alternative
techniques under the whole framework.

\subsection{Parsing Multi-Sorted Syntax}\label{subsec:differentsyntax}

\begin{comment}
As illustrated above, using Object Algebras separates data structures from behaviors, thus enabling more modularity and reuse. New language constructs correspond to the new cases in the algebra. Different operations
 on structures, with both code reuse and separate compilation supported.
\end{comment}

Using Object Algebras, it is easy to
model multi-sorted languages. If the syntax contains multiple sorts, we can distinguish them by different type parameters. As an example, we extend the language of literals, additions and variables by introducing types, including primitive type \inlinecode{int} and function (arrow) type, and we add lambda abstractions to expressions. Now the language has two sorts in the syntax, types and expressions:

\setlength{\grammarindent}{5em}
\begin{grammar}
<type> ::= `int' \alt <type> `->' <type>

<expr> ::=  ... \alt `\\' <ident> `:' <type> `.' <expr>
\end{grammar}

Figure~\ref{fig:multi} illustrates the corresponding Scala code
that extends the Object Algebra interface, pretty-printing operation and parser. We use two type parameters \inlinecode{E} and \inlinecode{T} for expressions and types. They guarantee that invalid terms such as \inlinecode{int + int} will be rejected by the parser.
Besides lexing, the trait \inlinecode{LamOAParser} also introduces parsers for types, and the new case for expressions.
We use \inlinecode{pTypedLamT} and \inlinecode{pTypedLamE} as copies of current \inlinecode{pT} and \inlinecode{pE}, due to the issue
with \inlinecode{super} in Scala (see discussion in Section~\ref{subsec:parsingwithoa}). \inlinecode{pT} and \inlinecode{pE} are the parsers used for performing recursion.

\begin{figure}[ht]
\lstinputlisting[linerange=7-33]{code/src/papercode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX
\caption{Code for parsing a language with multi-sorted syntax for types and expressions.}
\label{fig:multi}
\end{figure}

From the code, we observe that the multi-sorts of Object Algebra interface
express multiple syntax. The isolation for different syntax
is guaranteed by the type system. The following client code

\lstinputlisting[linerange=40-43]{code/src/papercode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX_CLIENT
works as expected to parse and pretty-print the result.

\subsection{Overriding Existing Rules}\label{subsec:overriding-rules}

As many syntactically extensible parsers, our approach also supports
modifying part of existing parsers, including updating or eliminating existing rules,
but in a type-safe way. This can be useful in many
situations, for instance when conflicts or ambiguities arise upon composing languages.
As an illustration, suppose we have an untyped lambda abstraction case in a base parser as below. Some irrelevant details are omitted.

\lstinputlisting[linerange=76-82]{code/src/papercode/Sec5/Code1.scala}% APPLY:linerange=BASEPARSER_UNTYPEDLAM
Here \inlinecode{pLam} parses a lambda symbol, an identifier, a dot and an expression in sequence.
Then we want to replace the untyped lambda abstractions by typed
lambdas. With inheritance and method overriding, it is easy to only
change the implementation of \lstinline{pLam} in the extended parser.
Due to dynamic dispatch, our new
implementation of lambdas will be different without affecting the other parts of the parser.

\lstinputlisting[linerange=86-92]{code/src/papercode/Sec5/Code1.scala}% APPLY:linerange=EXTPARSER_TYPEDLAM


One can even ``eliminate'' a production rule in the extension, by overriding it with a failure parser. The lexer can also be updated, since keywords and delimiters are represented by sets of strings.


\subsection{Language Components}\label{subsec:language-component}

Modular parsing not only enables us to build a corresponding parser
which evolves with the language together, but also allows us to
abstract language features as reusable, independent components.
Generally, a language feature includes related abstract syntax,
methods to \textit{build} the syntax (parsing), and methods to
\textit{process} the syntax (evaluation, pretty-printing, etc.). From
this perspective, not only one language, but many languages can be
developed in a modular way, with common language features reused.

Instead of designing and building a language from scratch, we can
easily add a new feature by reusing the corresponding language
component. For example, if a language is composed from a component of
boolean expressions, including if-then-else, it immediately knows how
to parse, traverse, and pretty-print the if-then-else structure.
Grouping language features in this way can
be very useful for rapid development of DSLs.

For implementation, a language component is represented by a Scala object, and it consists of three parts: Object Algebra interface, parser, and Object Algebras.

\begin{itemize}[leftmargin=*]
    \item \textbf{Object Algebra interface:} defined as a trait for the abstract syntax. The type parameters represent multiple sorts of syntax, and  methods are constructs.
    \item \textbf{Parser:} corresponding parser of the abstract syntax, written in a modular way as we demonstrated before.
    \item \textbf{Object Algebras (optional):} concrete operations on ASTs, such as pretty-printing.
\end{itemize}

We take the example in Section~\ref{subsec:parsingwithoa} again, which is a language of literals, additions and variables. It can be defined as a language component \inlinecode{VarExpr}.

\lstinputlisting[linerange=115-130]{code/src/papercode/Sec5/Code1.scala}% APPLY:linerange=LANGUAGE_COMPONENTS_VAREXPR

For the extension of types and lambda abstractions in Section~\ref{subsec:differentsyntax}, instead of inheriting from the previous language directly, we can define it as another independent language component \inlinecode{TypedLam}.

\lstinputlisting[linerange=134-150]{code/src/papercode/Sec5/Code1.scala}% APPLY:linerange=LANGUAGE_COMPONENTS_TYPEDLAM

The code below shows how we merge those two components together to obtain the language we want. Furthermore, the new language is still a modular
component ready for future composition. In that case modularity is realized over higher-order hierarchies.

\lstinputlisting[linerange=154-165]{code/src/papercode/Sec5/Code1.scala}% APPLY:linerange=LANGUAGE_COMPONENTS_VARLAMEXPR

The only drawback is that the glue code of composition appears to be
boilerplate. As shown above, we are combining ASTs, parsers and
pretty-printers of \lstinline{VarExpr} and \lstinline{TypedLam}
respectively. Such a pattern refers to \textit{family
  polymorphism}~\cite{ernst01FP} which is unfortunately not fully supported
in Scala, since nested classes/traits have to be manually composed.
%Nonetheless, one can avoid such boilerplate by using metaprogramming techniques.

\subsection{Alternative Techniques}

Under our modular parsing framework, we use Packrat parsing as the underlying parsing technique, OO inheritance with method overriding for composing and extending parsers, and Object Algebras for parsing extensible ASTs. However, such a pattern is more general and thus more powerful, because those aspects are orthogonal to each other, and hence can have alternatives.

\begin{itemize}[leftmargin=*]

\item {\bf Parsing Technique:}
The pattern does not depend on a particular parser combinator library
or parsing algorithm. We demonstrated that Packrat parsing has some
advantages and is suitable in a modular setting. However, under
other circumstances it may not be
the best choice. One can use other parser combinators as long
as the guidelines proposed in Section~\ref{sec:packrat} are met.

\item {\bf Composing and Extending Parsers:}
  We use traits to model parsers, OO inheritance to compose them, and
  method overriding for their extensibility. These features
  may not be supported in other programming languages, especially in
  functional languages such as Haskell. Nevertheless, \textit{open
    recursion}~\cite{CookThesis} could be used as an alternative. An explicit
  ``self-reference'' parameter is able to explain the recursive calls
  dynamically, by the real argument passed at runtime.

\item {\bf Extensible ASTs:}
Besides Object Algebras, many other techniques including \textit{Data
  types Ã  la carte} (DTC)~\cite{swierstra2008data} and the Cake pattern~\cite{odersky2005independently} also support extensible data structures. These alternatives could also be adopted to build ASTs and their parsers.

\end{itemize}

As we demonstrated, such a pattern for modular parsing is 
modular itself, and can be customized easily.
