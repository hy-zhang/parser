\section{Implementation}\label{sec:implementation}

\subsection{Fusion of Concepts}\label{subsec:fusion}

In the previous sections we have talked about Packrat Parsing, open recursion and Object Algebras. These components fuse together in our library implementation, for the initial goal, which is to build extensible parsers. We want to argue here that those aspects are totally orthogonal, and hence can have their alternatives. For example, Object Algebras are helpful to build extensible data structures, whereas in functional programming, there has been a large amount of related work on extensible datatypes, including DTC and MRM for the Haskell language. And a better
parsing library would potentially introduce a lot of fancy features and parser combinators, run with high efficiency, or even support indirect left-recursion.
\haoyuan{Open recursion could also have alternatives?} For now, our implementation integrates the existing ones, and has turned out to be practical in various applications.

The library is made up of around twenty lines of code only, as shown in Figure~\ref{fig:sourcelibrary}. It consists of some types wrapped up by synonyms, basic functions \lstinline{fix} and \lstinline{runParser}, and the combinator \lstinline{|||} from Section~\ref{subsec:differentsyntax}.

\begin{figure}[htbp]
\centering
\begin{lstlisting}
import scala.util.parsing.combinator._
import scala.util.parsing.combinator.syntactical._

object Library extends StandardTokenParsers with PackratParsers {
    type Fix[T] = (=> T) => T
    type Parser[T] = PackratParser[T]
    type OpenParser[Alg, List, T] = Alg => (=> List) => Parser[T]

    def fix[A](f: Fix[A]): A = { lazy val a: A = f(a); a }
    def runParser(p : Parser[_]) : String => Unit = in => {
        phrase(p)(new lexical.Scanner(in)) match {
            case t if t.successful => println(t.get)
            case t                 => scala.sys.error(t.toString)
        }
    }

    implicit class Combinator[Alg1, Alg2, R, E](x : Alg1 => (=> R) => Parser[E]) {
        def |||(y : Alg2 => (=> R) => Parser[E])
            : Alg1 with Alg2 => (=> R) => Parser[E]
                = alg => l => x(alg)(l) ||| y(alg)(l)
    }
}
\end{lstlisting}
\caption{Source code of our library.}\label{fig:sourcelibrary}
\end{figure}

\subsection{Framework of a Language Component}\label{subsec:framework}

Having pointed out that our goal is to realize modular and extensible parsers, we recommend users to write code in a modular and
organized way. The framework we use for a language, or rather a language component in our case study, consists of the following three
parts:
\begin{itemize}
\item \textbf{Object Algebra interface:} defined as a trait with several cases, corresponding to the grammar rules.
\item \textbf{Parser:} implementation of the parser, using open recursion and Object Algebras, with its scoping trait abstracted over the type parameters.
\item \textbf{Algebra:} some behaviors (operations) on the data structure, such as pretty-printing and so on.
\end{itemize}

Figure~\ref{fig:objectexpr} shows how to encapsulate \lstinline{ExprAlg} and its related stuff in object \lstinline{Expr} using our library. Note that we use type bounds to address the issue remained in Section~\ref{subsec:differentsyntax}. \lstinline{List[E]} is a type synonym for a record type, while the type bound \lstinline{L} \lstinline{<:} \lstinline{List[E]} in \lstinline{AlgParser} states that the fix-point of our parser is a record, which contains at least \lstinline{pE} for parsing expressions. Hence it saves us from updating the type of fix-points all the time.

\begin{figure}[htbp]
\centering
\begin{lstlisting}
object Expr {
    trait Alg[E] {
        def varE(x : String) : E
        def appE(e1 : E, e2 : E) : E
    }

    type List[E] = { val pE : Parser[E] }

    trait AlgParser[E, L <: List[E]] {
        val pExprE : OpenParser[Alg[E], L, E] = alg => p => {
            lazy val pE = p.pE
            ident ^^ alg.varE |||
            pE ~ pE ^^ { case e1 ~ e2 => alg.appE(e1, e2) }
        }
    }

    trait Print extends Alg[String] {
        def varE(x : String) = x
        def appE(e1 : String, e2 : String) = "(" + e1 + " " + e2 + ")"
    }
}
\end{lstlisting}
\caption{Object \lstinline{Expr} for expressions.}\label{fig:objectexpr}
\end{figure}

Now \lstinline{Expr} turns out to be a self-contained small language with parsing and pretty-printing. To construct a different language component, we implement \lstinline{LamAlg} in Figure~\ref{fig:objectlam}, where we declare a different \lstinline{List} for multiple syntax.

\begin{figure}[htbp]
\centering
\begin{lstlisting}
object Lam {
    trait Alg[E, T] {
        def intT() : T
        def lamE(x : String, t : T, e : E) : E
    }

    type List[E, T] = { val pE : Parser[E]; val pT : Parser[T] }

    trait AlgParser[E, T, L <: List[E, T]] {
        lexical.reserved += ("Int")
        lexical.delimiters += ("\\", ":", ".")
        val pLamE : OpenParser[Alg[E, T], L, E] = alg => p =>
            ("\\" ~> ident) ~ (":" ~> p.pT) ~ ("." ~> p.pE) ^^
                { case x ~ t ~ e => alg.lamE(x, t, e)}
        val pLamT : OpenParser[Alg[E, T], L, T] = alg => p =>
            "Int" ^^^ alg.intT
    }

    trait Print extends Alg[String, String] {
        def intT() = "Int"
        def lamE(x : String, t : String, e : String) = "\\" + x + ":" + t + "." + e
    }
}
\end{lstlisting}
\caption{Object \lstinline{Lam} for lambdas.}\label{fig:objectlam}
\end{figure}

\subsection{More modularity}

We have optimized the framework for not only modular parsers, but also languages, and that is the reason why we call them language components. To achieve
higher-order modularity, it is necessary to follow the structure when composing two small components. Figure~\ref{fig:objectlamexpr} presents the combination of \lstinline{Expr} and \lstinline{Lam}, as a new language, which is again modular for future compositions. Note that the \lstinline{AlgParser} extends both parent parsers, so as to reuse their parser functions, as well as composing lexers automatically.

\begin{figure}[htbp]
\centering
\begin{lstlisting}
object LamExpr {
    type List[E, T] = Lam.List[E, T]
    type Alg[E, T] = Expr.Alg[E] with Lam.Alg[E, T]
    trait Print extends Expr.Print with Lam.Print

    trait AlgParser[E, T, L <: List[E, T]] extends Expr.AlgParser[E, L]
            with Lam.AlgParser[E, T, L] {
        val pLamExprE = pExprE ||| pLamE
        val pLamExprT = pLamT
    }
}
\end{lstlisting}
\caption{Object \lstinline{LamExpr}, composing \lstinline{Lam} and \lstinline{Expr} together.}\label{fig:objectlamexpr}
\end{figure}

Below we give an example of client code for testing \lstinline{LamExpr}. \lstinline{parse} is a generic parser generator, which takes an algebra.
In \lstinline{parseAndPrint} we pass the printing algebra to \lstinline{parse}, so that it parses the input and apply pretty-printing, returning the result as expected.

\begin{lstlisting}
class List[E, T](pe : Parser[E], pt : Parser[T]) {
    val pE = pe; val pT = pt
}
def parse[E, T](inp: String)(alg: LamExpr.Alg[E, T]) = {
    def parser : Fix[List[E, T]] = l => {
        val lang = new LamExpr.AlgParser[E, T, List[E, T]] {}
        new List[E, T](lang.pLamExprE(alg)(l), lang.pLamExprT(alg)(l))
    }
    runParser(fix(parser).pE)(inp)
}
def parseAndPrint(inp: String) = parse(inp)(new LamExpr.Print {})

val result = parseAndPrint("\\x:Int.x y") // prints "\\x:Int.(x y)"
\end{lstlisting}
