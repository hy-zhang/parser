\section{Overview}\label{sec:overview}

Our modular parsing library consists of four parts, and we will go through them in this section. The first is underlying parsing technique we used. Parsing has been heavily studied over the years, especially for context-free grammars and its subsets. However, the choice of parsing techniques is not a minor issue here, because of modularity. To achieve modularity, the parsers must be written in a way that can be composed, and different parsing techniques have different suitability for that.

Although every parsing algorithm is able to implement by hand in principle, some of them are not friendly for that. A parser generator is a tool to generate parsers automatically or semi-automatically, from a grammar given by the user. There is no restriction on the algorithm, however most of them adopts LL and LR parsing algorithms, which are table-based.

\huang{TALK ABOUT PREVIOUS WORKS USING PARSER GENERATORS, AND ALSO THE DISADVTANGES OF THEM}

Comparing with the parser generators, a parser combinator takes several parsers and produce a new parser as its output. It is popular in functional programming, where the parsers are represented by functions and parser combinators are higher-order functions accepts them. Parser combinators are very suitable for our purpose, because of two reasons. Firstly, they are naturally modular. The manner of using them is to write small parsers and use combinators to composed them together. The construction procedure is explicit and fully controlled by the programmer. Secondly, each parser combinator is represented by a piece of code, and also are the parsers it takes. Thus in a statically typed programming language they can be type-checked during compile time.

There are variants in the category of parser combinators. Almost all of them adopt top-down, recursive descent parsing, which uses backtracking to search through the possible branches. Simple backtracking parser combinators, such as the famous library Parsec in Haskell, have some drawbacks. One is that they cannot support left-recursive grammars. The common solution is to rewrite a left-recursive grammar into an equivalent one, so called left-recursion elimination. This solution requires information of the whole grammar, so that it cannot be applied in a modular setting because we only have parts of the grammar. Another drawback is performance. Take Parsec as an example, its choice combinator only tries the second alternative if the first fails without any token consumption. If two alternatives have a same non-empty prefix, an auxiliary function \lstinline{try} must be added to backtrack. However, if we want to extend our parsers later, we should always consider the worst case in which all alternatives share common prefixes. Then we need to add \lstinline{try} for all the branches, which results worst case exponential time complexity.

Beyond the simple backtracking one, several advanced parser combinators were studied to resolve those issues. One of them is Packrat parsers, which is our choice. The details of Packrat parser are beyond the scope of this paper. In brief, Packrat parsers use memorization to record the result of applying each parser at each position of the input, so that repeated computation is eliminated, and it supports left-recursive grammars. These properties are very suitable for modularity. Thus we use Packrat parsers as the underlying parsing technique in our library.

It is worth mentioning that the choice of parser combinators will not affect the other parts of our library. One can choose other parser combinators like Parsec, in cases that the performance and supporting of left-recursion are not major concerns.

The second part of our library is open recursion. It is introduced to deal with the problem of recursive calls in modular parsing. We use a simple example to demonstrate the problem, which is parsing a language of natural numbers. The language is defined below.

\begin{lstlisting}[language=PlainCode]
Expr := zero | succ Expr
\end{lstlisting}

Firstly, we need to define the abstract syntax. Here we use Scala's case classes to save spaces, this can also be done using class inheritance.

\begin{lstlisting}
abstract class Expr
case class Zero extends Expr
case class Succ(v: Expr) extends Expr
\end{lstlisting}

And then we write parsing functions for every cases. Some irrelevant details in the code are omitted to outline the main structure. Suppose we have \lstinline{choice} combinator for alternatives and the input tokens are global values which can be accessed by all these functions.

\begin{lstlisting}
def parseExpr(): Expr = choice(parserZero, parseSucc)

def parserZero(): Expr = {...}

def parseSucc(): Expr = {
  parseToken('succ')
  val v = parseExpr()
  Succ(v)
}
\end{lstlisting}

It works well, but later we want to extend the language to support addition.

\begin{lstlisting}[language=PlainCode]
Expr := zero | succ Expr | add Expr Expr
\end{lstlisting}

Extending the abstract syntax is easy.

\begin{lstlisting}
case class Add(a: Expr, b: Expr) extends Expr
\end{lstlisting}



\begin{itemize}
\item Choosing the Parsing Technology
    \begin{itemize}
    \item Parser Generators : why not?
        \begin{itemize}
            \item Not type-safe
            \item No modular type-checking
            \item Not modular or no separate compilation (but we need to mention lots of work on extensible parsing here: example Language Workbenches; Rats)
        \end{itemize}
    \item Parser Combinators
        \begin{itemize}
        \item Backtracking parsers (Parsec)
            \begin{itemize}
            \item Need to remove left recursion (Problem: Transformation is not modular; if we do not know the full grammar then cannot be done)
            \item Need try/backtracking (Problem: Since we do not know the full set of rules in a modular setting, we have to assume worst case scenario and add redundant backtracking. )
            \item Mention some possible workarounds (there may be some but they still have issues)
            \end{itemize}
        \item (Non)-Backtracking/Packrat Parsers (Works well in a modular setting) (find a good name for this type of parsers?)
        \end{itemize}
    \end{itemize}
\item Adapting Parser Combinators for modularity
    \begin{itemize}
    \item Using Object Algebras
    \item Using Open Recursion
    \item Using new modular parser combinators (Library: new alternative combinator, for example)
    \end{itemize}
\item Small example
    \begin{itemize}
    \item small example of a modular parser using our technique
    \item show also the same example without modularity and write a detailed comparison
    \item Lambda Calculus is a good candidate for the example
    \item Show a small extension (adding plus and numeric literals)
    \end{itemize}
\end{itemize}
