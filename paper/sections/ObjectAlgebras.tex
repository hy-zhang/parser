\section{Full Extensibility with Object Algebras}\label{sec:algebrasandparsing}

The inheritance-based approach allows building extensible parsers, based on an OO class hierarchy.  Nevertheless, the addition of new operations over ASTs is problematic using traditional OO ASTs. In this section, we 
show how to support both the forms of extensibility for ASTs (easy 
addition of language contructs, and easy addition of operations)
using Object Algebras~\cite{}.

\subsection{Problem with Traditional OO ASTs}\label{subsec:problemwithoutoa}

OO ASTs allow easily adding new language constructs, but it is hard 
to add new operations over the AST. The OO AST in Figure~\ref{}, 
supports a pretty-printing operation. Suppose we also want to collect free variables on the expression language which models
literals, additions and variables. Based on the traditional OO class hierarchy, one attempt would be extending \inlinecode{Expr} with the new
operation directly:

\lstinputlisting[linerange=19-19]{../Scala/Parser/src/PaperCode/Sec4OA/Code1.scala}% APPLY:linerange=ATTEMPT_EXPRWITHFREEVARS

\bruno{The following text is not very good, needs to be revised. I think 
we need to show the full code and where it breaks. Since I removed text 
about the Expression problem in S3, I think we need to talk more about it here.}
It refers to one Scala solution to the Expression Problem.\huang{what's the solution? does it have the later "critical issue"? if so, why is it a "solution"} But then programmers have to define new classes for literals, additions and variables
by extending the old ones together with \inlinecode{FreeVarsExpr}. The critical issue is that, the existing parsing code only generates objects of the old
types, again it is a modularity issue, since it is a bad idea to modify existing code again and again with extensions. Other solutions including modelling constructors as functions introduce unnecessary complexity.

In contrast, Object Algebras~\cite{Oliveira2012} enables us to solve this problem. As a nice solution, it separates data variants
and operations, and offers high flexibility in the choice of operations to be performed over ASTs. Before adopting it for parsing, the next section introduces the background of Object Algebras.

\subsection{Object Algebras}\label{subsec:objectalgebras}
Object Algebras captures a design pattern to address the Expression Problem, achieving two dimensions of extensibility (language constructs and operations) in a modular and type-safe way. The definition of data structures is separated from their behaviors, and future extensions on both dimensions no longer require existing code to be modified, supporting separate compilation.

Using Object Algebras in Scala, ASTs as recursive data structures are defined by traits, where each constructor corresponds to an abstract method inside.
Essentially, Object Algebras generalize the {\sc Abstract Factory} pattern~\cite{}, and promote the use of factory methods, instead of constructors, for instantiating objects. The example from Section~\ref{subsec:packratparsing} is used here again for illustration.
At first the language only supports literals and additions:

\lstinputlisting[linerange=5-8]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_ALG
We have two constructors \inlinecode{lit} and \inlinecode{add}, corresponding to literals and additions. The trait \inlinecode{ExprAlg} is called an \textit{Object Algebra interface}. The trait is parametrized by the type
\inlinecode{E}, which abstracts over the concrete type of the AST. 

\paragraph{Adding New Operations}
To realize an operation on expressions, we simply instantiate the type parameter by a concrete type and
provides implementations for all cases. Below is an example of pretty-printing an expression:

\lstinputlisting[linerange=12-15]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_PRINT
Here \inlinecode{Print} is called an \textit{Object Algebra}. It traverses an expression bottom-up, and returns a string as the result.
One can define evaluation operation as a new trait on this expression langauge:

\lstinputlisting[linerange=19-22]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_EVAL

\paragraph{Adding New AST Constructs}
Futhermore, new language constructs can be added by extending \inlinecode{ExprAlg} and adding new cases only. Now we extend the language
with variables. A new Object Algebra interface \inlinecode{VarAlg} is defined as follows:

\lstinputlisting[linerange=26-28]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_ALGEXT
Now pretty-printing on the new language can be realized without modifying existing code:

\lstinputlisting[linerange=32-34]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_EXTPRINT
An observation is that only the new case is implemented for pretty-printing, and the others have been inherited.
In other words, existing code was reused and was not modified!

To create an expression representing \inlinecode{1 + x}, a generic method is defined as follows:

\lstinputlisting[linerange=41-41]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_MAKEEXP

Note how the construction of the asbtract syntax happens throught 
the use of factory methods, instead of constructors.
The pretty print the expression, resulting in \inlinecode{"(1 + x)"},
we pass an insteance of \inlinecode{VarExprPrint} to \inlinecode{makeExp}.

\begin{lstlisting}
makeExp(new VarExprPrint {})
\end{lstlisting}

\bruno{This is a good discussion, but it is out-of-place. We haven't 
yet talking about parsing with object algebras, so I think this discussion 
should come later.}
Now we observe that an ``object'' of expression actually
has the function type \inlinecode{VarExprAlg[E] =>} \inlinecode{E} for generic \inlinecode{E}. Comparing with traditional objects, one may have concern that if a parser produces function structures, it could be hard to further process them. Especially, in the design of a compiler
there will be a lot of desugarings (or transformations). However, we argue that this is not an issue, because functions can be used
in a very clever way. For example, if one wants to transform a \inlinecode{VarExprAlg} expression to an \inlinecode{ExprAlg} expression by
replacing some variables with values based on a variable environment, a transformation algebra can be implemented as follows:\haoyuan{mention in discussion that shy deals with boilerplate.}

\lstinputlisting[linerange=45-56]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_REFACTOR
Here the \inlinecode{VarExprAlg} expression \inlinecode{"1 + x"} is changed to \inlinecode{ExprAlg} expression \inlinecode{"1 + 2"}, before the pretty-printing algebra is applied. The abstract method
\inlinecode{alg} in \inlinecode{Refactor} can actually be any algebra simply for delegation. By passing a concrete implementation
to \inlinecode{alg}, \inlinecode{Refactor} will be able to transform a \inlinecode{VarExprAlg} expression before we obtain the result.

\subsection{Parsing with Object Algebras}\label{subsec:parsingwithoa}

Parsing builds the AST as a result. When Object Algebras are used 
to build ASTs, an Object Algebra containing the constructor/factory
methods has to be used by the parsing function. Thus, a first attempt 
at defining the parser for the small arithmetic language is:

\begin{comment}
\inlinecode{ExprAlg} is defined for a small language using Object Algebras. Since Object Algebras represent ``objects'' implicitly as functions like \inlinecode{ExprAlg[E] =>} \inlinecode{E} for abstract \inlinecode{E}, we first try to build the corresponding parser by type \inlinecode{ExprAlg[E] =>} \inlinecode{Parser[E]}.
\end{comment}

\lstinputlisting[linerange=8-16]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=BASE_OA_PARSER_BAD
Such a parser works fine, but it is not extensible! For example, we have demonstrated in Section~\ref{subsec:overriding} that method overriding is essential to update \inlinecode{pExpr} for an extended syntax. However, trying to do a similar method override for \inlinecode{pExpr} would require a type \inlinecode{VarExprAlg[E] =>} \inlinecode{Parser[E]}, where the type of the \emph{extended} Object Algebra interface appears in \emph{contravariant} position. This difference prohibits method/field overriding. Scala supports type-refinement of fields if the overriding 
field has a type which is a \emph{subtype} of the original field.
Unfortunatelly, in this case, although \inlinecode{VarExprAlg} is a subtype 
of \inlinecode{ExprAlg}, the function type \inlinecode{VarExprAlg[E] =>} \inlinecode{Parser[E]} is a supertype of \inlinecode{ExprAlg[E] =>} \inlinecode{Parser[E]}. Thus it is not possible to have overriding. 

% because Object Algebra interfaces extended from \inlinecode{VarExprAlg} %are subtypes of it, but the types of their parsers are supertypes of %\inlinecode{VarExprAlg[E] =>} \inlinecode{Parser[E]}.

\paragraph{A Solution}
A solution to this problem is instead have a field with the Object Algebra
in \lstinline{ExprOAParser}. This approach supports overriding as well. 
The parsing code is as follows:

\lstinputlisting[linerange=23-33]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=BASE_OA_PARSER
This is precisely the pattern that we advocate for modular parsing. 
One important remark is we introduce \inlinecode{pE} for recursive calls. 
The reason why we use an extra and seemingly redundant field, is due to a subtle issue caused by Scala language and its parser combinator library. There is a restriction of \inlinecode{super} keyword in Scala that \inlinecode{super} can only use fields defined by keyword \inlinecode{def}, can not use those defined by \inlinecode{val}, while the parser combinator library suggests using \inlinecode{val} to define parsers, especially for left-recursive ones. Our workaround is that we use different synonyms for \inlinecode{pE} in different traits, so that we can directly distinguish them by names without using \inlinecode{super}.

\paragraph{Extensions}
Now let's try this pattern with the variables extension:
\lstinputlisting[linerange=37-48]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=EXT_OA_PARSER
\bruno{break code into 2 parts: the definition of the trait; and the client 
code.}
\bruno{the following text should be for explaining the definition of the trait}
\noindent The type of the object algebra field \lstinline{alg} is first refined 
to \lstinline{VarExpAlg[E]}, to allow calling the additional factory method 
for variables. Note that, unlike the previous attempt, \lstinline{VarExpAlg[E]}
is a subtype of \lstinline{ExpAlg[E]}, thus the type-refinement of the 
field is allowed. Now, the code for parsing variables (\lstinline{pVar}) can 
call \lstinline{alg.varE}. The following code illustrates how to use 
the parser from a client perspective:

\bruno{put the client code here.}

\bruno{have we defined the ``parse'' method?? I don't think we have!
We need to first present the parse method. }
In the client code shown above, we first need to chose a concrete 
object algebra to initialize the \lstinline{alg} field in \lstinline{VarExprOAParser}. Here we pick the 
pretty-printing algebra \lstinline{VarExprPrint}, but any other object 
algebra that implements \lstinline{VarExprAlg} would work. 
With an instance of \lstinline{VarExprOAParser} in hand, we can call 
\lstinline{pE} to obtain the parser to feed to the \lstinline{parse} method. 
The result shows that such a pattern provides modular parsing. 

\begin{comment}
At this point, one may argue that with a different operation like evaluation, the redundant code is required to obtain the parser, and it results in parsing the same input twice. However, that is generally solved~\cite{Oliveira2012} \huang{it was "original object algebra paper", i added the citation here, is it the correct one? i'll check later} by composing two algebras into one in advance.
\end{comment}

\subsection{Parsing Multi-sort Syntax}\label{subsec:differentsyntax}

\huang{to polish}As illustrated above, one intuition of using Object Algebras is to separate data structures from behaviors, so as to modularize the design, and both parts are even more modular and reusable. We can simply add new variants corresponding to the new cases in the grammar, and realize different operations on structures, with both code reuse and separate compilation supported.

Another advantage of using Object Algebras is that we benefit from using generics. If the syntax contains multiple sorts, we can distinguish them by different type parameters. Thus fewer classes are defined and code is simplified. As an example, we extend the language of literals, additions and variables by introducing types as a new sort. Now it has two sorts in the syntax, types and expressions. We certainly do not want to mix them together.\\

\begin{tabular}{m{0.45\linewidth}m{0.45\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<type> ::= `int' \alt <type> `->' <type>
\end{grammar}
&
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::=  ... \alt `\\' <ident> `:' <type> `.' <expr>
\end{grammar}
\end{tabular}

When extending the Object Algebra interface, pretty-printing operation and parser, we use two type parameters \inlinecode{E} and \inlinecode{T} for expressions and types. They guarantee that invalid terms such as \inlinecode{int + int} will be rejected by the parser.

\lstinputlisting[linerange=31-59]{../Scala/Parser/src/PaperCode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX
Besides lexing, the trait \inlinecode{TypedLamOAParser} also introduces parsers for types, and the new case for expressions. For the same reason,
we use \inlinecode{pTypedLamT} and \inlinecode{pTypedLamE} as copies of current \inlinecode{pT} and \inlinecode{pE}, recursively. \inlinecode{pT} and \inlinecode{pE} are actually the parsers for recursion.

From the code we observe that the multi-sorts of Object Algebra interface
exactly express multiple syntax. The isolation for different syntax
is guaranteed by the type system. Now it is straightforward to show some client code
for the new parser:

\lstinputlisting[linerange=63-65]{../Scala/Parser/src/PaperCode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX_CLIENT
It works just as expected to parse and pretty-print the result.
