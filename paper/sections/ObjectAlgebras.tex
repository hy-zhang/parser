\section{Object Algebras and Parsing}\label{sec:algebrasandparsing}

Object Algebras, first introduced by ... et al as a solution to the famous \textit{Expression Problem}, provide extensibility on
both data variants and operations for structures like abstract syntax trees. We integrate Object Algebras directly to enhance the
extensibility of open parsers.

\subsection{Object Algebras}\label{subsec:objectalgebras}
Object Algebras captures a design pattern to address the Expression Problem nicely,
achieving two dimensions of extensibility (data variants and operations) in a modular and type-safe way.
Because of this, the definition of data structures is separated from behaviors on them, and future extensions
to both sides no longer require existing code to be modified, supporting separate compilation.

In Object Algebras, ASTs as recursive data structures are defined using traits, where each constructor corresponds
to an abstract method inside. The example from Section~\ref{subsec:parsingwithopen} is again used here for illustration.
At first the language only supports variables and applications:
\begin{lstlisting}
trait ExprAlg[E] {
    def varE(x : String) : E
    def appE(e1 : E, e2 : E) : E
}
\end{lstlisting}
The language has two constructors: literals and additions. The trait \lstinline{ExprAlg} is called an \textit{Object Algebra interface},
whereas as a factory, it cannot produces objects for the expressions directly like traditional approaches, but abstract the results in its
type parameter \lstinline{E} instead. To realize an operation on expressions, we simply instantiate the type parameter by a concrete type and
provides implementations for all cases. Below is an example of collecting all free variables in an expression:
\begin{lstlisting}
trait FreeVars extends ExprAlg[List[String]] {
    def varE(x : String) = List(x)
    def appE(e1 : List[String], e2 : List[String]) = e1 ++ e2
}
\end{lstlisting}
Here \lstinline{FreeVars} is called an \textit{Object Algebra}. It traverses an expression bottom-up, and returns a list of strings as the result.
Furthermore, one can define a new trait to implement pretty-printing on expressions:
\begin{lstlisting}
trait ExprPrint extends ExprAlg[String] {
    def varE(x : String) = x
    def appE(e1 : String, e2 : String) = "(" + e1 + " " + e2 + ")"
}
\end{lstlisting}
On the other hand, the data variants can be extended by inheriting \lstinline{ExprAlg} and adding new cases only. Suppose we want to
have literals in expressions, a new Object Algebra interface \lstinline{LitAlg} is defined as follows:
\begin{lstlisting}
trait LitAlg[E] extends ExprAlg[E] {
    def litE(n : Int) : E
}
\end{lstlisting}
Now pretty-printing on the new language can be realized by code reuse, without modifying existing code:
\begin{lstlisting}
trait LitPrint extends ExprPrint {
    def litE(n : Int) = n.toString
}
\end{lstlisting}
On this, to create an expression of \lstinline{LitAlg}, a generic method is defined as follows:
\begin{lstlisting}
def build[E](alg : LitAlg[E]) : E =
    alg.appE(alg.varE("x"), alg.litE(3))
\end{lstlisting}
Such a method implicitly represents the expression \lstinline{"x 3"}. The code
\begin{lstlisting}
build(new LitPrint(){})
\end{lstlisting}
results in \lstinline{"(x 3)"}, as the result of pretty-printing. Now we observe that an ``object'' of expression actually
has the function type \lstinline{LitAlg[E] =>} \lstinline{E} for generic \lstinline{E}. At this point, one may argue
that it is illusory compared to traditional objects, and since we are struggling against the parsing problem, if a parser
produces structures as functions, it could be hardly be further processed like objects, especially, in the design of a compiler
there will be a lot of desugarings (or transformations). However, we argue that this is not an issue, because functions can be used
in a very clever way. For example, if one wants to transform an \lstinline{ExprAlg} expression to a \lstinline{LitAlg} expression by
replacing some variables with values based on a variable environment, a transformation algebra can be implemented as follows:
\begin{lstlisting}
trait Refactor[E] extends ExprAlg[E] {
    def alg : SubAlg[E]
    def env : Map[String, Int]
    def varE(x : String) = if (env.contains(x)) alg.litE(env(x)) else alg.varE(x)
}
\end{lstlisting}\haoyuan{Is this example OK?}
When \lstinline{env = Map("y"} \lstinline{-> 3)}, the \lstinline{ExprAlg} expression \lstinline{"x y"} is changed to \lstinline{LitAlg} expression \lstinline{"x 3"}. The abstract method
\lstinline{alg} in \lstinline{Refactor} can be any algebra of \lstinline{SubAlg}, simply for delegation. By passing a concrete implementation
to \lstinline{alg}, \lstinline{Refactor} will be able to apply transformation to an \lstinline{ExprAlg} expression before \lstinline{alg} returns the result.

\subsection{Parsing with Object Algebras}\label{subsec:parsingwithoa}

Just as shown above, \lstinline{ExprAlg} is defined for a small language in an Object-Algebra style. Furthermore,
A parser can be defined for this whole language at once. Since Object Algebras represent ``objects'' implicitly as functions like \lstinline{ExprAlg[E] =>} \lstinline{E} for generic \lstinline{E}, such a parser should consume an algebra from its parameter, then return a value of \lstinline{Fix[Parser[E]]} as in open recursion, where \lstinline{E} is abstract.
\begin{lstlisting}
trait ExprParser[E] {
    val pE : ExprAlg[E] => Fix[Parser[E]] = alg => p =>
        ident ^^ alg.varE |||
        p ~ p ^^ { case e1 ~ e2 => alg.appE(e1, e2) }
}
\end{lstlisting}
It is observed that \lstinline{pE} is in fact a parser generator, where \lstinline{alg} appears as a parameter, which can be any algebra, and after \lstinline{alg} is fed, it returns a \lstinline{Fix[Parser[E]]}. Again \lstinline{p} is the explicit self-reference of the open parser. Inside the body, the algebra is invoked correspondingly for all cases right after parsing. Note that the two cases are combined using the original \lstinline{|||} operator. To make \lstinline{alg} as a generic algebra, the enclosing trait of the parser, namely \lstinline{ExprParser}, is abstracted over \lstinline{E}. Behaviors, or algebras that can be fed to such a parser, are expected to be defined independently from the Object Algebra interface, just like the algebra \lstinline{ExprPrint} in Section~\ref{subsec:objectalgebras}.

To explain the modularity, we again add literals to expressions, but instead of using inheritance as Section~\ref{subsec:objectalgebras}, \lstinline{LitAlg} is defined independently together with its own parser and algebra:
\begin{lstlisting}
trait LitAlg[E] {
    def litE(n : Int) : E
}

trait LitPrint {
    def litE(n : Int) = n.toString
}

trait LitParser[E] {
    val pE : LitAlg[E] => Fix[Parser[E]] = alg => p =>
        numericLit ^^ alg.litE
}
\end{lstlisting}
In this case, \lstinline{LitAlg} is yet another small language, which is self-contained. To merge the two languages together, we require their grammars
to be merged, and we obtain a combined language, whose parser integrates the two small parsers using alternative. In Scala we use compound types, namely use \lstinline{"with"} for two Object Algebra interface types, to avoid polluting the namespace.

\begin{lstlisting}
trait ExprLitParser[E] {
    val pE : (ExprAlg[E] with LitAlg[E]) => Fix[Parser[E]] = alg => p => {
        val pExprE = new ExprParser[E](){}.pE(alg)(p)
        val pLitE = new LitParser[E](){}.pE(alg)(p)
        pExprE ||| pLitE
    }
}
\end{lstlisting}

In client code, a user can either define a new function with type \lstinline{(ExprAlg[E] with LitAlg[E]) =>} \lstinline{Parser[E]} based on \lstinline{pE}, which implies an algebra is applied after \lstinline{fix}, or simply feed an algebra to \lstinline{pE} at first, then obtain the result from \lstinline{fix}:
\begin{lstlisting}
trait ExprLitPrint extends ExprPrint with LitPrint
val parsePrint = fix(new ExprLitParser[String](){}.pE(new ExprLitPrint(){}))
val result = runParser(parsePrint)("x 3") // prints "(x 3)"
\end{lstlisting}
\haoyuan{Is there a way to avoid defining ExprLitPrint?}

\subsection{Parsing with Multiple Syntax}\label{subsec:differentsyntax}

One intuition of using Object Algebras, as illustrated above, is to separate data structures from behaviors, so as to modularize the design, and both parts are even more modular and reusable. We can simply add new variants corresponding to the new cases in the grammar, or realize different operations on structures, without modifying existing code, meanwhile separate compilation is supported. Another one is that Object Algebras benefit us from using generics, where we can abstract multiple syntax in the type parameters, and define less classes, simplifying code comparatively. Below we refactor the last example in Section~\ref{subsec:parsingwithopen}, by defining a new Object Algebra interface with two cases \lstinline{intT} and \lstinline{lamE}. Meanwhile a parser is implemented for that language.
\begin{lstlisting}
trait LamAlg[E, T] {
    def intT() : T
    def lamE(x : String, t : T, e : E) : E
}

trait LamParser[E, T] {
    type Pair = (Parser[E], Parser[T])
    val pE : LamAlg[E, T] => (=> Pair) => Parser[E] = alg => p =>
        ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1)
            ^^ { case x ~ t ~ e => alg.lamE(x, t, e) }
    val pT : LamAlg[E, T] => (=> Pair) => Parser[T] = alg => p =>
        "Int" ^^ { _ => alg.intT() }
}
\end{lstlisting}
\lstinline{LamParser} contains parsers for both expressions and types. From the code we observe that the multi-sorts of Object Algebra interface
exactly express multiple syntax. At this point, to combine these two small components together we need some ``glue code''. But instead of writing composition by hand, we reimplement the combinator \lstinline{|||}, to compose one parser with type \lstinline{Alg1 =>} \lstinline{(=>} \lstinline{R)} \lstinline{=>} \lstinline{Parser[E]} and another one with type \lstinline{Alg2 =>} \lstinline{(=>} \lstinline{R)} \lstinline{=>} \lstinline{Parser[E]} using alternative. Note that we can only abstract over the whole algebra interface type, instead of working on its type parameters, as the number of type parameters is not fixed. In summary, \lstinline{"|||"} produces a combined parser, which takes a compound algebra as its parameter:
\begin{lstlisting}
implicit class Combinator[Alg1, Alg2, R, E](x : Alg1 => (=> R) => Parser[E]) {
    def |||(y : Alg2 => (=> R) => Parser[E]): (Alg1 with Alg2) => (=> R) => Parser[E]
        = alg => l => x(alg)(l) ||| y(alg)(l)
}
\end{lstlisting}
Now it is sufficient to merge \lstinline{ExprParser} and \lstinline{LamParser} together:
\begin{lstlisting}
trait ExprLamParser[E, T] {
    val pExpr = new ExprParser[E](){}
    val pLam = new LamParser[E, T](){}
    val pExprE : ExprAlg[E] => (=> pLam.Pair) => Parser[E] =
        alg => p => pExpr.pE(alg)(p._1)

    val pE = pExprE ||| pLam.pE
    val pT = pLam.pT
}
\end{lstlisting}
Parsers for expressions and types are connected using \lstinline{|||}, respectively. Hence the isolation for different syntax
is guaranteed by the type system. The only left problem is that we still need to replace the parser in \lstinline{ExprParser} with \lstinline{pExprE}
by updating the fix-point parameter. In the next section we will address this problem, and meanwhile our implementation enhances modularity in various aspects.

