\section{Full Extensibility with Object Algebras}\label{sec:algebrasandparsing}

The inheritance-based approach benefits us from building extensible parsers, based on an OO class hierarchy.
Nevertheless, the addition of new operations over ASTs is problematic using traditional OO classes. Often it requires modification on existing code, which breaks modularity. In this section, we will have a closer look at how Object Algebras is applied for full extensibility.

\subsection{Problem with Traditional OO ASTs}\label{subsec:problemwithoutoa}

Now it comes to Extension 2 in Section~\ref{subsec:parsingproblem}. In the previous code, we have pretty-printing as
an example of operations on ASTs. Suppose we also want to collect free variables on the expression language which models
literals, additions and variables. Based on the traditional OO class hierarchy, one attempt would be extending \inlinecode{Expr} with the new
operation directly:

\lstinputlisting[linerange=19-19]{../Scala/Parser/src/PaperCode/Sec4OA/Code1.scala}% APPLY:linerange=ATTEMPT_EXPRWITHFREEVARS

It refers to one Scala solution to the Expression Problem.\huang{what's the solution? does it have the later "critical issue"? if so, why is it a "solution"} But then programmers have to define new classes for literals, additions and variables
by extending the old ones together with \inlinecode{FreeVarsExpr}. The critical issue is that, the existing parsing code only generates objects of the old
types, again it is a modularity issue, since it is a bad idea to modify existing code again and again with extensions. Other solutions including modelling constructors as functions introduce unnecessary complexity.

In contrast, Object Algebras~\cite{Oliveira2012} enables us to solve this problem. As a nice solution, it separates data variants
and operations, and offers high flexibility in the choice of operations to be performed over ASTs. Before adopting it for parsing, the next section introduces the background of Object Algebras.

\subsection{Object Algebras}\label{subsec:objectalgebras}
Object Algebras captures a design pattern to address the Expression Problem nicely, achieving two dimensions of extensibility (data variants and operations) in a modular and type-safe way. The definition of data structures is separated from their behaviors, and future extensions on both dimensions no longer require existing code to be modified, supporting separate compilation.

Using Object Algebras in Scala, ASTs as recursive data structures are defined by traits, where each constructor corresponds to an abstract method inside. The example from Section~\ref{subsec:packratparsing} is used here again for illustration.
At first the language only supports literals and additions:

\lstinputlisting[linerange=5-8]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_ALG
We have two constructors \inlinecode{lit} and \inlinecode{add}, corresponding to literals and additions. The trait \inlinecode{ExprAlg} is called an \textit{Object Algebra interface},
whereas as a factory, it cannot produces objects for the expressions directly like traditional approaches, but abstract the results in its
type parameter \inlinecode{E} instead. To realize an operation on expressions, we simply instantiate the type parameter by a concrete type and
provides implementations for all cases. Below is an example of pretty-printing an expression:

\lstinputlisting[linerange=12-15]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_PRINT
Here \inlinecode{Print} is called an \textit{Object Algebra}. It traverses an expression bottom-up, and returns a string as the result.
One can define evaluation operation as a new trait on this expression langauge:

\lstinputlisting[linerange=19-22]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_EVAL

Futhermore, the data variants can be extended by inheriting \inlinecode{ExprAlg} and adding new cases only. Now we extend the language
with variables. A new Object Algebra interface \inlinecode{VarAlg} is defined as follows:

\lstinputlisting[linerange=26-28]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_ALGEXT
Now pretty-printing on the new language can be realized without modifying existing code:

\lstinputlisting[linerange=32-34]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_EXTPRINT
An observation is that only the new case is implemented for pretty-printing, and the others have been inherited.
It offers programmers great code reuse, in the sense that existing cases can also be
overridden in \inlinecode{VarExprPrint}.

To create an expression representing \inlinecode{1 + x}, a generic method is defined as follows:

\lstinputlisting[linerange=41-41]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_MAKEEXP

The code below results in \inlinecode{"(1 + x)"}, as the result of pretty-printing that expression.

\begin{lstlisting}
makeExp(new VarExprPrint {})
\end{lstlisting}

Now we observe that an ``object'' of expression actually
has the function type \inlinecode{VarExprAlg[E] =>} \inlinecode{E} for generic \inlinecode{E}. Comparing with traditional objects, one may have concern that if a parser produces function structures, it could be hard to further process them. Especially, in the design of a compiler
there will be a lot of desugarings (or transformations). However, we argue that this is not an issue, because functions can be used
in a very clever way. For example, if one wants to transform a \inlinecode{VarExprAlg} expression to an \inlinecode{ExprAlg} expression by
replacing some variables with values based on a variable environment, a transformation algebra can be implemented as follows:\haoyuan{mention in discussion that shy deals with boilerplate.}

\lstinputlisting[linerange=45-56]{../Scala/Parser/src/PaperCode/Sec4OA/Code2.scala}% APPLY:linerange=OVERVIEW_OA_REFACTOR
Here the \inlinecode{VarExprAlg} expression \inlinecode{"1 + x"} is changed to \inlinecode{ExprAlg} expression \inlinecode{"1 + 2"}, before the pretty-printing algebra is applied. The abstract method
\inlinecode{alg} in \inlinecode{Refactor} can actually be any algebra simply for delegation. By passing a concrete implementation
to \inlinecode{alg}, \inlinecode{Refactor} will be able to transform a \inlinecode{VarExprAlg} expression before we obtain the result.

\subsection{Parsing with Object Algebras}\label{subsec:parsingwithoa}

Just as shown above, \inlinecode{ExprAlg} is defined for a small language using Object Algebras. Since Object Algebras represent ``objects'' implicitly as functions like \inlinecode{ExprAlg[E] =>} \inlinecode{E} for abstract \inlinecode{E}, we first try to build the corresponding parser by type \inlinecode{ExprAlg[E] =>} \inlinecode{Parser[E]}.

\lstinputlisting[linerange=8-16]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=BASE_OA_PARSER_BAD
Such a parser works fine, yet it does not appear to be extensible. For example, we have demonstrated in Section~\ref{subsec:overriding} that method overriding is essential to update \inlinecode{pExpr} for an extended syntax. However, now \inlinecode{pExpr} has type \inlinecode{VarExprAlg[E] =>} \inlinecode{Parser[E]}, where the type of Object Algebra interface appears in \emph{contravariant} position. This difference prohibits method overriding, because Object Algebra interfaces extended from \inlinecode{VarExprAlg} are subtypes of it, but the types of their parsers are supertypes of \inlinecode{VarExprAlg[E] =>} \inlinecode{Parser[E]}.

This problem refers to \textit{binary methods}. \haoyuan{Shall we mention this?}\huang{???}

One solution to this problem is taking out the argument as a single field, hence it supports overriding as well. We rewrite the parsing code as follows:

\lstinputlisting[linerange=23-33]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=BASE_OA_PARSER
This is precisely the pattern that we advocate for modular parsing. Note that \inlinecode{pE} is the one that is used for recursive calls, exported by the trait and considered to be overridden during inheritance. The reason why we use an extra and seemingly redundant \inlinecode{pExpr}, is a subtle issue caused by Scala language and its parser combinator library. There is a restriction of \inlinecode{super} keyword in Scala that \inlinecode{super} can only use fields defined by keyword \inlinecode{def}, can not use those defined by \inlinecode{val}, while the parser combinator library suggests using \inlinecode{val} to define parsers, especially for left-recursive ones. Our workaround is that we use different synonyms for \inlinecode{pE} in different traits, so that we can directly distinguish them by names without using \inlinecode{super}.

Now let's try this pattern with the extension of varibles, which we have been using:
\lstinputlisting[linerange=37-48]{../Scala/Parser/src/PaperCode/Sec4OA/Code3.scala}% APPLY:linerange=EXT_OA_PARSER
In the client code shown above, an instance of algebra is fed to \inlinecode{VarExprOAParser} for pretty-printing expressions. Then the trait exports \inlinecode{pE}, parses the input and applies the algebra. The result shows that such a pattern is a nice solution to modular parsing. At this point, one may argue that with a different operation like evaluation, the redundant code is required to obtain the parser, and it results in parsing the same input twice. However, that is generally solved~\cite{Oliveira2012} \huang{it was "original object algebra paper", i added the citation here, is it the correct one? i'll check later} by composing two algebras into one in advance.

\subsection{Parsing Multi-sort Syntax}\label{subsec:differentsyntax}

\huang{to polish}As illustrated above, one intuition of using Object Algebras is to separate data structures from behaviors, so as to modularize the design, and both parts are even more modular and reusable. We can simply add new variants corresponding to the new cases in the grammar, and realize different operations on structures, with both code reuse and separate compilation supported.

Another advantage of using Object Algebras is that we benefit from using generics. If the syntax contains multiple sorts, we can distinguish them by different type parameters. Thus fewer classes are defined and code is simplified. As an example, we extend the language of literals, additions and variables by introducing types as a new sort. Now it has two sorts in the syntax, types and expressions. We certainly do not want to mix them together.\\

\begin{tabular}{m{0.45\linewidth}m{0.45\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<type> ::= `int' \alt <type> `->' <type>
\end{grammar}
&
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::=  ... \alt `\\' <ident> `:' <type> `.' <expr>
\end{grammar}
\end{tabular}

When extending the Object Algebra interface, pretty-printing operation and parser, we use two type parameters \inlinecode{E} and \inlinecode{T} for expressions and types. They guarantee that invalid terms such as \inlinecode{int + int} will be rejected by the parser.

\lstinputlisting[linerange=31-59]{../Scala/Parser/src/PaperCode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX
Besides lexing, the trait \inlinecode{TypedLamOAParser} also introduces parsers for types, and the new case for expressions. For the same reason,
we use \inlinecode{pTypedLamT} and \inlinecode{pTypedLamE} as copies of current \inlinecode{pT} and \inlinecode{pE}, recursively. \inlinecode{pT} and \inlinecode{pE} are actually the parsers for recursion.

From the code we observe that the multi-sorts of Object Algebra interface
exactly express multiple syntax. The isolation for different syntax
is guaranteed by the type system. Now it is straightforward to show some client code
for the new parser:

\lstinputlisting[linerange=63-65]{../Scala/Parser/src/PaperCode/Sec4OA/Code4.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX_CLIENT
It works just as expected to parse and pretty-print the result.
