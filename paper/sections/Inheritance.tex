\section{Modularizing Parsers with Inheritance}\label{sec:inheritance}

This section introduces the problem that motivates our work. In Figure~\ref{fig:packrat-arith} we have observed
that Packrat parsers can be defined in a convenient way, with recursive calls. The example is actually inspired
by Walder's Expression Problem. Similarly, our goal is to build parsers that are extensible in some dimensions.

\subsection{Dimensions of Extensibility}
We continue with the expression language of literals and additions. At this point,
one would like to have two kinds of extensions:

%\section{An Overview of \name}\label{sec:overview}
%
%This section gives an overview of our library \name, motivates
%additional problems that occur when parsing modular ASTs.  The first
%problem is that traditional parsers using parser combinators use
%hard-coded recursive calls. This problem is solved using
%delegation-based techniques, which enable parsing OO ASTs.  The second
%problem is how to achieve dual extensibility of ASTs (that is: how to
%allow for both new language constructs and new operations over the
%ASTs). This problem is solved using Object Algebras.

\begin{comment}
Basically, \name consists of four parts: underlying parsing technique, delegation mechanism encoded by open recursion, Object Algebras, and glue code of new combinators and utility functions. We start from Section \ref{subsec:overview-parsing}, which discusses the choice of parsing technique and how it affects modularity of parsers. Section \ref{subsec:overview-problem} demonstrates the goal of extending parsers together with ASTs in a semantic modular way, with both separate compilation and type-safe code reuse. Then we will see traditional parser combinators fail to achieve it because of hard-coded recursive calls. In Section \ref{subsec:overview-delegation}, we show how delegation can solve this problem and allow us to build extensible parsers. Finally, Section \ref{subsec:overview-oa} gives examples of using Object Algebras for more extensibility, including extension of operations and parsing multiple sorts of syntax.\haoyuan{TODO}
\end{comment}

\begin{comment}
\subsection{Choosing the Parsing Technique}\label{subsec:overview-parsing}

%A technique for type-safe modular parsing should the following 3
%features: \emph{modular type-checking}; \emph{separate compilation};
%low performance overhead

In the last section, we have argued that parser combinators are a suitable parsing technique for
our purpose, as they naturally build modular parsers for type-checking.
Unfortunately many parser combinators have important limitations.
In particular several parser combinators,
including the famous Parsec~\cite{Leijen2001} library, require
programmers to manually do \textit{left-recursion elimination} and \textit{longest match composition}, and
require significant amounts of \textit{backtracking}. All of them are
problematic in a modular setting.




\paragraph{Packrat Parsing}
Fortunately some more advanced parsing techniques such as Packrat
parsing~\cite{Ford2002}, address the limitations of simple parser combinators
such as Parsec. Packrat parsers use
memoization to record the result of applying each parser at each
position of the input, so that repeated computation is eliminated.
Moreover, theoretically the algorithm behind Packrat parsers
supports both direct and indirect left-recursion~\cite{warth2008}.
The current version of the library is still
buggy with indirect left-recursion, but we believe that
they will fix it in the future, and direct left-recursion is
already practical to use for a large number of applications. All of these properties are very
suitable for modularity, thus we decided to use Packrat parsers as the underlying
parsing technique in \name.


It is worth mentioning that the choice of parser combinators will not
affect the other parts of our library. One can choose other parser
combinators like Parsec, in cases that the performance and supporting
of left-recursion are not major concerns. A different library can even build a new
\name with fancy features or higher efficiency.
\end{comment}

%\huang{done, added the attempt/failure/reason of extending conventional parsers}\bruno{You are not motivating the problem! You are going straight to
%  the solution without pointing out what the problem is first. What
%  you need to do is: First show what happens with conventional
%  parsers: at some point, if you add extensions the recursive calls
%  will be wrong. Then you show (in the next section) the solution:
% use delegation/open recursion.}

%\huang{partly done, only extend a new language construct in the example, how about leaving extension of new operations in the OA subsection?}\bruno{I think we need to set up a challenge here, similar to the challenge of
%  the expression problem. The challenge should be like. Build a parser
%for a simple expression language, then extend the language with both
%a new language construct and a new operation. This section will show
%how we can do that using traditional parsers, but without modular
%type-safety and separate compilation. The remaining sections will show
%that the techniques introduced by us, enable us to solve those two challenges.}

\begin{itemize}
\item \textbf{Extension 1}: adding a new case (or rather, a new construct) to \lstinline{Expr};
\item \textbf{Extension 2}: adding a new operation to \lstinline{Expr}.
\end{itemize}

\paragraph{Attempt to Extend the Parser} Now we first consider
extension 1, namely we are extending the syntax as well as the parser. Hence we introduce variables as a new case.

\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= ...
   \alt <ident>
\end{grammar}

As in an OO solution to the Expression Problem, it is easy to extend
the corresponding AST:

\lstinputlisting[linerange=95-97]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=OVERVIEW_SIMPLE_LAM

And since we already have the parser for literals and additions, we would
like to build the new parser by reusing the old one. Here one may quickly come up
with the following attempt, where a new parser is defined for \lstinline{Var}, then composed
with \lstinline{pExpr}:

\lstinputlisting[linerange=62-63]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=BAD_ATTEMPT

Unfortunately, it fails to parse some expressions like \lstinline{"1 + x"}, which is obviously valid in the new grammar.
The reason is that \lstinline{pAdd} makes two recursive calls to parse sub-expressions, by using \lstinline{pExpr}, which
covers both cases in the old grammar. But the newly added case \lstinline{pVar} is not observed by the recursive \lstinline{pExpr},
hence the parser does not work as expected. Still, one may continue to change the recursive call in \lstinline{pAdd} with \lstinline{pExtExpr},
but modification on existing code sacrifices separate compilation, as mentioned by the Expression Problem.

\subsection{Inheritance-Based Approach}\label{subsec:inheritance-approach}

Fortunately in Scala we can make use of inheritance for modular parsing. Specifically,
the new parser can be defined in an enclosing trait that extends
the old one:

\lstinputlisting[linerange=68-73]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=INHERITANCE_APPROACH
Now \lstinline{ExtParser} successfully represents the parser for the extended language, because Scala uses dynamic dispatch for
method overriding in inheritance. When the input \lstinline{"1 + x"} is fed to the parser \lstinline{this.pExpr}, it firstly delegates
the work to \lstinline{super.pExpr}, which parses literals and additions. However, the recursive call \lstinline{pExpr} in \lstinline{pAdd}
actually refers to \lstinline{this.pExpr} again, due to dynamic dispatch. It implies that the recursive call has included the extension. This
elegant inheritance-based approach opens the recursion of parsers in a modular way.

Notice that Scala has a linearized-style multiple inheritance for traits. It can be very helpful when composing several languages. Suppose now
we want to compose the parsers for expressions from pre-defined languages \lstinline{LanguageA} and \lstinline{LanguageB} using alternative.
The use of keyword \lstinline{super} is able to
specify the implementation from inheritance, like:

\lstinputlisting[linerange=78-84]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=MULTIPLE_INHERITANCE

As we demonstrated, inheritance is the key technique to obtain semantic modularity.
It enables type-safe code reuse and separate compilation for parsing OO style ASTs with extension 1.

\subsection{Object Algebras for full Extensibility}\label{subsec:overview-oa}

Although delegation enables OO extensibility, the use of an OO class
hierarchy makes the addition of new operations over the AST
problematic. Modification on existing code breaks the modularity. This
refers to the famous \textit{Expression Problem} []. For challenge 2, suppose now we want to
support evaluation on expressions, in Scala one attempt would be extending \lstinline{Expr} with
evaluation:

\lstinputlisting[linerange=178-178]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=OVERVIEW_ATTEMPT_EXPRWITHEVAL
But then the programmer has to define new classes for literals and additions that extend old ones and \lstinline{EvalExpr}. Specifically,
the critical point is that existing parsing code only generates \lstinline{Expr} objects with pretty printing, so modification on parsing is again required.


In contrast, Object Algebras~\cite{Oliveira2012} enable us to solve this problem, as it separates data variants and
operations, to
offer high flexibility in the choice of operations to be performed
over the AST. It also makes parsing with multiple sorts of syntax easier.

\paragraph{Parsing with Object Algebras} Using Object Algebras, the abstract syntax of the expression language is defined as below.

\lstinputlisting[linerange=8-11]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_ALG

Then we are able to define operations over the syntax in a modular way. For instance, pretty printing operation can be realized as:

\lstinputlisting[linerange=15-18]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_PRINT

And also parser for it as below. Notice the parsing function \inlinecode{pExpr} now takes an argument of type \inlinecode{ExprAlg[E]}, which means it accepts any instance of \inlinecode{ExprAlg}. Such an instance can for example be \lstinline{Print}, which takes charge of operations on expressions, and parsing code only does delegation.

\lstinputlisting[linerange=22-27]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_PARSER

\haoyuan{I'm trying to avoid using terminology like algebra and algebra interface.}

\paragraph{Extensibility of Syntax} Following previous examples, the code below shows how to extend the language with variables.

\lstinputlisting[linerange=31-44]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_EXT
Note that we use the new combinator \lstinline{<|>} defined in our library, to compose two parsing functions into one. The function \lstinline{pExtExpr} has the compound type \lstinline{ExprAlg[E] with VarAlg[E]} in its argument, where two language ASTs are combined to represent the new language.

To use the parser, we must provide an algebra instance as the operation to construct the parsing results. In the code below, we use the combination of \lstinline{Print} and \lstinline{PrintVar}, so that the parsing result is a pretty printing of the AST.

\lstinputlisting[linerange=53-58]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_USE

\paragraph{Extensibility of Operations} With Object Algebras, operations over ASTs can also be extended in a modular way. Here is an example of collecting free variables from an expression. We can feed this operation to the parser and obtain a set of free variables.

\lstinputlisting[linerange=72-78]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_EXT_OP

\haoyuan{I think in our library language ASTs are composed using intersection, not inheritance.}

\paragraph{Multiple Sorts of Syntax} Another advantage of using Object Algebras is that it supports multiple sorts of syntax easily. In several cases, we want to divide the syntactic elements into some groups. For example, the grammar below has two sorts, which are expressions and types.

\begin{tabular}{m{0.45\linewidth}m{0.45\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<type> ::= `int' \alt <type> `->' <type>
\end{grammar}
&
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::=  `\\' <ident> `:' <type> `.' <expr>
\end{grammar}
\end{tabular}

Using Object Algebras, we can easily distinguish them just by adding an extra type parameter. The abstract syntax is
presented below:

\lstinputlisting[linerange=63-67]{../Scala/Parser/src/PaperCode/Overview/OA.scala}% APPLY:linerange=OVERVIEW_OA_MULTI_SYNTAX
In the next sections, we will discuss them with more details.
