\section{Modularizing Parsers with Inheritance}\label{sec:inheritance}

This section introduces the problem that motivates our work. In Figure~\ref{fig:packrat-arith} we have observed
that Packrat parsers can be defined in a convenient way, with recursive calls. The example is actually inspired
by Walder's Expression Problem. Similarly, our goal is to build parsers that are extensible in some dimensions.

\subsection{Dimensions of Extensibility}\label{subsec:dimensions}
We continue with the expression language of literals and additions. At this point,
one would like to have two kinds of extensions:

%\section{An Overview of \name}\label{sec:overview}
%
%This section gives an overview of our library \name, motivates
%additional problems that occur when parsing modular ASTs.  The first
%problem is that traditional parsers using parser combinators use
%hard-coded recursive calls. This problem is solved using
%delegation-based techniques, which enable parsing OO ASTs.  The second
%problem is how to achieve dual extensibility of ASTs (that is: how to
%allow for both new language constructs and new operations over the
%ASTs). This problem is solved using Object Algebras.

\begin{comment}
Basically, \name consists of four parts: underlying parsing technique, delegation mechanism encoded by open recursion, Object Algebras, and glue code of new combinators and utility functions. We start from Section \ref{subsec:overview-parsing}, which discusses the choice of parsing technique and how it affects modularity of parsers. Section \ref{subsec:overview-problem} demonstrates the goal of extending parsers together with ASTs in a semantic modular way, with both separate compilation and type-safe code reuse. Then we will see traditional parser combinators fail to achieve it because of hard-coded recursive calls. In Section \ref{subsec:overview-delegation}, we show how delegation can solve this problem and allow us to build extensible parsers. Finally, Section \ref{subsec:overview-oa} gives examples of using Object Algebras for more extensibility, including extension of operations and parsing multiple sorts of syntax.\haoyuan{TODO}
\end{comment}

\begin{comment}
\subsection{Choosing the Parsing Technique}\label{subsec:overview-parsing}

%A technique for type-safe modular parsing should the following 3
%features: \emph{modular type-checking}; \emph{separate compilation};
%low performance overhead

In the last section, we have argued that parser combinators are a suitable parsing technique for
our purpose, as they naturally build modular parsers for type-checking.
Unfortunately many parser combinators have important limitations.
In particular several parser combinators,
including the famous Parsec~\cite{Leijen2001} library, require
programmers to manually do \textit{left-recursion elimination} and \textit{longest match composition}, and
require significant amounts of \textit{backtracking}. All of them are
problematic in a modular setting.




\paragraph{Packrat Parsing}
Fortunately some more advanced parsing techniques such as Packrat
parsing~\cite{Ford2002}, address the limitations of simple parser combinators
such as Parsec. Packrat parsers use
memoization to record the result of applying each parser at each
position of the input, so that repeated computation is eliminated.
Moreover, theoretically the algorithm behind Packrat parsers
supports both direct and indirect left-recursion~\cite{warth2008}.
The current version of the library is still
buggy with indirect left-recursion, but we believe that
they will fix it in the future, and direct left-recursion is
already practical to use for a large number of applications. All of these properties are very
suitable for modularity, thus we decided to use Packrat parsers as the underlying
parsing technique in \name.


It is worth mentioning that the choice of parser combinators will not
affect the other parts of our library. One can choose other parser
combinators like Parsec, in cases that the performance and supporting
of left-recursion are not major concerns. A different library can even build a new
\name with fancy features or higher efficiency.
\end{comment}

%\huang{done, added the attempt/failure/reason of extending conventional parsers}\bruno{You are not motivating the problem! You are going straight to
%  the solution without pointing out what the problem is first. What
%  you need to do is: First show what happens with conventional
%  parsers: at some point, if you add extensions the recursive calls
%  will be wrong. Then you show (in the next section) the solution:
% use delegation/open recursion.}

%\huang{partly done, only extend a new language construct in the example, how about leaving extension of new operations in the OA subsection?}\bruno{I think we need to set up a challenge here, similar to the challenge of
%  the expression problem. The challenge should be like. Build a parser
%for a simple expression language, then extend the language with both
%a new language construct and a new operation. This section will show
%how we can do that using traditional parsers, but without modular
%type-safety and separate compilation. The remaining sections will show
%that the techniques introduced by us, enable us to solve those two challenges.}

\begin{itemize}
\item \textbf{Extension 1}: adding a new case (or rather, a new construct) to \lstinline{Expr};
\item \textbf{Extension 2}: adding a new operation to \lstinline{Expr}.
\end{itemize}

\paragraph{Attempt to Extend the Parser} Now we first consider
extension 1, namely we are extending the syntax as well as the parser. Hence we introduce variables as a new case.

\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= ...
   \alt <ident>
\end{grammar}

As in an OO solution to the Expression Problem, it is easy to extend
the corresponding AST:

\lstinputlisting[linerange=98-100]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=OVERVIEW_SIMPLE_LAM

And since we already have the parser for literals and additions, we would
like to build the new parser by reusing the old one. Here one may quickly come up
with the following attempt, where a new parser is defined for \lstinline{Var}, then composed
with \lstinline{pExpr}:

\lstinputlisting[linerange=62-63]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=BAD_ATTEMPT

Unfortunately, it fails to parse some expressions like \lstinline{"1 + x"}, which is obviously valid in the new grammar.
The reason is that \lstinline{pAdd} makes two recursive calls to parse sub-expressions, by using \lstinline{pExpr}, which
covers both cases in the old grammar. But the newly added case \lstinline{pVar} is not observed by the recursive \lstinline{pExpr},
hence the parser does not work as expected. Still, one may continue to change the recursive call in \lstinline{pAdd} with \lstinline{pVarExpr},
but modification on existing code sacrifices separate compilation, as mentioned by the Expression Problem.

\subsection{Inheritance-Based Approach}\label{subsec:inheritance-approach}

Fortunately in Scala we can make use of inheritance for modular parsing. Specifically,
the new parser can be defined in an enclosing trait that extends
the old one:

\lstinputlisting[linerange=68-73]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=INHERITANCE_APPROACH
Now \lstinline{VarExprParser} successfully represents the parser for the extended language, because Scala uses dynamic dispatch for
method overriding in inheritance. When the input \lstinline{"1 + x"} is fed to the parser \lstinline{this.pExpr}, it firstly delegates
the work to \lstinline{super.pExpr}, which parses literals and additions. However, the recursive call \lstinline{pExpr} in \lstinline{pAdd}
actually refers to \lstinline{this.pExpr} again, due to dynamic dispatch. It implies that the recursive call has included the extension. This
elegant inheritance-based approach opens the recursion of parsers in a modular way.

Notice that Scala has a linearized-style multiple inheritance for traits. It can be very helpful when composing several languages. Suppose now
we want to compose the parsers for expressions from pre-defined languages \lstinline{LanguageA} and \lstinline{LanguageB} using alternative.
The use of keyword \lstinline{super} is able to
specify the implementation from inheritance, like:

\lstinputlisting[linerange=78-84]{../Scala/Parser/src/PaperCode/Overview/Overview.scala}% APPLY:linerange=MULTIPLE_INHERITANCE

As we demonstrated, inheritance is the key technique to obtain semantic modularity.
It enables type-safe code reuse and separate compilation for parsing OO style ASTs with extension 1.


