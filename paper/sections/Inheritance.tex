\begin{comment}
Basically, \name consists of four parts: underlying parsing technique, delegation mechanism encoded by open recursion, Object Algebras, and glue code of new combinators and utility functions. We start from Section \ref{subsec:overview-parsing}, which discusses the choice of parsing technique and how it affects modularity of parsers. Section \ref{subsec:overview-problem} demonstrates the goal of extending parsers together with ASTs in a semantic modular way, with both separate compilation and type-safe code reuse. Then we will see traditional parser combinators fail to achieve it because of hard-coded recursive calls. In Section \ref{subsec:overview-delegation}, we show how delegation can solve this problem and allow us to build extensible parsers. Finally, Section \ref{subsec:overview-oa} gives examples of using Object Algebras for more extensibility, including extension of operations and parsing multiple sorts of syntax.\haoyuan{TODO}
\end{comment}

\begin{comment}
It is worth mentioning that the choice of parser combinators will not
affect the other parts of our library. One can choose other parser
combinators like Parsec, in cases that the performance and supporting
of left-recursion are not major concerns. A different library can even build a new
\name with fancy features or higher efficiency.
\end{comment}


\section{Modularizing Parsers with Inheritance}\label{sec:inheritance}

This section introduces the problem of semantic modular parsing which motivates our work, and an initial solution using only standard inheritance in OO.

\subsection{Modular Parsing Problem}\label{subsec:parsingproblem}
\huang{or "Parsing Extensible ASTs" ?}
The extensibility issues of AST structures and operations that process them, can be illustrated by the famous Expression Problem~\cite{wadler1998expression}. There are two dimensions of extensibility:

\begin{itemize}
\item \textbf{Extension 1}: adding a new data variant (or rather, a new constructor of ASTs).
\item \textbf{Extension 2}: adding a new operation over ASTs.
\end{itemize}

We already have solutions such Object Algebras~\cite{Oliveira2012} for this problem. However, when ASTs evolve, the corresponding parsers which produce such structures should also change accordingly. Our motivation is to build modular parsers, which can be extended together with ASTs. Futhermore, we focus on semantic modularity, that means we expect parsers to be modularly type-checked and separately compiled.

In the rest of Section~\ref{sec:inheritance}, we will introduce an solution for modular parsing with Extension 1 above, using only standard inheritance in OO. Extension 2 will be discussed in Section~\ref{sec:algebrasandparsing}.

\subsection{Inheritance-Based Parser}

Let's firstly consider Extension 1, which is to extend the syntax as well as the parser. As an example, we continue with the expression language of literals and additions in Section~\ref{subsec:packratparsing}. We introduce variables as a new case as below.

\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= ...
   \alt <ident>
\end{grammar}

It is easy to extend the corresponding AST in an OO way:

\lstinputlisting[linerange=29-31]{../Scala/Parser/src/PaperCode/Sec3Inheritance/Code1.scala}% APPLY:linerange=INHERITANCE_SIMPLE_LAM

Since we already have the parser for literals and additions, we would
like to build the new parser by reusing the old one. In Scala we can take advantage of inheritance for such reuse. Specifically,
the new parser can be defined in an enclosing trait that extends
the old one. Here one may quickly come up
with the following attempt, where a new parser is defined for \inlinecode{Var}, then composed
with \inlinecode{pExpr}:

\lstinputlisting[linerange=35-38]{../Scala/Parser/src/PaperCode/Sec3Inheritance/Code1.scala}% APPLY:linerange=INHERITANCE_BAD_ATTEMPT

Unfortunately, it fails to parse some expressions like \inlinecode{"1 + x"}, which is obviously valid in the new grammar.
The reason is that \inlinecode{pAdd} makes two recursive calls to parse sub-expressions, by using \inlinecode{pExpr}, which
covers both cases in the old grammar. But the newly added case \inlinecode{pVar} is not observed by the recursive \inlinecode{pExpr},
hence the parser does not work as expected. It is possible to build the correct parser by replacing the recursive call in \inlinecode{pAdd} with \inlinecode{pVarExpr}.
However, modification on existing code sacrifices separate compilation, as mentioned by the Expression Problem.

\subsection{Overriding for Extensibility}\label{subsec:overriding}

It is actually quite simple to let \inlinecode{pExpr} cover the newly extended case without modifying existing code. Method overriding is a standard feature which often comes with inheritance, and it allows us to explain inherited method again, such as \inlinecode{pExpr}. We can build the new parser which correctly parses \inlinecode{"1 + x"} as below.

\lstinputlisting[linerange=42-47]{../Scala/Parser/src/PaperCode/Sec3Inheritance/Code1.scala}% APPLY:linerange=INHERITANCE_APPROACH

Now \inlinecode{VarExprParser} successfully represents the parser for the extended language, because Scala uses dynamic dispatch for
method overriding in inheritance. When the input \inlinecode{"1 + x"} is fed to the parser \inlinecode{this.pExpr}, it firstly delegates
the work to \inlinecode{super.pExpr}, which parses literals and additions. However, the recursive call \inlinecode{pExpr} in \inlinecode{pAdd}
actually refers to \inlinecode{this.pExpr} again due to dynamic dispatch, and it covers the variable case. Similarly, all recursive calls can be updated to include new extensions if needed.

Notice that Scala has a linearized-style multiple inheritance for traits. It can be very helpful when composing several languages. Suppose now
we want to compose the parsers for expressions from pre-defined languages \inlinecode{LanguageA} and \inlinecode{LanguageB} using alternative.
The use of keyword \inlinecode{super} is able to
specify the implementation from inheritance, like:

\lstinputlisting[linerange=70-76]{../Scala/Parser/src/PaperCode/Sec3Inheritance/Code1.scala}% APPLY:linerange=MULTIPLE_INHERITANCE

As we demonstrated, inheritance is the key technique to obtain semantic modularity.
It enables type-safe code reuse and separate compilation for parsing OO style ASTs with Extension 1.
