\section{Open Recursion and Parsing}\label{sec:openandparsing}

Our story begins with a well-known concept mostly in object-oriented programming, called \textit{open recursion}. This mechanism
constructs the basis of extensibility of our parsing. We will introduce the concept with illustration before integrating
it  to achieve halfway extensible parsers.

\subsection{Open Recursion with Delegation}\label{subsec:openrecursion}

Open recursion is known as a useful feature that one method body can ``invoke another method of the same object via a special variable called \lstinline{self} or, in some languages, \lstinline[keywords={}]{this}'' (by Ralf Hinze). The interesting thing is that such a variable \lstinline{self} is late-bound, or open to the recursion, which means it can integrate some additional features defined later, while existing methods that take \lstinline{self} as a parameter can simply delegate their known cases to it.

For sure we cannot always leave it open; upon using it we have to close the recursion, at which time we need to take a fix-point. Here one might suddenly be reminded of the \lstinline{fix} function in some functional languages like Haskell. In Haskell \lstinline{fix} is defined as:

\begin{lstlisting}[language=Haskell,keywords={}]
fix f = let x = f x in x
\end{lstlisting}
In Scala, however, there is no library \lstinline{fix} function, but it can be easily implemented since Scala also supports lazy evaluation. See below:

\lstinputlisting[linerange=27-30]{../Scala/Parser/src/PaperCode/SampleParser.scala}% APPLY:linerange=OPENRECURSION_FIX

where function \lstinline{f} has a by-name parameter of type \lstinline{"=>} \lstinline{A"}.
Here we illustrate by the famous Fibonacci example. Traditionally it can be implemented in Scala using pattern-matching:
\begin{lstlisting}
def fib : Int => Int = i => i match {
    case 0 => 0
    case 1 => 1
    case n => fib(n - 1) + fib(n - 2)
}

val x = fib(2) // 1
\end{lstlisting}
An alternative implementation using open recursion is as follows:
\begin{lstlisting}
type Fix[T] = (=> T) => T
def fib2 : Fix[Int => Int] = self => i => i match {
    case 0 => 0
    case 1 => 1
    case n => self.apply(n - 1) + self.apply(n - 2)
}

val x2 = fix(fib2)(2) // 1
\end{lstlisting}
where \lstinline{self} is the explicit self-reference, namely the delegator. Functions like \lstinline{fib2} which takes
an explicit self-reference as its parameter are called \textit{generators} (by Ralf Hinze).
If we close the recursion on \lstinline{fib2} only, the evaluation of \lstinline{fix(fib2)(2)}, namely the above \lstinline{x2} is processed as follows:
\begin{lstlisting}[language=Haskell,keywords={}]
   fix(fib2)(2)
= lazy val a = fib2(a); a.apply(2)
= lazy val a = fib2(a); fib2(a)(2)
= ... (the third case in fib2)
= lazy val a = fib2(a); a.apply(1) + a.apply(0)
= lazy val a = fib2(a); fib2(a)(1) + fib2(a)(0)
= ... (the first two cases in fib2)
= lazy val a = fib2(a); 1 + 0
= 1
\end{lstlisting}
which behaves similarly as \lstinline{fib(2)}. The process of evaluation will terminate if there are some base cases (like the first two in
\lstinline{fib2}) which stop the recursion in their branches, and the evaluation is finally reduced to those cases.

Suppose now we want to make use of open recursion for additional operations. We first define a combinator which combines the results of two generators in a pair:
\begin{lstlisting}
implicit class Compose[A, B, C](f : Fix[A => B]) {
    def *(g : Fix[A => C]) : Fix[A => (B, C)] = self => x =>
        (f(self.apply(_)._1)(x), g(self.apply(_)._2)(x))
}
\end{lstlisting}
Using Scala implicit class, \lstinline{*} can be used as an infix operator for composition in convenience.
Then we define a generator which prints out a number as a string:
\begin{lstlisting}
def show : Fix[Int => String] = self => x => x.toString
\end{lstlisting}
Now \lstinline{fix(fib2 * show)(2)} results in \lstinline{(1, "2")}. We have seen that both \lstinline{fib2} and \lstinline{show} are integrated in the evaluation.

Next we define a more general combinator \lstinline{merge} for open recursion. It is similar to the \lstinline{*} above, but instead of putting two values in a pair by default, \lstinline{merge} takes a parameter called \lstinline{op}, which tells the associative operation of two results. The definition is straightforward:
\begin{lstlisting}
def merge[E, F, G, H[_,_]](op : F => G => H[F, G], x : (=> E) => F, y : (=> E) => G) : (=> E) => H[F, G] = e => op(x(e))(y(e))
\end{lstlisting}

%\begin{itemize}
%\item Fixpoints library + explaining delegation with some examples
%\item Alternative combinator + others
%\item Trait Composition to do Language Composition
%\end{itemize}

%In this section, we will further look into the mechanism behind our modular parsing library.
%We will first introduce some concepts independently from the process of parsing, including open recursion and Object Algebras,
%then present how they are integrated in our library.
%Starting from simple examples, a series of extensions and refactoring will be applied to illustrate
%how we achieve modularity in a type-safe way.

\subsection{Parsing with Open Recursion}\label{subsec:parsingwithopen}
Open recursion potentially opens the gate of extensibility for parsing, as a parser can now be open to additional features in the future.
Our exploration starts from a simple example, where a single parser only parses a free variable (i.e., a string). Traditionally, to write
such a parser, we need to import the library as
well as defining the datatype for which it produces.

\begin{lstlisting}
type Parser[E] = PackratParser[E]

abstract class Expr
case class Var(x : String) extends Expr
val pVar : Parser[Expr] = ident ^^ Var
\end{lstlisting}
Note that we are omitting lexing and demo code here. And we use \lstinline{Parser} as a type synonym for \lstinline{PackratParser} throughout the paper. Furthermore, we would like the parser to support applications.
Not only the implementation of that parser is needed, but also its corresponding datatype:
\begin{lstlisting}
case class App(e1 : Expr, e2 : Expr) extends Expr
val pApp : Parser[Expr] = pVar ~ pVar ^^ { case e1 ~ e2 => App(e1, e2) }
\end{lstlisting}
Such a parser \lstinline{pApp} can only parse one-layer applications like \lstinline{"x y"}. Hence we revise it using recursion:
\begin{lstlisting}
val pApp : Parser[Expr] = {
    val p = pVar ||| pApp
    p ~ p ^^ { case e1 ~ e2 => App(e1, e2) }
}
\end{lstlisting}
Note that we are composing \lstinline{pVar} and \lstinline{pApp} using alternative. Alternation is a general operation to compose different parsers, since they represent different grammar rules with the logical relation ``or'' between one another. In this example, both sub-expressions of an application can be either a single variable or again an application. Now \lstinline{pApp} manages to parse an arbitrary number of applications like \lstinline{"x y z ..."} in a right-associative way.
Nevertheless, even though we are not considering operations but the creation of objects only, such an approach does not turn out to be a modular extension, because if numeric literals are further accepted in our small language, the grammar becomes:
\begin{lstlisting}
e ::= x | e ' ' e | n
\end{lstlisting}
Besides writing a new parser for literals, we need to rewrite the existing \lstinline{pApp}, since applications can now contain numbers, like \lstinline{"x 3"} and so on.
\begin{lstlisting}
case class Lit(n : Int) extends Expr
val pLit : Parser[Expr] = numericLit ^^ Lit
val pApp : Parser[Expr] = {
    val p = pVar ||| pApp ||| pLit
    p ~ p ^^ { case e1 ~ e2 => App(e1, e2) }
}
\end{lstlisting}
We have observed that \lstinline{pApp} is indeed constructed in a non-modular way, because the \lstinline{p} standing for recursive parser needs to be updated on every extension. Actually in the grammar, the recursive \lstinline{"e"} in the second case should not only include all the existing cases like \lstinline{pApp} and \lstinline{pVar}, but also take future extensions into account (we can have arbitrarily more cases). This is where we are inspired to use open recursion. To define \lstinline{pApp} as an ``open'' function, we add a parameter \lstinline{p} to it, representing the explicit self-reference of our whole parser, open to future extensions. Note that \lstinline{p} should be defined as a by-name parameter using \lstinline{"=>"}.
\begin{lstlisting}
val pApp : Fix[Parser[Expr]] = p => p ~ p ^^ { case e1 ~ e2 => App(e1, e2) }
\end{lstlisting}
Here the type \lstinline{Fix[Parser[Expr]]}, namely \lstinline{(=>} \lstinline{Parser[Expr])} \lstinline{=>} \lstinline{Parser[Expr]} is exactly what we want for a parser. Similarly \lstinline{pVar} is redefined also as a function using the explicit fix-point \lstinline{p}. To be more convenient for composition, we define an auxiliary combinator \lstinline{"|||"} for parsers of type \lstinline{(=>} \lstinline{R)} \lstinline{=>} \lstinline{Parser[E]} with the same \lstinline{R} and \lstinline{E}. It is more general using \lstinline{R} instead of \lstinline{Parser[E]}, because there might be multiple fix-points in the parameter. Such a function is overloaded and can be invoked as an infix operator when defined in an implicit class. It is implemented using the general \lstinline{merge} function in Section~\ref{subsec:openrecursion}.
\begin{lstlisting}
val pVar : Fix[Parser[Expr]] = p => ident ^^ Var

implicit class Combinator[E, R](x : (=> R) => Parser[E]) {
    type H[A, B] = Parser[E]
    def |||(y : (=> R) => Parser[E]) : (=> R) => Parser[E] = {
        val alt : Parser[E] => Parser[E] => Parser[E] = a => b => a ||| b
        merge[R, Parser[E], Parser[E], H](alt, x, y)
    }
}
\end{lstlisting}
Now since \lstinline{pVar} and \lstinline{pApp} are defined independently, we are able to compose them using \lstinline{|||}:
\begin{lstlisting}
val pVarApp : Fix[Parser[Expr]] = pVar ||| pApp
\end{lstlisting}
Here \lstinline{pVarApp} is the combination of two parsers. But what we really want is something that has type \lstinline{Parser[Expr]}. One can be soon reminded that in Section~\ref{subsec:openrecursion}, we use \lstinline{fix} to get the fix-point of a function, in this case we write \lstinline{fix(pVarApp)}, which manages to parse an arbitrary number of applications.

This is the magic of open recursion: we can define as many small components as we like, and they are implemented as functions, with the help of explicit self-reference. Whenever we would like to close the recursion, simply use \lstinline{fix} for their combination. Such a process is guaranteed to terminate when we restrict the input for parsing to be finite, and we have some base cases like \lstinline{pVar}, which terminates recursion in their branches, in addition, with the help of Packrat parsers with direct left-recursion support.

Another thing which catches our attention is that, small parsers are combined using the alternative combinator. Hence, parsing failing at any position will try its next alternative, and for each recursion all the parsers are tried successively until one of them succeeds. It reveals its essence as a recursive descent parser. But it is quite easy and modular to use; with further extensions, they can be implemented separately and then appended to the combination of old ones.

Furthermore, in above code we use \lstinline{|||} for alternative instead of \lstinline{|}. As we have mentioned in Section~\ref{sec:packratparsers}, \lstinline{|||} is more powerful with longest matching. Consider if we obtain \lstinline{pVarApp} from \lstinline{pVar | pApp}, the final parser \lstinline{fix(pVarApp)} cannot even parse an application \lstinline{"x y"}, since it succeeds in parsing a variable first and only returns \lstinline{"x"}. With \lstinline{|||}, however, we can put composition in any order and it still works as expected.

But our story does not tend to stop here, as we have observed some limitations of the current approach. Specifically, one is that extensibility of data operations is not guaranteed, though we obtain the extensibility of data variants by defining an arbitrarily large number of new case classes. Suppose we want new operations like pretty-printing on expressions, we may 1) add a method \lstinline{print} to all case classes with their own interpretations; 2) define a single method \lstinline{print} and do pattern-matching on case classes inside. When adding new data variants and operations, both require existing code to be modified, thus affect code reuse and modularity.

Another weakness is that the only little extensibility is just fragile when it comes to grammars with multiple different syntax. For instance, in the beginning we only have variables and applications in \lstinline{Expr}, to have types in our language, the \lstinline{Int} type and lambda expressions with annotation are added. See the grammar below:
\begin{lstlisting}
e ::= x | e ' ' e | \x:t.e
t ::= "Int"
\end{lstlisting}

We proceed to implement those parsers. An issue is that we need both a \lstinline{Parser[Expr]} and a \lstinline{Parser[Type]} in the fixpoint.
Hence we use a pair in the parameter:
\begin{lstlisting}
type Pair = (Parser[Expr], Parser[Type])

abstract class Type
case class IntT() extends Type
val pInt : (=> Pair) => Parser[Type] =
    p => "Int" ^^^ IntT()

case class Lam(x : String, t : Type, e : Expr) extends Expr
val pLam : (=> Pair) => Parser[Expr] =
    p => ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1) ^^
        { case x ~ t ~ e => Lam(x, t, e) }

val pVar2 : (=> Pair) => Parser[Expr] = p => pVar(p._1)
val pApp2 : (=> Pair) => Parser[Expr] = p => pApp(p._1)

val pET : Fix[Pair] = {
    val pE = pVar2 ||| pApp2 ||| pLam
    val pT = pInt
    p => (pE(p), pT(p))
}
\end{lstlisting}
Based on the old \lstinline{pVar} and \lstinline{pApp}, we implement \lstinline{pVar2} and \lstinline{pApp2} which take the pair as their fix-points instead.
In that case the parsers are consistent, and hence can be composed using the combinator \lstinline{|||}.
The last value \lstinline{pET} integrates the four single parsers defined before, where parsers for expressions and parsers for types are composed respectively. Furthermore, we use \lstinline{fix(p)} to obtain the pair of two parsers we want: one for expressions, the other for types. The parser \lstinline{fix(p)._1} parsers expressions like \lstinline{"\x:Int.x x"} successfully. Yet meanwhile, some drawbacks of this approach come into sight. With different syntax, it
is necessary to extend the fix-point to contain more parsers, in which case usually some structures like tuples are used,
making code tedious and less elegant. Moreover, we need to update such a fix-point in the arguments of all previously defined parsers, so as to make parsers consistent for the combinator (things get even worse without that combinator). It introduces more boilerplate code, which highly affects code reuse.

