\section{Background: Scala Packrat Parsing Library}\label{sec:packratparsers}

\bruno{We need to think whether this section should be incoorporated
  in S2}

This section introduces the Scala Packrat Parsing library~\cite{}, which is
used by \name.

\paragraph{An Example}
A Packrat parser has type \lstinline{PackratParser[E]} for some
\lstinline{E}, which indicates the representation\bruno{the
  representation of what?}. The code below illustrates
Scala's Packrat parsing library. 

\begin{lstlisting}
lexical.reserved += ("str")
lexical.delimiters += ("(", ")")

val p : PackratParser[String] =
    "str" ~> ("(" ~> numericLit <~ ")") ^^ { x => x.toString }
\end{lstlisting}

\noindent
 
Note that the code should be defined in an enclosing type that extends
\lstinline{scala.util.parsing.combinator.syntactical.StandardTokenParsers}
for lexing and
\lstinline{scala.util.parsing.combinator.PackratParsers} for Packrat
parsers.
The first two lines are used for lexing. The third line defines a
parser which can, for instance, parse \lstinline{"str(5)"} and produce
the string \lstinline{"5"}. In \lstinline{StandardTokenParsers} there
are a number of basic parsers, such as \lstinline{numericLit} that
parses integers, and \lstinline{stringLit} that parsers string
literals. Moreover, in Scala the syntax for parsing
is quite concise and clear, as shown above, with the help of
parser combinators. The combinators \lstinline{~>} and \lstinline{<~} only collect
results from the parts that arrows point to, and the combinator \lstinline{^^} is
followed by a function which is applied to a parser to return new
values. Finally, a generic \lstinline{runParser}
function is used for testing:

\begin{lstlisting}
def runParser(p: Parser[_]): String => Unit = in => {
    val t = phrase(p)(new lexical.Scanner(in))
    if (t.successful) println(t.get) else scala.sys.error(t.toString)
}
\end{lstlisting}
Now \lstinline{runParser(p)("str(5)")} prints out \lstinline{"5"} as expected.

\begin{table}[t]
\centering
\begin{tabular}{l}
\hline
\begin{lstlisting}
def ~[U](q: => Parser[U]): Parser[~[T, U]]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition. \\
\hline
\begin{lstlisting}
def ^^[U](f: (T) => U): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for function application. \\
\hline
\begin{lstlisting}
def ^^^[U](v: => U): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator that changes a successful result into the specified value. \\
\hline
\begin{lstlisting}
def <~[U](q: => Parser[U]): Parser[T]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the left result. \\
\hline
\begin{lstlisting}
def ~>[U](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the right result. \\
\hline
\begin{lstlisting}
def repsep[T](p: => Parser[T], q: => Parser[Any]): Parser[List[T]]
\end{lstlisting} \\
\hspace{.2in}- A parser generator for interleaved repetitions. \\
\hline
\begin{lstlisting}
def ident: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches an identifier. \\
\hline
\begin{lstlisting}
def numericLit: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches a numeric literal. \\
\hline
\begin{lstlisting}
def |[U >: T](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative composition. \\
\hline
\begin{lstlisting}
def |||[U >: T](q0: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative with longest match composition. \\
\hline \\
\end{tabular}
\caption{Some frequently used functions in Scala parser API.}\label{tab1}
\end{table}\bruno{We should double-check that this table lists the
  combinators used in the paper.}

\paragraph{Packrat Parsing API} Table~\ref{tab1} shows some common parser combinators
that are used in our implementation.  There are several standard
parser combinators. For example \lstinline{|} is the combinator for
alternative parsers. Other combinators have descriptions of their
semantics on the table.

There are two features of the Packrat Parsing library that play a key role
for modularity, which are discussed next.

\paragraph{Longest Match Composition} The Packrat parsing library 
contains an alternation combinator, which does \emph{longest match
  composition}. This combinator has a different semantics from
\lstinline{|}.
Suppose that we are composing a list of parsers using alternative
\lstinline{|}, in an order. A parser in the front might be successful
in parsing a substring of the input, but then it unexpectedly stops
the parsing and discards the rest, while another parser might be able
to parse the whole input. In that case, using \lstinline{|||} we no
longer need to worry about the order of composition, which potentially
encourages its extensibility. A concrete example will be illustrated
for this later. \bruno{Please show example here. }

\paragraph{Left Recursion} The Scala Packrat Parsing library 
supports direct left-recursion. Left recursion has been considered
as a big problem especially in recursive descent parsers~\cite{}, and many
existing parsing libraries have limited or no support for it. From theoretical point of
view, the algorithm behind Packrat parsers supports both direct and
indirect left-recursion. In practice, the current version of the library is still
buggy in some cases with indirect left-recursion, but we believe that
they will fix it in the future, and direct left-recursion is
already practical to use for a large number of applications.
