\section{Scala Parsing Library: Packrat Parsers}\label{sec:packratparsers}

We have selected Packrat Parsing library for our prototype implementation. It is a library built on Scala's basic parsing features,
which opens access to high performance in parsing, convenient parser combinators with concise syntax, as well as lexers for users. Generally,
a Packrat parser has type \lstinline{PackratParser[E]} for some \lstinline{E}, which indicates the representation. Below we present a small piece of
code that uses Packrat parsing for our illustration. Note that it should be defined in an enclosing type that extends \lstinline{scala.util.parsing.combinator.syntactical.StandardTokenParsers} for lexing and \lstinline{scala.util.parsing.combinator.PackratParsers} for Packrat parsers.

\begin{lstlisting}
lexical.reserved += ("str")
lexical.delimiters += ("(", ")")

val p : PackratParser[String] =
    "str" ~> ("(" ~> numericLit <~ ")") ^^ { x => x.toString }
\end{lstlisting}

The first two lines stand for lexing. In the third line we define a parser which can, for instance, parse \lstinline{"str(5)"} and produce the string \lstinline{"5"}. In \lstinline{StandardTokenParsers} there are a number of basic parsers, such as \lstinline{numericLit} that parsers integers, and \lstinline{stringLit} that parsers string literals for convenient use. Moreover, in Scala the syntax for parsing is quite concise and clear, as we have shown above, with the help of parser combinators. \lstinline{~>} and \lstinline{<~} only collect results from the parts that arrows point to, and \lstinline{^^} is followed by a function which is applied to a parser to return new values. Finally, we can define a generic \lstinline{runParser} function for testing:

\begin{lstlisting}
def runParser(p: Parser[_]): String => Unit = in => {
    val t = phrase(p)(new lexical.Scanner(in))
    if (t.successful) println(t.get) else scala.sys.error(t.toString)
}
\end{lstlisting}
Now \lstinline{runParser(p)("str(5)")} prints out \lstinline{"5"} as expected.

\begin{table}[t]
\centering
\begin{tabular}{l}
\hline
\begin{lstlisting}
def ~[U](q: => Parser[U]): Parser[~[T, U]]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition. \\
\hline
\begin{lstlisting}
def ^^[U](f: (T) => U): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for function application. \\
\hline
\begin{lstlisting}
def <~[U](q: => Parser[U]): Parser[T]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the left result. \\
\hline
\begin{lstlisting}
def ~>[U](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the right result. \\
\hline
\begin{lstlisting}
def repsep[T](p: => Parser[T], q: => Parser[Any]): Parser[List[T]]
\end{lstlisting} \\
\hspace{.2in}- A parser generator for interleaved repetitions. \\
\hline
\begin{lstlisting}
def ident: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches an identifier. \\
\hline
\begin{lstlisting}
def numericLit: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches a numeric literal. \\
\hline
\begin{lstlisting}
def |[U >: T](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative composition. \\
\hline
\begin{lstlisting}
def |||[U >: T](q0: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative with longest match composition. \\
\hline \\
\end{tabular}
\caption{AAA}\label{tab1}
\end{table}

Furthermore, Table~\ref{tab1} shows some common parser combinators that are used in our implementation.
In particular, \lstinline{|} is common syntax for alternative parsers in many languages, whereas \lstinline{|||} is a new combinator available in Scala, which is also for alternation but with longest match composition. Imagine that we are composing a list of parsers using alternative \lstinline{|}, in an order. A parser in the front might be successful in parsing a substring of the input, but then it unexpectedly stops the parsing and discards the rest, while another parser might be able to parse the whole input. In that case, using \lstinline{|||} we no longer need to worry about the order of composition, which potentially encourages its extensibility. A concrete example will be illustrated for this later.

On the other hand, the Scala Packrat Parsing library comes to our attention not only because of its performance, but also due to its support for direct left-recursion. Left recursion has been considered as a big problem especially in recursive descent parsers, which many existing libraries cannot perfectly support. From theoretical point of view, the algorithm behind Packrat parsers supports both direct and indirect left-recursion. The current version of the library is still buggy in some cases with indirect left-recursion, but we believe that they will fix it in the future, and with direct left-recursion it is already practical to use for a large number of applications.

