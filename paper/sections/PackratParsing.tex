\section{Packrat Parsing for Modularity}\label{sec:packrat}

This section discusses the algorithmic challenges introduced by modular parsing and argues that parser combinators from Packrat parsing
are suitable to address those challenges.

\subsection{Algorithmic Challenges of Modularity}\label{subsec:challenges}
At a first look, parser combinators are very suitable for modular parsing, because of two reasons. Firstly, they are naturally modular. The manner of using them is to write small parsers and use combinators to composed them together. The construction procedure is explicit and fully controlled by the programmer. Secondly, each parser combinator is represented by a piece of code, and also are the parsers it takes. Thus in a statically typed programming language they can be statically type-checked.
Unfortunately many parser combinators have important limitations.
In particular several parser combinators,
including the famous Parsec~\cite{Leijen2001} library, require
programmers to manually do \textit{left-recursion elimination}, \textit{longest match composition}, and
require significant amounts of \textit{backtracking}. All of them are
problematic in a modular setting.

\paragraph{Left-Recursion Elimination} The top-down, recursive descent parsing strategy adopted by those parser combinator libraries cannot support left-recursive grammars directly. The common solution is to rewrite the grammar into an equivalent but not left-recursive one, so called left-recursion elimination.

The grammar below represents a simple arithmetic language containing only integers. Its corresponding parser is shown on the right side, written in Parsec.

\begin{tabular}{m{0.4\linewidth}m{0.5\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= <int>
\end{grammar}
&
\begin{lstlisting}[language=PlainCode]
parseExpr = parseInt
\end{lstlisting}
\end{tabular}

Consider we extended the language by adding subtractions to the grammar. If we still write its parser by directly following the grammar structure, the new left-recursive case will get the parser into an infinite loop. Namely, \inlinecode{parseExpr} and \inlinecode{parseSub} call each other and never stop.

\begin{tabular}{m{0.4\linewidth}m{0.5\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= <int> \alt <expr> `-' <int>
\end{grammar}
&
\begin{lstlisting}[language=PlainCode]
parseExpr = parseSub <|> parseInt
parseSub = do
  e <- parseExpr
  ...
\end{lstlisting}
\end{tabular}

To solve this issue, we have to rewrite the grammar as below to eliminate left-recursion and build the parser based on this new grammar.\\

\begin{tabular}{m{0.4\linewidth}m{0.5\linewidth}}
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= <int> <expr'>

<expr'> ::= <empty> \alt `-' <int> <expr'>
\end{grammar}
&
\end{tabular}

After left-recursion elimination, the structure of grammar is changed, as well as its corresponding parser. In a modular setting, it is possible but unnecessorily compilcated to analyse the grammar and rewrite it when doing extension. Anticipating that every non-terminal has left-recursive rules, even though some do not, is helpful for extension. However, it is inconvenient and introduces extra complexity for representation of grammar and implementation of parser.

Another issue of left-recursion elimination is that it requires extra
bookkeeping work to retain the original semantics. For example, the
expression $1-2-3$ is parsed as $(1-2)-3$ in the left-recursive
grammar, but after rewrite the result is $1((-2)-3))$. The parse tree
must be transformed to recover its structure.

\paragraph{Longest Match Composition} Another problematic issue
in parser combinator libraries is the need for manually ordering
alternatives in a grammar.
Consider the grammar:
\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= <int> \alt <int> `+' <expr>
\end{grammar}

In Parsec, for instance, the parser below will only parse the input \inlinecode{"1 + 2"} to \inlinecode{"1"}, as \inlinecode{parseInt} successfully parses \inlinecode{"1"}
and terminates parsing.

\begin{lstlisting}[language=PlainCode]
parser = parseInt <|> parseAdd
\end{lstlisting}

Using traditional alternative composition, when a preceding parser successfully parses a prefix of the input, it will finish parsing and return the result, in spite that subsequent parsers may be able to parse the whole input.
%\huang{I've rewritten this paragraph}\bruno{The example is good, I think but the explanation is not.
%You want to say that when you know
%  the full grammar, you can figure out where ``try'' is
%  needed. Without the full grammar you'd need assume the worst
%  case. Make an effort to make your explanation cristal clear!
%I think you want to miss the abstract explanation that you give first,
%with the explanation about the concrete example.
%Start with ``The need for backtracking is also problematic
%in a modular setting. For example, suppose ...'' and synchronize
%the abstract explanation and the explanation for the example.
%}
In contrast with the parser above, \inlinecode{parser = parseAdd <|> parseInt} works as expected with the two cases swapped.

In this case, reordering the alternatives ensures that
the \emph{longest match} is picked among the possible results. However, manual reording for the longest match is inconvenient, and worst still, it is essentially non-modular. When the grammar is extended with new rules, programmers are supposed to \emph{manually} adjust
the order of parsers, which requires rewritting previously written code.

\paragraph{Backtracking} The need for backtracking is also problematic
in a modular setting. For example, consider a grammar that includes
``import'' statements including \inlinecode{import..from}.
Now we want to extend the grammar with an \inlinecode{import..as} case, as shown in the third line of grammar below.

\setlength{\grammarindent}{5em}
\begin{grammar}
<stmt> ::= `import' <ident> `from' <ident>
    \alt ...
    \alt `import' <ident> `as' <ident>
\end{grammar}

Since the \inlinecode{import..from} case shares a prefix with the new case \inlinecode{import..as}, when the former case fails, we must backtrack to the beginning. Take Parsec as an example, its choice
combinator \inlinecode{<|>} only tries the second alternative if the first fails
without any token consumption. An auxiliary function \inlinecode{try} is used for explicit backtracking.

\begin{lstlisting}[language=PlainCode]
oldParser = parseImpFrom <|> parseA <|> parseB <|> ...
newParser = try parseImpFrom <|> parseA <|> parseB <|> ... <|> parseImpAs
\end{lstlisting}

Given the full grammar, we can decide where to put \inlinecode{try} for backtracking. However, with modular parsing we are unable to have a global view of the full grammar. Hence the worst case should be considered that all alternatives may share common prefixes with future cases. In that case we need to backtrack for all the branches. To avoid failures in the future, we have to add \inlinecode{try} everywhere:

\begin{lstlisting}[language=PlainCode]
parser = try parseImpFrom <|> try parseA <|> try parseB <|> ... <|> try parseImpAs
\end{lstlisting}

\noindent However, this results in the worst case exponential time complexity in Parsec, because it does not have related optimization.

\subsection{Packrat Parsing}\label{subsec:packratparsing}
Fortunately some more advanced parsing techniques such as Packrat parsing~\cite{Ford2002} have been developed to address limitations of simple parser combinators. Packrat parsers use memoization to record the result of applying each parser at each position of the input, so that repeated computation is eliminated. Moreover, Packrat parsing supports both direct and indirect left-recursion~\cite{warth2008} theoretically. All of these properties are very suitable for modularity, thus we decided to use Packrat parsers as the underlying parsing technique in our modular parsing library.
\begin{comment}
It is worth mentioning that the choice of parser combinators will not
affect the other parts of our library. One can choose other parser
combinators like Parsec, in cases that the performance and supporting
of left-recursion are not major concerns. A different library can even build a new
\name with fancy features or higher efficiency.
\end{comment}
Scala has a standard parser combinator library\footnote{https://github.com/scala/scala-parser-combinators}
\cite{moors2008parser} which implements Packrat parsers.
The library provides a number of parser combinators, including the longeset match alternative combinator.
Below we present an example to illustrate Scala parsers.
%
%\bruno{So, we make a big fuss identifying the problems with other
%parser combinators in the previous subsection and now we present
%an example that does not suffer from any of the previous problems!
%What makes sense here is an example that uses: a \emph{left-recursive grammar}; the \emph{longest match combinator}; and where we can argue that
%there's no need for the user to do manual backtracking. Just use
%the example with the left-recursive grammar for parsing integers and additions and argue that none of the limitations
%discussed previously applies!
%}

\paragraph{Parsing a Simple Arithmetic Language}
Suppose we want to parse a simple language with literals and
additions. The concrete syntax is as follows:
%\bruno{Here's a good opportunity to both improve the paper and make it
%more compact! This is the example that should be illustrated and
%discussed at the end of Section 2. Then we can just create a figure to
%refer to the code in Section 2 and refer again to the figure here. No
%need for two different examples.}

\setlength{\grammarindent}{5em}
\begin{grammar}
<expr> ::= <int>
    \alt <expr> `+' <expr>
\end{grammar}
%\alt `(' <expr> `)'

It is straightforward to model ASTs by inheritance and write corresponding parsers for all cases.
Note that a parser has type \lstinline{PackratParser[E]} for some
\lstinline{E}, which indicates the type of results it produces. Figure~\ref{fig:packrat-arith} shows the abstract syntax and
the parser code that generates expressions as ASTs. Meanwhile, pretty-printing shows up as an operation on the AST.

\begin{figure}[t]
\centering
\lstinputlisting[linerange=6-29]{../Scala/Parser/src/PaperCode/Sec2Packrat/Code1.scala}% APPLY:linerange=PACKRAT_SIMPLE_EXPR
\caption{Packrat Parsing for an arithmetic language.}\label{fig:packrat-arith}
\end{figure}


In the trait \lstinline{ExprParser}, \lstinline{lexical} is used for lexing. \lstinline{pLit} parses an integer for the literal case.
\lstinline{pAdd} handles the addition case and creates an object of \lstinline{Add}. It parses two sub-expressions by calling \lstinline{pExpr}
recursively. Finally \lstinline{pExpr} composes \lstinline{pLit} and \lstinline{pAdd} using the longest match alternative combinator \inlinecode{|||}.
Table~\ref{tab:packrat} gives a closer look at part of the API that we have used in our work.

\begin{table}[t]
\begin{tabular}{l}
\hline
\begin{lstlisting}
def ~[U](q: => Parser[U]): Parser[~[T, U]]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition. \\
\hline
\begin{lstlisting}
def ^^[U](f: (T) => U): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for function application. \\
\hline
\begin{lstlisting}
def ^^^[U](v: => U): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator that changes a successful result into the specified value. \\
\hline
\begin{lstlisting}
def <~[U](q: => Parser[U]): Parser[T]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the left result. \\
\hline
\begin{lstlisting}
def ~>[U](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for sequential composition which keeps only the right result. \\
\hline
\begin{lstlisting}
def repsep[T](p: => Parser[T], q: => Parser[Any]): Parser[List[T]]
\end{lstlisting} \\
\hspace{.2in}- A parser generator for interleaved repetitions. \\
\hline
\begin{lstlisting}
def ident: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches an identifier. \\
\hline
\begin{lstlisting}
def numericLit: Parser[String]
\end{lstlisting} \\
\hspace{.2in}- A parser which matches a numeric literal. \\
\hline
\begin{lstlisting}
def |[U >: T](q: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative composition. \\
\hline
\begin{lstlisting}
def |||[U >: T](q0: => Parser[U]): Parser[U]
\end{lstlisting} \\
\hspace{.2in}- A parser combinator for alternative with longest match composition. \\
\hline \\
\end{tabular}
\caption{Part of Scala Parser API.\bruno{We should double-check that this table lists the
  combinators used in the paper.}}\label{tab:packrat}
\end{table}

It is worth mentioning that such a grammar is left-recursive in the addition case. Since left-recursion is well supported by Packrat parsers, we do not need extra code for it. Our parser also employs longest match composition by using the combinator \lstinline{|||} in the library. Furthermore, it does not suffer from the backtracking problem, as the memoization technique of Packrat parsing guarantees the efficiency.

For more concise demonstration, in the rest of paper we assume that all the code are in an enclosing environment of traits \inlinecode{StandardTokenParsers} and \inlinecode{PackratParsers}. Futhermore, we will use \lstinline{Parser} as a type synonym for \lstinline{PackratParser} and a generic \inlinecode{parse} function for testing as below. The last line demonstrates how we parse a valid expression \inlinecode{1 + 2} using our parser.

\lstinputlisting[linerange=34-41]{../Scala/Parser/src/PaperCode/Sec2Packrat/Code2.scala}% APPLY:linerange=PACKRAT_RUNPARSER
