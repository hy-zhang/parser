\subsection{First Try on Parsing}\label{subsec:firsttry}

Our story begins with a single parser that only parses a free variable (i.e., a string).
In Scala we have Packrat parsers supporting lexing and direct left-recursion in its grammar.
To write such a parser, we need to import the library as
well as defining the datatype for which it produces.

\begin{lstlisting}
object OpenRecursion extends StandardTokenParsers with PackratParsers {
    type Parser[E] = PackratParser[E]

    class Expr
    class Var(x : String) extends Expr
    val pVar : Parser[Expr] = ident ^^ { x => new Var(x) }
    ...
}
\end{lstlisting}
Note that we are omitting lexing and demo code here. And we use \lstinline{Parser} as a type synonym for \lstinline{PackratParser} throughout the paper. Furthermore, we would like the parser to support applications.
Not only the implementation of that parser is needed, but also its corresponding datatype: (we omit the fact that the code for below few
examples is written in the same object, namely \lstinline{OpenRecursion})
\begin{lstlisting}
class App(e1 : Expr, e2 : Expr) extends Expr
val pApp : Parser[Expr] = pVar ~ pVar ^^ { case e1 ~ e2 => new App(e1, e2) }
\end{lstlisting}
Such a parser \lstinline{pApp} can only parse one-layer applications like \lstinline{"x y"}. Hence we revise it using recursion:
\begin{lstlisting}
val pApp : Parser[Expr] = {
    val p = pVar ||| pApp
    p ~ p ^^ { case e1 ~ e2 => new App(e1, e2) }
}
\end{lstlisting}
Note that we are composing \lstinline{pVar} and \lstinline{pApp} using alternative. Alternation is a general operation to compose different parsers, since they represent different grammar rules with the logical relation ``or'' between one another. In this example, both sub-expressions of an application can be either a single variable or again an application. Now \lstinline{pApp} manages to parse an arbitrary number of applications like \lstinline{"x y z ..."} in a right-associative way.
Nevertheless, such an approach does not turn out to be a modular extension, because the grammar we want for an expression is actually:
\begin{lstlisting}
e ::= x | e ' ' e | ...
\end{lstlisting}
Note that such a recursive \lstinline{"e"} in the second case should not only include all the existing cases like \lstinline{pApp} and \lstinline{pVar}, but also take future extensions into account (the ellipsis we used above, for instance, \lstinline{e '+'} \lstinline{e}). This is how we are inspired to use \textbf{open recursion}. To define \lstinline{pApp} as an ``open'' function, we add a parameter \lstinline{p} to it, representing the explicit self-reference of our whole parser, open to future extensions. Note that \lstinline{p} should be defined as a by-name parameter using \lstinline{"=>"}.
\begin{lstlisting}
val pApp : (=> Parser[Expr]) => Parser[Expr] =
    p => p ~ p ^^ { case e1 ~ e2 => new App(e1, e2) }
\end{lstlisting}
Here the type \lstinline{"(=>} \lstinline{Parser[Expr])} \lstinline{=>} \lstinline{Parser[Expr]"} is exactly what we want for a parser. Similarly \lstinline{pVar} is redefined also as a function using the explicit fix-point \lstinline{p}. Furthermore, we define an auxiliary combinator \lstinline{"|||"} for parsers of type \lstinline{"(=>} \lstinline{R)} \lstinline{=>} \lstinline{Parser[E]"} with the same \lstinline{R} and \lstinline{E}. Such a function is overloaded and can be invoked as an infix operator when defined in an implicit class. It is really implemented using the general \lstinline{merge} function in Section~\ref{subsec:openrecursion}.
 \begin{lstlisting}
val pVar : (=> Parser[Expr]) => Parser[Expr] = p => ident ^^ { x => new Var(x) }

implicit class ParserCombinator[E, R](x : (=> R) => Parser[E]) {
    type H[A, B] = Parser[E]
    def |||(y : (=> R) => Parser[E]) : (=> R) => Parser[E] = {
        val alt : Parser[E] => Parser[E] => Parser[E] = a => b => a ||| b
        merge[R, Parser[E], Parser[E], H](alt, x, y)
    }
}
\end{lstlisting}
Now since \lstinline{pVar} and \lstinline{pApp} are defined independently, we are able to compose them using \lstinline{|||}:
\begin{lstlisting}
val pVarApp : (=> Parser[Expr]) => Parser[Expr] = pVar ||| pApp
\end{lstlisting}
Here \lstinline{pVarApp} is the combination of parsers. But what we really want is something that has type \lstinline{Parser[Expr]}. One can be soon reminded that in Section~\ref{subsec:openrecursion}, we use \lstinline{fix} to get the fix-point of a function, in this case we write \lstinline{fix(pVarApp)}, which manages to parse an arbitrary number of applications.

This is the magic of open recursion: we can define as many small components as we like, and they are implemented as functions, with the help of explicit self-reference. Whenever we would like to close the recursion, simply use \lstinline{fix} for their combination. Such a process is guaranteed to terminate when we restrict the input for parsing to be finite, and we have some base cases like \lstinline{pVar}, which terminates recursion in their branches, in addition, with the help of Packrat parsers with direct left-recursion support.

Another thing which catches our attention is that, small parsers are combined using the alternative combinator. Hence, parsing failing at any position will try its next alternative, and for each recursion all the parsers are tried successively until one of them succeeds. It reveals its essence as a recursive descent parser. But it is quite easy and modular to use; with further extensions, they can be implemented separately and then appended to the combination of old ones.

Furthermore, in above code we use \lstinline{|||} for alternative instead of \lstinline{|}. As we have mentioned in Section~\ref{subsec:parsinglibrary}, \lstinline{|||} is more powerful with longest matching. Consider if we obtain \lstinline{pVarApp} from \lstinline{pVar | pApp}, the final parser \lstinline{fix(pVarApp)} cannot even parse an application \lstinline{"x y"}, since it succeeds in parsing a variable first and only returns \lstinline{"x"}. With \lstinline{|||}, however, we can put composition in any order and it still works as expected.
