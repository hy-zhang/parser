\subsection{Object Algebras for Different Syntax}\label{subsec:differentsyntax}

Such extensibility becomes fragile when it comes to grammars with different syntax. Now suppose we would like to have types in the grammar. Firstly the new grammar is shown below, where the \lstinline{IntT} type and lambda expressions with annotation have been added:
\begin{lstlisting}
e ::= x | e ' ' e | \x:t.e
t ::= "Int"
\end{lstlisting}

We proceed to implement those parsers. An issue is that we need both a \lstinline{Parser[Expr]} and a \lstinline{Parser[Type]} in the fixpoint.
Hence we use a pair in the parameter:
\begin{lstlisting}
type Pair = (Parser[Expr], Parser[Type])

class Type
class IntT extends Type
val pInt : (=> Pair) => Parser[Type] =
    p => "Int" ^^ { _ => new IntT() }

class Lam(x : String, t : Type, e : Expr) extends Expr
val pLam : (=> Pair) => Parser[Expr] =
    p => ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1) ^^
        { case x ~ t ~ e => new Lam(x, t, e) }

val pVar2 : (=> Pair) => Parser[Expr] = p => pVar(p._1)
val pApp2 : (=> Pair) => Parser[Expr] = p => pApp(p._1)

val pET : (=> Pair) => Pair = {
    val pE = pVar2 ||| pApp2 ||| pLam
    val pT = pInt
    p => (pE(p), pT(p))
}
\end{lstlisting}
The last value \lstinline{p} integrates the four single parsers defined before, so we use \lstinline{fix(p)} to
obtain a pair two parsers we want: one for expressions, the other for types. The parser \lstinline{fix(p)._1} parsers expressions
like \lstinline{"\x:Int.x x"} successfully. Yet meanwhile, some drawbacks of this approach come into sight. With different syntax, it
is necessary to extend the fixpoint to contain more parsers, in which case usually some structures like tuples are used,
making code tedious and less elegant. On the other hand, the modularity is quite restricted; only parsing and datatypes are extensible.
Suppose now we want to realize some behaviors on those data structures, for example pretty-printing, then whenever we introduce a new behavior,
it needs implementations in every class body, requiring existing code to be modified. At this point, Object Algebras are adopted for data structures
instead.

Object Algebras are a nice solution to the famous \textit{Expression Problem}, achieving two dimensions of extensibility (data variants and operations)
in a type-safe way. The intuition of using Object Algebras is to separate data structures from behaviors, so as to modularize the design. We can simply add new variants for the new cases in the grammar, or realize different operations on structures, without modifying existing code, and separate compilation is supported. Coincidentally, Object Algebras use generics, where the type parameters perfectly support extensible different syntax, and hence simplify the code comparatively. Below is the code using Object Algebras, where we start from \lstinline{varE} and \lstinline{appE} only, later we will extend them with \lstinline{intT} and \lstinline{lamE}:
\begin{lstlisting}
trait OldAlg[E] {
    def varE(x : String) : E
    def appE(e1 : E, e2 : E) : E
}

trait OldParser[E] {
    val pE : OldAlg[E] => (=> PackratParser[E]) => PackratParser[E] = alg => p =>
        ident ^^ { x => alg.varE(x) } |||
        p ~ p ^^ { case e1 ~ e2 => alg.appE(e1, e2) }
}
\end{lstlisting}
Here \lstinline{OldAlg} is called an \textit{Object Algebra interface}, which has two constructs for the AST. Its parser is
supposed to produce a structure from an input, whereas with Object Algebras structures are implicit: an \textit{algebra}
is immediately applied to the structure and returns the result. It means such a structure that the parser generates should have
type \lstinline{"OldAlg[E] =>} \lstinline{E"} for some \lstinline{E}. In the above code, \lstinline{alg} which has type
\lstinline{OldAlg[E]} is an algebra, and appears as a parameter of \lstinline{pE}, then in the body of \lstinline{pE} the algebra
is invoked correspondingly right after parsing. Since it should be a generic algebra, the parser is enclosed by the generic trait \lstinline{OldParser}.

Now we move on to declare \lstinline{intT} and \lstinline{lamE} in a new trait:
\begin{lstlisting}
trait NewAlg[E, T] {
    def intT() : T
    def lamE(x : String, t : T, e : E) : E
}

trait NewParser[E, T] {
    val pE : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[E] = alg => p =>
        ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1)
            ^^ { case x ~ t ~ e => alg.lamE(x, t, e) }
    val pT : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[T] = alg => p =>
        "Int" ^^ { _ => alg.intT() }
}
\end{lstlisting}
\lstinline{NewParser} contains parsers for both expressions and types. From the code we observe that the multi-sorts of Object Algebra interface
exactly express different syntax. At this point, to combine these two small components together we need some ``glue code''. The two ASTs \lstinline{OldAlg} and
\lstinline{NewAlg} should be put together, but instead of defining a new trait, it is more convenient to directly use compound types in the parameter.
\begin{lstlisting}
trait OldNewParser[E, T] {
    val p : (OldAlg[E] with NewAlg[E, T]) => (=> (PackratParser[E], PackratParser[T]))
            => (PackratParser[E], PackratParser[T]) = alg => p => {
        val pOld = new OldParser[E](){}
        val pNew = new NewParser[E, T](){}
        (pOld.pE(alg)(p._1) ||| pNew.pE(alg)(p), pNew.pT(alg)(p))
    }
  }
\end{lstlisting}
Parsers for expressions and types are connected using alternative, respectively. Hence the isolation for different syntax
is guaranteed by the type system.
