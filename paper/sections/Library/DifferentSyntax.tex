\subsection{Object Algebras for Different Syntax}\label{subsec:differentsyntax}

\haoyuan{To be split into Parsing with OA, and Different Syntax.}

Such extensibility becomes fragile when it comes to grammars with different syntax. Now suppose we would like to have types in the grammar. Firstly the new grammar is shown below, where the \lstinline{IntT} type and lambda expressions with annotation have been added:
\begin{lstlisting}
e ::= x | e ' ' e | \x:t.e
t ::= "Int"
\end{lstlisting}

We proceed to implement those parsers. An issue is that we need both a \lstinline{Parser[Expr]} and a \lstinline{Parser[Type]} in the fixpoint.
Hence we use a pair in the parameter:
\begin{lstlisting}
type Pair = (Parser[Expr], Parser[Type])

class Type
class IntT extends Type
val pInt : (=> Pair) => Parser[Type] =
    p => "Int" ^^ { _ => new IntT() }

class Lam(x : String, t : Type, e : Expr) extends Expr
val pLam : (=> Pair) => Parser[Expr] =
    p => ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1) ^^
        { case x ~ t ~ e => new Lam(x, t, e) }

val pVar2 : (=> Pair) => Parser[Expr] = p => pVar(p._1)
val pApp2 : (=> Pair) => Parser[Expr] = p => pApp(p._1)

val pET : (=> Pair) => Pair = {
    val pE = pVar2 ||| pApp2 ||| pLam
    val pT = pInt
    p => (pE(p), pT(p))
}
\end{lstlisting}
Based on the old \lstinline{pVar} and \lstinline{pApp}, we implement \lstinline{pVar2} and \lstinline{pApp2} which take the pair as their fix-points instead.
In that case the parsers are consistent, and hence can be composed using the combinator \lstinline{|||}.
The last value \lstinline{pET} integrates the four single parsers defined before, where parsers for expressions and parsers for types are composed respectively. Furthermore, we use \lstinline{fix(p)} to obtain the pair of two parsers we want: one for expressions, the other for types. The parser \lstinline{fix(p)._1} parsers expressions like \lstinline{"\x:Int.x x"} successfully. Yet meanwhile, some drawbacks of this approach come into sight. With different syntax, it
is necessary to extend the fix-point to contain more parsers, in which case usually some structures like tuples are used,
making code tedious and less elegant. Moreover, we need to update such a fix-point in the arguments of all previously defined parsers, so as to make parsers consistent for the combinator (things get even worse without that combinator).
On the other hand, the modularity is quite restricted; only parsing and datatypes are extensible.
Suppose now we want to realize some behaviors on those data structures, for example pretty-printing, then whenever we introduce a new behavior,
it needs implementations in every class body, requiring existing code to be modified. At this point, Object Algebras are adopted for data structures
instead.

One intuition of using Object Algebras is to separate data structures from behaviors, so as to modularize the design, and both parts are even more modular and reusable. We can simply add new variants corresponding to the new cases in the grammar, or realize different operations on structures, without modifying existing code, meanwhile separate compilation is supported. Another one is that Object Algebras benefit us from using generics, where we can abstract different syntax in the type parameters, and define less classes, simplifying code comparatively. Below we present the code using Object Algebras, where we start from \lstinline{varE} and \lstinline{appE} only, later we will extend them with \lstinline{intT} and \lstinline{lamE}:
\begin{lstlisting}
trait OldAlg[E] {
    def varE(x : String) : E
    def appE(e1 : E, e2 : E) : E
}

trait OldParser[E] {
    val pE : OldAlg[E] => (=> Parser[E]) => Parser[E] = alg => p =>
        ident ^^ { x => alg.varE(x) } |||
        p ~ p ^^ { case e1 ~ e2 => alg.appE(e1, e2) }
}
\end{lstlisting}
Here \lstinline{OldAlg} is an Object Algebra interface. An Object Algebra interface is more like a small language, where several cases (constructors) are put together. Since with Object Algebras structures are implicit, a parser of \lstinline{OldAlg} should generate ``structures'' with
type \lstinline{"OldAlg[E] =>} \lstinline{E"} for any \lstinline{E}. In \lstinline{OldParser}, \lstinline{alg} of type
\lstinline{OldAlg[E]} can be any algebra, which appears as a parameter of \lstinline{pE}, then in the body of \lstinline{pE} the algebra
is invoked correspondingly right after parsing. It means we do not get any explicit objects generated from parsers, but they are immediately applied with algebras and return the results. To make \lstinline{alg} as a generic algebra, the enclosing trait of the parser, namely \lstinline{OldParser}, is generic.

Now we move on to declare \lstinline{intT} and \lstinline{lamE} in a new trait:
\begin{lstlisting}
trait NewAlg[E, T] {
    def intT() : T
    def lamE(x : String, t : T, e : E) : E
}

trait NewParser[E, T] {
    val pE : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[E] = alg => p =>
        ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1)
            ^^ { case x ~ t ~ e => alg.lamE(x, t, e) }
    val pT : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[T] = alg => p =>
        "Int" ^^ { _ => alg.intT() }
}
\end{lstlisting}
\lstinline{NewParser} contains parsers for both expressions and types. From the code we observe that the multi-sorts of Object Algebra interface
exactly express different syntax. At this point, to combine these two small components together we need some ``glue code''. The two ASTs \lstinline{OldAlg} and
\lstinline{NewAlg} should be put together, but instead of defining a new trait, it is more convenient to directly use compound types in the parameter.
\begin{lstlisting}
trait OldNewParser[E, T] {
    val p : (OldAlg[E] with NewAlg[E, T]) => (=> (PackratParser[E], PackratParser[T]))
            => (PackratParser[E], PackratParser[T]) = alg => p => {
        val pOld = new OldParser[E](){}
        val pNew = new NewParser[E, T](){}
        (pOld.pE(alg)(p._1) ||| pNew.pE(alg)(p), pNew.pT(alg)(p))
    }
  }
\end{lstlisting}
Parsers for expressions and types are connected using alternative, respectively. Hence the isolation for different syntax
is guaranteed by the type system.
