\subsection{Parsing with Multiple Syntax}\label{subsec:differentsyntax}

\haoyuan{Another way to organize the paper is to introduce the lack support of class approach for multiple different syntax, and directly extend var and app with lam.}

Back to the class approach, the only little extensibility is just fragile when it comes to grammars with different syntax. Suppose we would like to have types in the expression language. Firstly the new grammar is shown below, where the \lstinline{Int} type and lambda expressions with annotation have been added to class \lstinline{Expr}:
\begin{lstlisting}
e ::= x | e ' ' e | \x:t.e
t ::= "Int"
\end{lstlisting}

We proceed to implement those parsers. An issue is that we need both a \lstinline{Parser[Expr]} and a \lstinline{Parser[Type]} in the fixpoint.
Hence we use a pair in the parameter:
\begin{lstlisting}
type Pair = (Parser[Expr], Parser[Type])

class Type
class IntT extends Type
val pInt : (=> Pair) => Parser[Type] =
    p => "Int" ^^ { _ => new IntT() }

class Lam(x : String, t : Type, e : Expr) extends Expr
val pLam : (=> Pair) => Parser[Expr] =
    p => ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1) ^^
        { case x ~ t ~ e => new Lam(x, t, e) }

val pVar2 : (=> Pair) => Parser[Expr] = p => pVar(p._1)
val pApp2 : (=> Pair) => Parser[Expr] = p => pApp(p._1)

val pET : (=> Pair) => Pair = {
    val pE = pVar2 ||| pApp2 ||| pLam
    val pT = pInt
    p => (pE(p), pT(p))
}
\end{lstlisting}
Based on the old \lstinline{pVar} and \lstinline{pApp}, we implement \lstinline{pVar2} and \lstinline{pApp2} which take the pair as their fix-points instead.
In that case the parsers are consistent, and hence can be composed using the combinator \lstinline{|||}.
The last value \lstinline{pET} integrates the four single parsers defined before, where parsers for expressions and parsers for types are composed respectively. Furthermore, we use \lstinline{fix(p)} to obtain the pair of two parsers we want: one for expressions, the other for types. The parser \lstinline{fix(p)._1} parsers expressions like \lstinline{"\x:Int.x x"} successfully. Yet meanwhile, some drawbacks of this approach come into sight. With different syntax, it
is necessary to extend the fix-point to contain more parsers, in which case usually some structures like tuples are used,
making code tedious and less elegant. Moreover, we need to update such a fix-point in the arguments of all previously defined parsers, so as to make parsers consistent for the combinator (things get even worse without that combinator).

One intuition of using Object Algebras, as illustrated above, is to separate data structures from behaviors, so as to modularize the design, and both parts are even more modular and reusable. We can simply add new variants corresponding to the new cases in the grammar, or realize different operations on structures, without modifying existing code, meanwhile separate compilation is supported. Another one is that Object Algebras benefit us from using generics, where we can abstract different syntax in the type parameters, and define less classes, simplifying code comparatively. Below we present the code using Object Algebras, where we start from \lstinline{ExprAlg} (with \lstinline{varE} and \lstinline{appE} only), and define a new Object Algebra interface with \lstinline{intT} and \lstinline{lamE}:
\begin{lstlisting}
trait LamAlg[E, T] {
    def intT() : T
    def lamE(x : String, t : T, e : E) : E
}

trait NewParser[E, T] {
    val pE : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[E] = alg => p =>
        ("\\" ~> ident) ~ (":" ~> p._2) ~ ("." ~> p._1)
            ^^ { case x ~ t ~ e => alg.lamE(x, t, e) }
    val pT : NewAlg[E, T] => (=> (PackratParser[E], PackratParser[T]))
            => PackratParser[T] = alg => p =>
        "Int" ^^ { _ => alg.intT() }
}
\end{lstlisting}
\lstinline{NewParser} contains parsers for both expressions and types. From the code we observe that the multi-sorts of Object Algebra interface
exactly express different syntax. At this point, to combine these two small components together we need some ``glue code''. The two ASTs \lstinline{OldAlg} and
\lstinline{NewAlg} should be put together, but instead of defining a new trait, it is more convenient to directly use compound types in the parameter.
\begin{lstlisting}
trait OldNewParser[E, T] {
    val p : (OldAlg[E] with NewAlg[E, T]) => (=> (PackratParser[E], PackratParser[T]))
            => (PackratParser[E], PackratParser[T]) = alg => p => {
        val pOld = new OldParser[E](){}
        val pNew = new NewParser[E, T](){}
        (pOld.pE(alg)(p._1) ||| pNew.pE(alg)(p), pNew.pT(alg)(p))
    }
  }
\end{lstlisting}
Parsers for expressions and types are connected using alternative, respectively. Hence the isolation for different syntax
is guaranteed by the type system.
