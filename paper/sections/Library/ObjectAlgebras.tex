\subsection{Object Algebras}\label{subsec:objectalgebras}

Object Algebras captures a design pattern to address the famous \textit{Expression Problem} nicely,
achieving two dimensions of extensibility (data variants and operations) in a modular and type-safe way.
Because of this, the definition of data structures is separated from behaviors on them, and future extensions
to both sides no longer require existing code to be modified, supporting separate compilation.

In Object Algebras, ASTs as recursive data structures are defined using traits, where each constructor corresponds
to an abstract method inside. The recursive types are represented using generics. Here we show the example of a simple
expression language:
\begin{lstlisting}
trait ExpAlg[E] {
    def lit(i : Int) : E
    def add(e1 : E, e2 : E) : E
}
\end{lstlisting}
The language has two constructors: literals and additions. The trait \lstinline{ExpAlg} is called an \textit{Object Algebra interface},
whereas as a factory, it cannot produces objects for the expressions directly like traditional approaches, but abstract the results in its
type parameter \lstinline{E} instead. To realize an operation on expressions, we simply instantiate the type parameter by a concrete type and
provides implementations for all cases. Below is an example of evaluation:
\begin{lstlisting}
trait Eval extends ExpAlg[Int] {
    def lit(i : Int) = i
    def add(e1 : Int, e2 : Int) = e1 + e2
}
\end{lstlisting}
Here \lstinline{Eval} is called an \textit{Object Algebra}. It traverses an expression bottom-up, and returns an integer as the result.
Furthermore, one can define a new trait to implement pretty-printing on expressions:
\begin{lstlisting}
trait Print extends ExpAlg[String] {
    def lit(i : Int) = "" + i
    def add(e1 : String, e2 : String) = e1 + " + " + e2
}
\end{lstlisting}
On the other hand, the data variants can be extended by inheriting \lstinline{ExpAlg} and adding new cases only. Suppose we want to
have subtraction in expressions, a new Object Algebra interface \lstinline{SubAlg} is defined as follows:
\begin{lstlisting}
trait SubAlg[E] extends ExpAlg[E] {
    def sub(e1 : E, e2 : E) : E
}
\end{lstlisting}
Now evaluation on the new language can be realized by code reuse, and without modifying existing code:
\begin{lstlisting}
trait SubEval extends Eval {
    def sub(e1 : Int, e2 : Int) = e1 - e2
}
\end{lstlisting}
On this, to create an expression of \lstinline{SubAlg}, a generic method is defined as follows:
\begin{lstlisting}
def build[E](alg : SubAlg[E]) : E =
    alg.sub(alg.add(alg.lit(2), alg.lit(3)), alg.lit(4))
\end{lstlisting}
Such a method implicitly represents the expression \lstinline{"2 + 3 - 4"}. The code
\begin{lstlisting}
build(new Eval(){})
\end{lstlisting}
results in \lstinline{1}, as the result of evaluation. Now we observe that an ``object'' of expression actually
has the function type \lstinline{SubAlg[E] =>} \lstinline{E} for generic \lstinline{E}. At this point, one may argue
that it is illusory compared to traditional objects, and since we are struggling against the parsing problem, if a parser
produces structures as functions, it could be hardly be further processed like objects, especially, in the design of a compiler
there will be a lot of desugarings (or transformations). However, we argue that this is not a case, because functions can be used
in a very clever way. For example, if one wants to refactor an \lstinline{ExpAlg} expression to a \lstinline{SubAlg} expression by
replacing all negative numbers with subtraction, a transformation algebra can be implemented as follows:
\begin{lstlisting}
trait Refactor[E] extends ExpAlg[E] {
    def alg : SubAlg[E]
    def lit(i : Int) = if (i > 0) alg.lit(i) else alg.sub(alg.lit(0), alg.lit(-i))
    def add(e1 : E, e2 : E) = alg.add(e1, e2)
}
\end{lstlisting}
With \lstinline{Refactor}, the expression \lstinline{"1 + (-2)"} is refactored to \lstinline{"1 + (0 - 2)"}. The abstract method
\lstinline{alg} in \lstinline{Refactor} can be any algebra of \lstinline{SubAlg}, simply for delegation. By passing a concrete implementation
to \lstinline{alg}, \lstinline{Refactor} will be able to apply refactoring to an \lstinline{ExpAlg} expression.