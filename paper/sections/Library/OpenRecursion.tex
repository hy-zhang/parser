\section{Modular Parsing Library}\label{sec:library}

%\begin{itemize}
%\item Fixpoints library + explaining delegation with some examples
%\item Alternative combinator + others
%\item Trait Composition to do Language Composition
%\end{itemize}

In this section, we will further look into the mechanism behind our modular parsing library.
We will first introduce some concepts independently from the process of parsing, including open recursion and Object Algebras,
then present how they are integrated in our library.
Starting from simple examples, a series of extensions and refactorings will be applied to illustrate
how we achieve modularity in a type-safe way.

\subsection{Open Recursion and Delegation}\label{sec:openrecursion}

Open recursion is known as a useful feature that one method body can ``invoke another method of the same object via a special variable called \lstinline{self} or, in some languages, \lstinline[keywords={}]{this}'' (by Ralf Hinze). The interesting thing is that such a variable \lstinline{self} is late-bound, or open to the recursion, which means it can integrate some additional features defined later, whereas the method that takes \lstinline{self} as a parameter can simply delegate its known cases to it.

For sure we cannot always leave it open; upon using it we have to close the recursion, and at that time we need to take a fix-point. Here one might suddenly be reminded of the \lstinline{fix} function in some functional languages like Haskell. Below is the famous Fibonacci example:
\begin{lstlisting}[language=Haskell,keywords={}]
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
\end{lstlisting}
An alternative approach using open recursion is as follows:
\begin{lstlisting}[language=Haskell,keywords={type}]
type Fix t = t -> t

fib' :: Fix (Int -> Int)
fib' self 0 = 0
fib' self 1 = 1
fib' self n = self (n - 1) + self (n - 2)
\end{lstlisting}
where \lstinline{self} is the explicit self-reference, namely the delegator. Functions like \lstinline{fib'} which takes
an explicit self-reference as its parameter are called \textit{generators} (by Ralf Hinze). The definition of \lstinline{fix} is:
\begin{lstlisting}[language=Haskell,keywords={}]
fix f = let x = f x in x
\end{lstlisting}
If we close the recursion on \lstinline{fib'} only, the evaluation of \lstinline{fix fib'} \lstinline{2} is as follows:
\begin{lstlisting}[language=Haskell,keywords={}]
   fix fib' 2
= let x = fib' x in x 2
= let x = fib' x in fib' x 2
= let x = fib' x in (x 1) + (x 0)
= let x = fib' x in (fib' x 1) + (fib' x 0)
= let x = fib' x in 1 + 0
= 1
\end{lstlisting}
which behaves the same as \lstinline{fib 2}. The process of evaluation will terminate if there are some base cases (like the first two in
\lstinline{fib'}) which stop the recursion in their branches, and the evaluation is finally reduced to those cases.

Suppose now we want to make use of open recursion for additional operations. We first define a combinator which combines the results of two generators in a pair:
\begin{lstlisting}[language=Haskell,keywords={}]
(*) :: Fix (a -> b) -> Fix (a -> c) -> Fix (a -> (b, c))
f * g = \self x -> (f (fst . self) x, g (snd . self) x)
\end{lstlisting}
Then we define a generator which prints out a number as a string:
\begin{lstlisting}[language=Haskell,keywords={}]
show' :: Fix (Int -> String)
show' self x = show x
\end{lstlisting}
Now \lstinline{fix (fib'}\lstinline{ * show')} \lstinline{2} results in \lstinline{(1, "2")}. We have seen that both \lstinline{fib'} and \lstinline{show'} are integrated in the evaluation. In Scala, however, there is no \lstinline{fix} function, but it can be easily defined since it is based on lazy evaluation. See below:
\begin{lstlisting}
def fix[A](f : (=> A) => A) : A = {
    lazy val a : A = f(a)
    a
}
\end{lstlisting}
Next we define the general combinator \lstinline{merge} for open recursion. It is similar to the \lstinline{(*)} above, but instead of putting two values in a pair by default, \lstinline{merge} takes a parameter called \lstinline{op}, which tells the associative operation of two results.
\begin{lstlisting}
def merge[E, F, G, H[_,_]](op : F => G => H[F, G], x : (=> E) => F, y : (=> E) => G) : (=> E) => H[F, G] = e => op(x(e))(y(e))
\end{lstlisting}
