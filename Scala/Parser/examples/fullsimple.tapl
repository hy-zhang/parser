let x = succ 0 in let y = succ x in y
fix (\eo: {even: Nat -> Bool, odd: Nat -> Bool}.{even = \x: Nat. if iszero x then true else eo.odd (pred x), odd = \x: Nat. if iszero x then false else eo.even (pred x)})
evenodd.even (succ 0)
evenodd.even (succ (succ 0))
\x: Nat.if iszero x then true else if iszero (pred x) then false else even (pred (pred x))
even (succ (succ (succ 0)))
\t:{firstlast:String, addr:String}.t
{firstlast="lambdamix", addr="Russia"} as PhysicalAddr
\t:{name:String, email:String}.t
\t:<physical:PhysicalAddr, virtual:VirtualAddr>.t
\a:Addr. case a of <physical=x> => x.firstlast | <virtual=y> => y.name
"123"
{firstlast= "lambdamix", addr="Russia"} as PhysicalAddr
{name = "ilya", email = "ilya@ru"} as VirtualAddr
<physical=pa> as Addr
<virtual=va> as Addr
getName addr1
getName addr2
\x: Unit. 5
\x: Unit. 5
let x = 5 in 7
(\x:Bool->Bool.if x false then true else false) (\x:Bool.if x then false else true)
inert [Bool->Nat]
<l=unit> as <l:Unit, r:Unit>
(if ((< b = true > as Nat) (succ b)) then (pred (\ b : A . a)) else (let e = (let e = (true as String) in (succ "apple")) in (succ 1)))
(case (succ (\ a : (Float -> A) . "boy")) of < e = a > => (succ (let e = "apple" in unit)) | < e = c > => (pred (< b = ({ d = unit , a = 0 }) > as ({ e : Bool , d : Nat }))))
({ e = ({ d = (iszero b) , b = (0 . d) }) , c = (iszero (inert [ B ])) })
(\ b : (({ a : Nat , d : C }) -> (< c : Bool , d : A >)) . (\ c : (A -> Float) . (let c = false in a)))
(pred (succ (inert [ (< e : Unit , a : A >) ])))
(iszero (inert [ ({ d : A , d : B }) ]))
(({ a = (inert [ ({ d : Bool , c : Bool }) ]) , a = (succ b) }) (\ e : (< b : Bool , b : Nat >) . (pred (fix b))))
(case (inert [ (({ b : (Float -> A) , e : (< a : A , b : A >) }) -> (< c : (< e : Unit , b : C >) , d : Float >)) ]) of < a = a > => (fix (\ b : ({ c : A , e : Nat }) . b)) | < a = c > => ({ c = ({ d = unit , a = (pred 2) }) , b = (iszero (iszero a)) }))
(((pred (let c = true in (inert [ Float ]))) . e) (\ c : (< d : ({ d : String , d : C }) , e : ((< b : A , d : C >) -> Unit) >) . (fix (if true then 1 else b))))
({ b = (fix ({ e = (pred 2) , c = (iszero 1) })) , b = ((succ (succ (succ 2))) . d) })
({ d = (succ ({ c = unit , d = 0 })) , b = (if ({ d = true , c = (fix unit) }) then (succ unit) else (case "boy" of < c = b > => true | < b = d > => "apple")) })
(let a = ({ e = (fix (1 . b)) , b = (inert [ ({ a : Float , d : Bool }) ]) }) in (let c = (iszero b) in (fix "boy")))
(\ c : ({ a : (< b : Nat , d : Unit >) , b : (< e : Unit , c : Float >) }) . (inert [ (Nat -> Bool) ]))
(fix (fix (if (if b then a else 1) then c else (b "apple"))))
(if (succ (succ (if a then 0 else 2))) then ((fix (0 2)) . a) else (< d = (inert [ ({ e : ({ e : Unit , d : Bool }) , c : String }) ]) > as (({ a : String , b : Bool }) -> Unit)))
((((case 0 of < c = e > => 2 | < a = c > => a) as (< c : Unit , a : C >)) . b) (< a = (let c = (< e = 0 > as C) in (b . b)) > as (B -> A)))
(let e = (pred (pred (unit unit))) in (succ (< b = true > as B)))
(iszero (\ a : ((C -> Bool) -> (< c : A , e : B >)) . (pred 2)))
(iszero ((succ 2) . d))
(let c = (succ (succ (unit true))) in (fix (fix a)))
(inert [ ((< d : C , b : B >) -> ({ e : (< e : Nat , e : A >) , d : (A -> B) })) ])
((iszero (2 "apple")) as (((B -> Float) -> Unit) -> (< c : ({ c : String , d : Bool }) , a : (< e : A , d : Float >) >)))
(\ a : ({ b : ((< d : (Float -> Float) , e : String >) -> (B -> Unit)) , b : (< b : (B -> Bool) , c : (< b : ({ b : Bool , e : Float }) , b : (B -> Nat) >) >) }) . (if (fix c) then (fix unit) else (({ e = c , a = 2 }) . a)))
(succ (\ b : ({ c : B , a : B }) . ((inert [ B ]) 1)))
(((succ c) as (< d : String , e : B >)) . d)
(fix (pred (pred unit)))
((if (0 as ({ e : Nat , a : Nat })) then (iszero 0) else (a as B)) (case (let a = "boy" in (\ a : Unit . a)) of < c = a > => (case 0 of < c = b > => b | < b = b > => true) | < d = d > => (unit . a)))
(if (\ c : ({ b : ({ a : Bool , a : Unit }) , e : (< a : C , d : A >) }) . ((< c = b > as Nat) as Bool)) then ((pred true) as (C -> Bool)) else (let b = (iszero "apple") in (unit as (Float -> Float))))
((if (< e = (b "apple") > as (< b : Unit , e : String >)) then (inert [ (< c : B , c : String >) ]) else (inert [ ({ b : Bool , d : Unit }) ])) . d)
((pred (succ (case "apple" of < e = b > => "apple" | < a = e > => a))) . e)
((iszero (if "boy" then (case 0 of < e = c > => 1 | < e = e > => a) else true)) as ((C -> Nat) -> ({ b : (< e : B , d : B >) , d : ({ c : B , b : String }) })))
(case (pred ((< c = 1 > as Nat) . e)) of < b = c > => (< b = (\ b : B . false) > as (< d : ({ b : Bool , e : Nat }) , b : ({ e : Nat , e : String }) >)) | < c = a > => ((if 1 then a else b) as ({ c : (C -> Float) , e : Float })))
(fix (if (iszero (pred "boy")) then (let e = (iszero false) in (case false of < e = b > => 0 | < c = b > => unit)) else (\ d : Nat . ({ a = 0 , b = 0 }))))
(pred (if ((pred 0) as ({ b : B , b : B })) then (((\ d : String . 2) as Bool) ({ c = a , a = 2 })) else ((< e = 0 > as C) . e)))
(iszero ({ b = (fix "apple") , d = (pred (let a = a in "apple")) }))
(case (inert [ (Bool -> Nat) ]) of < c = b > => ((if ((unit . c) 0) then (pred unit) else (inert [ Unit ])) . e) | < c = c > => ((fix (if b then b else a)) as (Unit -> (< b : C , b : A >))))
(if ((succ (iszero b)) as (< c : Bool , c : Float >)) then ((succ (pred "boy")) (case a of < a = a > => unit | < d = b > => unit)) else (< e = (iszero false) > as (({ e : Float , a : Float }) -> Nat)))
(let e = (succ (inert [ (< e : Float , a : (Unit -> A) >) ])) in ({ b = (let c = unit in (succ b)) , b = ((case "apple" of < b = c > => true | < c = a > => false) as ({ c : String , e : C })) }))
(inert [ ((< e : Nat , e : (< d : B , d : C >) >) -> ({ c : ({ b : Float , a : ({ b : A , b : Nat }) }) , a : (< d : (< c : String , b : A >) , a : Nat >) })) ])
({ c = (inert [ (< b : (Float -> A) , c : (< a : A , d : Nat >) >) ]) , a = (iszero (pred (\ c : String . "apple"))) })
(let c = (inert [ ({ e : ({ e : Bool , e : A }) , c : ({ c : Float , e : Nat }) }) ]) in (case ({ e = (b . c) , a = "apple" }) of < b = a > => (let d = (pred "boy") in (fix (unit a))) | < e = b > => (let b = (c as Unit) in (inert [ String ]))))
(let a = (inert [ (< d : ({ e : Bool , b : Float }) , b : (Float -> Float) >) ]) in (pred (iszero ({ b = c , c = "apple" }))))
(< c = (\ a : ({ c : Unit , d : (A -> Unit) }) . (iszero (fix true))) > as (< b : (< c : ({ a : Bool , d : Bool }) , c : C >) , c : ((Bool -> A) -> ({ b : Unit , e : C })) >))
(let d = (pred (iszero 0)) in ((\ b : Float . (succ false)) (succ (true . e))))
(iszero (if (pred a) then (\ a : String . true) else ((let b = c in true) . b)))
(case ((let e = (inert [ B ]) in (< b = c > as Float)) as ({ e : ((< a : C , b : Unit >) -> Nat) , e : (< e : A , b : Nat >) })) of < e = c > => (iszero (if (if c then 0 else b) then "boy" else (\ e : Nat . c))) | < b = b > => (succ (fix (iszero unit))))
(case (inert [ ({ d : (({ c : String , a : Bool }) -> Nat) , e : (< e : String , b : Bool >) }) ]) of < e = d > => (pred (inert [ ({ b : Nat , c : B }) ])) | < c = d > => (pred (pred 1)))
(case (< e = (fix "apple") > as ((Bool -> String) -> Nat)) of < d = e > => ((pred (0 . a)) ((fix 2) as (< d : Bool , c : Float >))) | < c = b > => (inert [ (< e : ({ d : (Nat -> Float) , d : ({ c : Unit , d : Unit }) }) , d : (({ d : B , b : C }) -> Float) >) ]))
(iszero (iszero (< d = ((iszero b) . d) > as (A -> A))))
((succ (let e = (case (fix "boy") of < d = d > => "boy" | < b = b > => (fix c)) in (succ c))) (inert [ (< d : A , d : Unit >) ]))
(iszero ((fix (< a = c > as C)) as ({ e : A , d : A })))
(pred (succ (0 . c)))
((({ e = b , e = 1 }) ("boy" as Nat)) as (({ a : Bool , e : B }) -> (< b : Unit , a : Unit >)))
(inert [ (< b : (< e : (C -> B) , d : ({ b : Float , d : (Float -> String) }) >) , d : ((< e : C , c : String >) -> (< d : Unit , e : A >)) >) ])
(let c = (inert [ (B -> (< c : Nat , d : String >)) ]) in (iszero (((true unit) as C) . a)))
(pred ((let d = (inert [ A ]) in (iszero "apple")) (\ b : (C -> Bool) . (\ a : String . 2))))
(\ a : ({ d : ({ a : ({ c : Unit , e : String }) , d : (< d : (< d : Unit , e : String >) , b : B >) }) , b : (< d : Bool , a : (Nat -> Float) >) }) . ((fix 0) (< a = "apple" > as B)))
(fix (case (succ 2) of < d = d > => (pred (if a then c else "apple")) | < e = d > => (let c = 2 in 1)))
(\ a : ({ d : (< c : (String -> Float) , d : (< d : String , a : C >) >) , e : (Unit -> String) }) . (< c = (< d = 2 > as Unit) > as ({ d : Bool , a : B })))
(iszero ((succ ({ b = a , b = 0 })) (succ c)))
(\ e : ((({ c : (< d : String , e : String >) , a : C }) -> (< b : B , a : C >)) -> (< e : A , e : Bool >)) . ({ c = (case "apple" of < a = b > => "apple" | < b = e > => 2) , b = (let d = "apple" in false) }))
({ c = (fix ({ d = (({ d = unit , d = 2 }) . e) , e = (fix "boy") })) , e = (fix (\ a : C . "apple")) })
(fix (let a = (if 1 then (iszero "apple") else 1) in (inert [ (< b : (Bool -> C) , c : A >) ])))
(< e = (case (let d = true in 2) of < c = e > => (0 0) | < d = d > => (< d = unit > as B)) > as (< b : (C -> Unit) , c : (Float -> Float) >))
(iszero (< a = (pred (if c then unit else 2)) > as (< a : A , d : (< d : String , b : Nat >) >)))
(({ d = (inert [ ({ b : Bool , b : Bool }) ]) , a = (let e = (fix c) in ((2 as Bool) (pred "boy"))) }) . b)
(((case a of < d = d > => 0 | < e = d > => true) ({ d = (if unit then "apple" else 0) , b = a })) . e)
(let d = (\ c : (< a : (Float -> Nat) , c : String >) . (fix c)) in (let a = ({ c = (if 2 then 2 else "apple") , e = c }) in (fix (iszero false))))
(case (let a = (succ (succ ("boy" as String))) in ((if false then 1 else true) as ({ e : B , e : Nat }))) of < c = a > => (pred ((if 2 then false else c) (inert [ Unit ]))) | < b = d > => (< b = (succ "apple") > as ({ b : ({ c : (< d : A , c : A >) , a : B }) , e : (Unit -> Unit) })))
(\ d : (((< b : A , a : Float >) -> ({ e : Nat , e : Nat })) -> (< a : (< b : Nat , b : String >) , b : (< a : Nat , b : A >) >)) . (if (\ a : (< c : (< b : Bool , b : C >) , c : Unit >) . (\ e : String . 1)) then (iszero (iszero a)) else (let c = (inert [ A ]) in "boy")))
(let c = (\ a : (< a : A , b : Nat >) . (0 as String)) in (< a = (unit . e) > as (String -> (C -> Nat))))
(iszero (fix ({ c = "boy" , d = 0 })))
(inert [ ({ a : ((< d : (< a : Nat , c : A >) , d : Bool >) -> (({ c : String , d : A }) -> C)) , e : (< a : (< a : Nat , b : ({ d : C , b : Float }) >) , c : ({ e : String , a : A }) >) }) ])
(if (pred ("boy" unit)) then ({ c = (pred (pred (let a = 2 in false))) , c = (fix (case false of < d = d > => (fix false) | < c = a > => 1)) }) else (pred ((fix 2) . d)))
(pred (fix (({ c = a , b = "apple" }) as Nat)))
(((inert [ Float ]) . e) . e)
(fix (pred ({ b = (if 1 then c else false) , b = "apple" })))
({ b = ({ a = (< b = c > as C) , e = (fix 0) }) , d = (pred (fix (2 2))) })
(iszero (fix (inert [ ({ b : Float , c : A }) ])))
(iszero (fix (inert [ (< a : C , e : Nat >) ])))
((case (b as (< b : String , e : String >)) of < c = b > => (case (if unit then 0 else (iszero 0)) of < c = b > => (false (let b = true in unit)) | < b = c > => ({ d = true , a = b })) | < e = c > => (fix (iszero c))) . a)
(< a = (fix (succ (\ d : Bool . 1))) > as (< a : (< a : Float , b : Nat >) , c : ({ b : String , d : Nat }) >))
(fix (case (inert [ Bool ]) of < b = a > => (iszero 1) | < d = c > => (if "apple" then ({ c = 1 , a = b }) else 1)))
(< d = ((\ d : (< a : A , c : (C -> B) >) . (\ e : (< b : String , d : C >) . (fix true))) as ({ c : ({ d : A , d : Nat }) , b : Float })) > as (({ a : C , d : Nat }) -> ({ a : Float , c : Float })))
((if (inert [ B ]) then (succ (fix 0)) else ((fix false) (< d = c > as B))) . c)
(< e = (pred (inert [ ({ a : Unit , e : Nat }) ])) > as (< b : ({ d : (Float -> Float) , c : ({ c : Unit , d : Bool }) }) , d : ({ c : ({ b : ({ d : B , c : String }) , d : ({ c : Nat , c : String }) }) , b : (Float -> Float) }) >))
(let a = (case ("apple" 2) of < b = e > => (iszero false) | < e = c > => (let d = 2 in true)) in (< c = (a as A) > as (({ a : A , c : Unit }) -> ({ a : Nat , a : A }))))
(if (fix ({ a = (false . c) , d = 1 })) then (case ((fix (inert [ Float ])) (\ d : String . (1 as Bool))) of < d = a > => (iszero (< e = true > as Float)) | < c = b > => (true (inert [ Unit ]))) else (inert [ (B -> B) ]))
(fix (fix (let a = (iszero 1) in (if (pred c) then true else "apple"))))
(\ d : ({ c : (< a : (< d : A , d : String >) , e : (String -> Bool) >) , b : (B -> Unit) }) . (iszero (< e = ({ b = b , d = true }) > as Unit)))
(if (fix (({ b = ("boy" b) , c = "apple" }) (unit "apple"))) then ({ b = ((case b of < b = a > => 1 | < e = a > => b) as ({ c : Float , a : String })) , a = (case ("apple" as String) of < e = b > => "apple" | < d = d > => c) }) else (let c = (iszero true) in (succ (1 as Bool))))
({ a = (if (pred 1) then ({ a = a , c = a }) else (pred (let a = "apple" in b))) , e = (if ((false 0) as B) then (b as A) else (case (\ d : B . 1) of < b = e > => unit | < d = a > => (pred c))) })
(((fix (case a of < c = a > => false | < a = c > => true)) . a) (fix (succ (0 . a))))
(< d = (inert [ (C -> Nat) ]) > as ({ b : ((< d : Float , e : Bool >) -> (< e : Nat , a : Float >)) , e : (({ b : Bool , e : Bool }) -> (< a : A , a : Bool >)) }))
(let b = ((if true then "apple" else "apple") as (< d : A , e : B >)) in ((< a = true > as A) as (< d : String , e : A >)))
(((let a = false in "apple") as ({ d : (Unit -> Unit) , c : Nat })) . d)
(succ ((let e = unit in true) as (< d : Unit , b : Nat >)))
(iszero (fix ((let d = false in unit) (unit as Float))))
(< b = ((< a = ({ b = unit , d = true }) > as (C -> Float)) (b as ({ b : Float , e : Unit }))) > as (< b : (< e : Nat , a : (C -> Float) >) , a : (< a : String , a : C >) >))
(\ e : ({ c : ({ e : (Float -> C) , a : (< e : B , b : C >) }) , c : (({ d : Nat , d : Unit }) -> B) }) . (< d = (succ (iszero 1)) > as (Unit -> (Bool -> Nat))))
(< c = (succ (({ e = (case true of < d = e > => b | < e = e > => true) , d = (iszero 2) }) (fix (iszero false)))) > as (< c : ({ b : (C -> Unit) , e : ({ e : Nat , c : Nat }) }) , b : (< e : (A -> Bool) , b : B >) >))
(< b = (\ a : (B -> A) . (pred 1)) > as ({ c : ((Bool -> Bool) -> (String -> Unit)) , c : ({ a : ({ c : A , b : Unit }) , d : String }) }))
(succ (inert [ ({ b : C , a : Float }) ]))
((\ a : (B -> B) . (false as A)) as ({ b : (((B -> Unit) -> (< e : Float , d : Unit >)) -> (< a : Float , d : Float >)) , b : (Bool -> Unit) }))
(succ ({ a = (pred unit) , b = (if 0 then ("boy" 2) else (iszero true)) }))
(fix ({ b = (if (c "boy") then (let b = a in unit) else false) , e = ({ b = ("boy" . c) , c = ("apple" as Nat) }) }))
((< c = (let b = (if 2 then false else true) in "boy") > as ({ e : Float , d : (< d : Float , e : Bool >) })) as (< d : ({ c : (< e : A , e : (< a : Unit , a : Nat >) >) , c : ({ e : Bool , a : Bool }) }) , a : ({ c : Bool , a : ({ d : C , b : Nat }) }) >))
(fix (let e = (< a = (iszero unit) > as ((Nat -> Unit) -> Unit)) in (iszero (fix 1))))
(inert [ ({ d : ({ c : (Unit -> C) , b : (B -> String) }) , a : ({ e : Float , d : A }) }) ])
(case (pred (fix "apple")) of < c = a > => (if ({ d = (case (succ "boy") of < d = e > => 2 | < b = a > => (succ 0)) , c = (let c = a in "boy") }) then (inert [ (< e : A , c : (< d : Nat , b : Float >) >) ]) else (iszero (let c = c in "boy"))) | < d = d > => (fix ({ d = (\ c : Float . unit) , e = (pred "apple") })))
(let c = (\ c : (Nat -> C) . (iszero (< a = a > as A))) in (case (({ c = 1 , d = "apple" }) as A) of < e = d > => (c unit) | < a = c > => (inert [ Bool ])))
(fix (succ (succ true)))
((if (< c = false > as (< e : B , d : String >)) then (if 2 then unit else (case unit of < b = a > => a | < c = d > => true)) else ({ d = (iszero "apple") , b = (\ d : (C -> Nat) . "apple") })) (\ e : (Bool -> Bool) . (pred "apple")))
(pred (succ ({ e = (let e = unit in 2) , e = unit })))
(iszero (< a = (case 2 of < e = c > => c | < e = a > => unit) > as (< d : (< a : Bool , b : String >) , c : String >)))
(fix (< b = (iszero "apple") > as (Bool -> Nat)))
(fix ((\ c : (< c : Float , c : String >) . 1) (case (fix ("apple" as A)) of < a = e > => (< a = 1 > as Bool) | < b = d > => (fix "boy"))))
(if (case (fix (c true)) of < b = a > => (let a = ((let c = "boy" in b) (inert [ Unit ])) in (pred "apple")) | < d = c > => (succ b)) then (\ c : ({ e : Unit , d : (Nat -> A) }) . ((fix 2) ({ a = (b as Unit) , c = b }))) else (pred (fix (\ c : Bool . "boy"))))
((({ d = (0 as Bool) , b = (succ 2) }) as ((< e : Nat , e : String >) -> ({ d : Nat , a : Bool }))) as ((< c : ({ b : String , e : Nat }) , e : B >) -> (A -> Bool)))
(iszero ({ e = (\ c : (< b : String , e : Bool >) . 0) , c = (fix (a as String)) }))
(let a = (case (inert [ (B -> Unit) ]) of < a = b > => ((let e = b in c) . a) | < a = e > => (case (pred 0) of < e = a > => (fix "boy") | < b = d > => ((case unit of < b = b > => 2 | < a = c > => 2) . b))) in (({ b = true , b = a }) as ({ d : (A -> Nat) , d : ({ b : String , a : C }) })))
(iszero (< e = (fix (let e = false in "apple")) > as ((< d : Bool , a : C >) -> ({ c : Unit , d : B }))))
(if (iszero ((succ "apple") as (< d : Nat , d : Bool >))) then (case (\ a : Float . (fix "apple")) of < c = a > => (iszero (\ a : C . ({ a = false , b = c }))) | < b = c > => ({ a = (\ d : C . (fix 0)) , a = (pred (c . e)) })) else ((iszero c) . a))
(\ c : (< d : ((< d : C , a : B >) -> ({ a : String , d : A })) , b : (({ c : B , c : C }) -> A) >) . (let a = (\ c : ({ d : Float , d : Bool }) . (fix (let b = c in c))) in (pred (succ unit))))
(if (iszero (pred c)) then ({ d = (inert [ (C -> Nat) ]) , e = (pred (succ "apple")) }) else ((fix (inert [ C ])) . a))
(inert [ (< e : ({ a : Bool , d : Float }) , c : (B -> (< e : B , e : B >)) >) ])
((fix (case 1 of < e = a > => b | < c = e > => false)) as ((Bool -> (C -> Nat)) -> ({ e : (< a : Nat , d : ({ b : String , a : Nat }) >) , b : ((< d : Nat , d : Bool >) -> (Bool -> Nat)) })))
((pred ((let e = c in "apple") as (< c : String , e : C >))) (iszero (\ b : (< d : (Float -> Nat) , b : (Float -> Nat) >) . (case "boy" of < a = b > => false | < d = e > => "apple"))))
(fix (inert [ (< a : (< b : C , d : B >) , d : ({ a : String , c : Unit }) >) ]))
(< c = (inert [ (({ b : Float , b : B }) -> B) ]) > as (< a : ({ d : B , d : (< c : Bool , e : Unit >) }) , a : (< b : C , e : Float >) >))
(< a = (let b = (fix (< d = unit > as Unit)) in (succ ({ b = "apple" , a = true }))) > as (< a : (C -> Float) , a : (Float -> Unit) >))
(case ({ c = (let c = (iszero 1) in (inert [ Float ])) , d = (iszero (< e = 1 > as A)) }) of < a = e > => (({ b = unit , a = false }) . c) | < a = d > => ((succ 0) (succ (< a = "boy" > as B))))
((let a = (inert [ ({ e : String , b : Bool }) ]) in (pred (case 0 of < b = a > => 0 | < a = a > => true))) (case ({ d = a , d = "apple" }) of < d = a > => (let c = b in 1) | < d = d > => (unit . c)))
(inert [ ({ e : ((< c : String , d : String >) -> A) , d : ({ e : A , d : A }) }) ])
({ e = ((case (let c = 1 in c) of < d = b > => ("apple" a) | < c = a > => (let c = a in c)) (let b = (c "apple") in (succ (0 . e)))) , a = ((< e = 1 > as Float) (\ b : B . ({ d = 0 , a = 1 }))) })
({ e = (iszero (pred ({ b = "apple" , b = b }))) , e = (pred (pred "apple")) })
(pred (< a = (fix (if a then true else b)) > as ((< e : (< e : A , c : String >) , b : Unit >) -> (< a : Unit , c : (< c : Float , d : Nat >) >))))
(fix ((let d = b in false) . d))
(inert [ (((C -> A) -> (< d : A , e : String >)) -> (< d : (< e : ({ c : B , a : A }) , e : ({ b : String , e : C }) >) , b : ((Bool -> Float) -> ({ d : String , a : Nat })) >)) ])
(((\ b : Float . false) (let a = b in true)) . b)
(inert [ ((< c : Unit , b : String >) -> (< e : (< c : B , b : Nat >) , b : ({ c : String , c : A }) >)) ])
(case (("boy" as C) (iszero "boy")) of < c = b > => (\ c : ({ c : C , c : ({ b : A , e : B }) }) . (< e = (case "apple" of < d = b > => unit | < b = d > => c) > as C)) | < b = c > => ({ c = (if (succ 2) then (iszero "apple") else (< e = false > as Unit)) , c = ({ e = (iszero a) , d = ({ c = 0 , c = b }) }) }))
({ e = (inert [ ({ c : Nat , e : Nat }) ]) , b = (fix (\ d : (B -> String) . (\ e : Unit . unit))) })
((fix (fix (inert [ (< c : Float , a : Float >) ]))) as ({ c : (< a : String , d : B >) , e : ({ e : Float , c : C }) }))
(fix ((if b then (iszero a) else true) (succ b)))
((iszero (false . a)) (< c = (iszero c) > as (< e : (String -> Bool) , d : C >)))
(fix (succ (0 (succ unit))))
(case (fix (iszero "apple")) of < e = e > => (let b = (let b = 2 in (succ 2)) in (inert [ (B -> Float) ])) | < b = e > => ((fix ({ a = unit , a = false })) ((inert [ C ]) true)))
(case (inert [ (C -> Float) ]) of < a = b > => (let d = ((inert [ Unit ]) . b) in (fix false)) | < e = a > => ((({ c = "boy" , c = (let a = c in 0) }) (fix false)) as (< c : Float , d : ({ e : C , e : B }) >)))
((pred (case "boy" of < d = d > => 2 | < c = a > => false)) as (({ d : ({ e : C , c : A }) , a : A }) -> (< d : ({ a : C , c : B }) , e : Unit >)))
(\ a : ({ e : (Unit -> String) , d : ({ e : ({ b : Nat , d : Bool }) , c : C }) }) . (\ b : (< a : ({ b : Unit , d : Bool }) , c : (Float -> Bool) >) . (pred (if 0 then 1 else unit))))
(\ a : (< d : ({ e : Bool , a : Unit }) , e : ((< c : (Unit -> Bool) , e : Float >) -> (< e : String , d : Bool >)) >) . (\ d : (< e : (< c : A , a : Bool >) , c : B >) . (succ unit)))
(< b = (iszero (< c = (case c of < c = d > => a | < d = d > => 0) > as Unit)) > as ({ d : ((Float -> Float) -> ({ c : A , e : Float })) , c : (({ e : Unit , e : Bool }) -> (< b : Float , c : ({ c : Bool , a : Nat }) >)) }))
(pred (fix (pred (pred true))))
(succ (succ (let e = true in c)))
({ a = (< c = (false . b) > as ({ c : (Nat -> Unit) , d : (< c : Unit , a : Nat >) })) , d = (inert [ (< a : (< a : Float , c : C >) , d : ({ c : Nat , b : C }) >) ]) })
(< e = (inert [ (Unit -> Bool) ]) > as ((< b : ({ d : B , d : B }) , a : ({ a : Unit , a : C }) >) -> (< d : (< d : B , d : Nat >) , e : ({ e : Unit , e : Nat }) >)))
(((\ a : (String -> Unit) . unit) . e) . b)
((pred (let b = ((succ c) as (< a : Float , a : C >)) in (< a = (inert [ Unit ]) > as (< c : String , e : C >)))) . a)
(let b = ({ c = (< b = b > as Float) , c = (< d = "boy" > as ({ e : Unit , b : Bool })) }) in (pred (("boy" 2) . c)))
(< e = (iszero (case (fix 0) of < e = a > => (let b = 0 in "apple") | < d = e > => (< c = 1 > as Nat))) > as ({ a : (< c : C , c : Nat >) , e : ((B -> Bool) -> C) }))
((case ((false b) as String) of < d = a > => (< c = (< c = 1 > as Bool) > as B) | < e = e > => (< a = (fix false) > as (< d : String , d : Unit >))) as ({ e : (C -> (Float -> String)) , b : ({ d : ({ d : B , b : C }) , d : ({ c : String , c : A }) }) }))
(\ d : (< a : (< c : B , d : B >) , d : (< e : ({ a : String , c : Bool }) , d : (Nat -> B) >) >) . (let d = (succ (2 as Nat)) in (< d = (2 as A) > as (Nat -> Nat))))
(if ((inert [ ({ c : (B -> Nat) , c : Float }) ]) as (({ a : Float , b : (B -> B) }) -> (A -> A))) then (iszero (succ (fix a))) else (iszero ({ b = (pred "boy") , e = 0 })))
({ b = (iszero ({ a = (succ false) , b = (case ({ a = b , c = c }) of < e = a > => true | < d = e > => ({ e = 0 , e = 2 })) })) , e = (let b = (case ({ a = c , d = false }) of < e = a > => true | < b = b > => a) in (iszero (inert [ Nat ]))) })
(\ e : ({ a : ({ d : Unit , b : Float }) , b : (< e : Float , e : ({ c : Bool , d : Float }) >) }) . ({ c = (< d = a > as B) , a = (pred (pred "apple")) }))
(inert [ ({ c : (< e : (< c : B , d : B >) , c : (< c : String , a : Float >) >) , b : (< e : C , c : (String -> Unit) >) }) ])
(case ((inert [ (< c : C , a : C >) ]) (\ b : (< d : Float , c : B >) . (inert [ ({ c : C , b : Bool }) ]))) of < c = c > => ({ c = (let c = (if 0 then c else 0) in ("apple" . b)) , a = (fix 2) }) | < e = c > => (< a = (let a = (case (iszero a) of < d = b > => b | < d = b > => (inert [ C ])) in (pred (case "apple" of < b = c > => b | < e = a > => "apple"))) > as ({ d : String , d : Unit })))
(case (("boy" as Bool) as (Unit -> A)) of < b = e > => (\ a : (< c : (< e : (Nat -> Float) , a : Nat >) , c : ({ c : Float , a : Nat }) >) . ((\ a : C . "apple") as (Bool -> Bool))) | < c = d > => (pred (\ e : Bool . (inert [ Unit ]))))
(if (iszero (fix (\ c : ({ d : B , a : C }) . (succ c)))) then (inert [ ((< c : Bool , e : Unit >) -> A) ]) else (inert [ (< e : ((< d : Nat , b : Bool >) -> String) , b : (A -> Float) >) ]))
(case (if (pred "boy") then (let e = (succ 0) in (succ 0)) else (if false then 1 else (succ 0))) of < c = c > => ((((< e = false > as Unit) (case unit of < d = e > => 2 | < a = a > => b)) (inert [ Unit ])) (succ (pred "apple"))) | < c = b > => ((inert [ ({ a : Bool , c : B }) ]) . b))
(inert [ ({ a : (< b : Unit , b : Bool >) , e : ({ a : Bool , e : Bool }) }) ])
(inert [ (< d : (< d : Unit , c : String >) , e : ({ c : A , b : ({ a : B , b : Unit }) }) >) ])
(case (if (1 as ({ c : B , a : Float })) then (false (succ "boy")) else (succ (if 2 then 2 else 2))) of < c = a > => (iszero (iszero (iszero a))) | < e = c > => (let c = (iszero (< a = unit > as Float)) in (let b = 1 in ({ a = unit , b = unit }))))
((\ d : ((< d : Nat , b : Float >) -> A) . ((let c = "apple" in "apple") (pred 0))) . b)
(iszero (let a = ((let d = 1 in 0) a) in (pred (succ true))))
({ a = ((if b then "apple" else a) (if b then 2 else unit)) , c = (succ (fix (\ c : Bool . a))) })
((succ (iszero (if a then 0 else (false as Nat)))) (iszero (a "apple")))
((pred ((unit a) . c)) as (< a : (< c : A , c : Unit >) , d : (< d : Float , c : (< c : C , d : String >) >) >))
((pred (0 as (< e : Nat , c : Float >))) as ({ c : ((< c : Unit , b : C >) -> (< a : Unit , a : Nat >)) , d : (Float -> A) }))
(case (succ (fix unit)) of < a = b > => (if (let a = (pred 2) in (inert [ Float ])) then (case (\ b : String . true) of < e = d > => 0 | < d = d > => ({ b = 2 , b = unit })) else (2 as ({ c : C , e : C }))) | < c = b > => (case (inert [ (< a : String , b : C >) ]) of < a = a > => (unit . e) | < b = d > => (< a = (let a = c in "boy") > as (Float -> (< c : Float , d : C >)))))
(\ a : (< d : (B -> String) , a : (< d : (< a : String , e : Nat >) , e : Unit >) >) . (fix ((fix a) as (String -> String))))
(\ d : (< e : ({ c : B , e : String }) , b : ({ c : Float , a : Bool }) >) . (< e = (fix (pred 2)) > as (B -> (< e : B , e : C >))))
(let b = (< a = (c . c) > as (Bool -> Unit)) in ((iszero 0) (pred (iszero 1))))
(if ((2 2) . e) then (iszero (pred a)) else (((\ a : Float . 2) as ({ c : C , b : B })) . d))
(iszero (pred (succ (pred 2))))
(pred (let c = (case "apple" of < e = b > => 1 | < e = c > => false) in ({ e = b , b = c })))
(case (inert [ ((A -> Float) -> (< b : B , e : Float >)) ]) of < d = d > => (iszero (pred (< a = c > as Float))) | < a = d > => ((fix ({ a = (case 2 of < b = c > => 0 | < d = c > => 2) , b = 2 })) as (< b : (C -> Float) , c : (Nat -> Bool) >)))
(iszero (if (\ d : ({ d : ({ e : A , a : Unit }) , b : ({ a : Nat , b : Unit }) }) . (iszero (a . c))) then (case 1 of < c = a > => false | < a = b > => (case b of < a = a > => b | < c = b > => a)) else ({ c = (pred 2) , b = (succ false) })))
(if (case (pred (if 1 then "boy" else 2)) of < a = b > => (inert [ String ]) | < e = a > => (if true then 0 else "boy")) then (let c = (iszero (fix "apple")) in ((< d = c > as A) . a)) else (iszero (iszero true)))
(succ (pred ({ a = "apple" , b = false })))
(inert [ (({ c : B , e : B }) -> (Unit -> B)) ])
(pred ((if (fix b) then (< d = 2 > as Unit) else (case "apple" of < b = e > => unit | < e = e > => true)) . a))
(succ (succ ((succ "boy") . b)))
(succ (iszero (iszero false)))
(\ c : ({ a : (< e : ({ e : A , a : Nat }) , c : (Unit -> Unit) >) , d : ({ a : (String -> C) , a : ({ a : C , a : ({ b : A , d : String }) }) }) }) . (iszero ({ a = (\ a : String . "boy") , b = (\ d : Unit . 1) })))
(\ a : (< b : ({ a : B , c : Nat }) , d : (< d : String , c : A >) >) . ((\ e : B . b) (succ (c b))))
(case (case (succ (b as A)) of < b = c > => (iszero (succ a)) | < e = d > => ((succ "boy") . d)) of < b = a > => (case (let b = true in 0) of < d = d > => (unit as A) | < b = d > => (inert [ Unit ])) | < c = d > => (< e = (< e = false > as Nat) > as (< c : A , e : ({ e : Float , e : String }) >)))
((iszero ({ e = (\ d : C . c) , b = (if 1 then 0 else "apple") })) ((\ e : C . "boy") as (< a : Unit , e : String >)))
((if (case true of < b = d > => "boy" | < b = d > => (inert [ C ])) then ("boy" . d) else (inert [ B ])) as (< a : (< c : (< c : String , a : C >) , c : String >) , a : (< b : B , c : Bool >) >))
(if (< d = (if (case 2 of < a = c > => 2 | < e = e > => "apple") then ("boy" as Nat) else c) > as ({ a : Bool , c : String })) then ({ a = ((if "apple" then true else "boy") as (< b : String , b : B >)) , c = ({ d = "apple" , b = 2 }) }) else (inert [ ({ a : ({ e : String , c : Unit }) , e : Bool }) ]))
(pred (if (\ b : (String -> Unit) . 1) then (\ d : Unit . false) else (succ false)))
(case ({ c = (if (if "boy" then b else 1) then "boy" else (< c = unit > as Bool)) , d = (iszero b) }) of < c = d > => (iszero (\ b : (A -> String) . 1)) | < b = e > => (fix (< b = (iszero true) > as Bool)))
(< b = ((inert [ B ]) as ({ b : Bool , c : Nat })) > as (< b : (A -> ({ c : Unit , b : Nat })) , c : (B -> Unit) >))
(< b = (({ a = 2 , b = 1 }) as (Bool -> Bool)) > as ({ b : (({ b : Bool , e : String }) -> (< e : Float , d : A >)) , a : (C -> (Nat -> Bool)) }))
({ d = ((pred "boy") . a) , a = (fix ((if ("apple" . b) then ("apple" "boy") else a) (let e = "boy" in "apple"))) })
(iszero (pred (fix "boy")))
(if (fix (succ (let c = c in b))) then (if (if (pred 1) then (2 . e) else (false 1)) then (fix (< e = b > as String)) else (({ d = 0 , a = b }) as ({ a : (< d : Float , b : Bool >) , e : (< b : A , a : Float >) }))) else ({ a = (\ c : ({ d : String , b : Nat }) . (inert [ Nat ])) , e = (succ ({ a = 0 , c = "apple" })) }))
(\ a : ((< c : Float , c : Float >) -> ({ a : B , d : Float })) . (iszero (\ b : Float . false)))
(< e = (fix ((inert [ (C -> Bool) ]) as (String -> ({ e : Unit , a : C })))) > as ((B -> B) -> (Bool -> Bool)))
((fix ({ a = "boy" , b = (succ a) })) as (< e : (Unit -> (< c : Nat , e : B >)) , e : (< c : A , b : C >) >))
(fix (succ (case ({ a = 2 , d = "boy" }) of < b = b > => ({ c = b , c = unit }) | < e = e > => (true as A))))
({ b = (\ d : (({ d : Unit , e : A }) -> ({ c : A , e : Unit })) . (inert [ Nat ])) , d = (fix (iszero "apple")) })
(inert [ ({ e : (< e : Float , a : Float >) , a : ({ d : C , c : String }) }) ])
(iszero ({ b = (let e = (succ true) in ({ e = unit , c = b })) , b = ((true . d) false) }))
(pred ({ d = (let b = (iszero c) in a) , d = (let d = ((case "apple" of < e = c > => true | < e = b > => false) . e) in (iszero b)) }))
(inert [ (< b : ({ d : (({ a : Bool , a : C }) -> ({ a : B , d : A })) , a : ({ c : (Bool -> C) , e : (Nat -> Nat) }) }) , e : (< a : Unit , c : Nat >) >) ])
(let a = (if (succ a) then (< e = (< d = 2 > as String) > as Float) else ((let b = false in 1) 1)) in (case (let d = (if 1 then true else false) in (true . d)) of < d = c > => (< d = unit > as B) | < c = c > => (b . e)))
(((case true of < e = b > => true | < b = b > => 0) as ((< d : C , b : Float >) -> (Unit -> Unit))) as (({ c : (< b : B , b : A >) , e : String }) -> (Unit -> Unit)))
((\ e : (< b : C , e : A >) . (fix false)) . d)
(if (((succ "boy") . a) . d) then (succ (pred (< b = a > as Nat))) else (fix (case (fix "apple") of < d = d > => ({ d = 2 , c = unit }) | < e = b > => b)))
(case (let e = (true as Bool) in (if 0 then "apple" else "boy")) of < c = a > => ({ d = (b true) , c = (let d = ({ b = "apple" , e = 0 }) in a) }) | < a = c > => (({ b = true , a = (\ a : C . 2) }) . e))
(if (case (if (c as ({ c : Unit , d : Float })) then (\ d : Unit . b) else (let d = "apple" in "apple")) of < c = b > => (pred (b as Bool)) | < e = a > => ((let b = (fix "apple") in 2) as ({ a : Unit , e : String }))) then ((let c = (let c = true in 2) in (b as Float)) as ({ a : ({ e : B , c : A }) , d : ({ e : Unit , a : Bool }) })) else (fix ((true as A) (iszero b))))
((if (case (a as Bool) of < e = a > => (let c = unit in 2) | < b = d > => "apple") then ((succ 0) as ({ d : Float , d : Bool })) else (case a of < c = b > => c | < e = d > => true)) (\ d : ({ e : C , a : (Float -> String) }) . (pred (fix unit))))
(inert [ (< b : ({ e : ({ c : Float , c : (Bool -> Nat) }) , a : ({ c : ({ d : String , b : A }) , b : (< e : Nat , c : String >) }) }) , a : ({ c : Nat , c : String }) >) ])
((succ (case (iszero c) of < d = d > => (fix "boy") | < d = b > => (fix 0))) . b)
(< e = (fix (succ a)) > as (< b : ((< e : A , b : Nat >) -> Unit) , c : (< c : Bool , d : String >) >))
((if (\ e : B . (iszero true)) then (pred (inert [ Float ])) else (pred (iszero "apple"))) as (< e : ({ c : A , d : Nat }) , d : (({ b : A , d : B }) -> (< a : Bool , b : C >)) >))
({ e = (if (pred false) then (if 0 then 0 else (c as String)) else (< a = c > as C)) , b = (case (iszero "apple") of < b = c > => (pred (< c = unit > as B)) | < d = e > => (("boy" b) . b)) })
((succ (inert [ (A -> C) ])) (succ (\ e : ((A -> Unit) -> Float) . (if true then 2 else 1))))
(succ (\ a : (< a : (B -> Bool) , e : C >) . (let d = (case (unit b) of < a = d > => 1 | < d = c > => (iszero true)) in (if 1 then 2 else "apple"))))
(((if (inert [ (String -> Float) ]) then (if (succ true) then "boy" else (succ true)) else (2 as C)) . c) . a)
(inert [ ({ b : (< a : C , e : Unit >) , e : ({ c : (String -> Unit) , e : String }) }) ])
(let b = (fix (succ 2)) in (succ (iszero 1)))
((\ d : (String -> Float) . (< d = 0 > as Float)) . e)
((iszero (pred 0)) as ({ c : ({ d : ({ c : Bool , a : Unit }) , e : (Nat -> C) }) , d : (({ d : Bool , e : Nat }) -> ((Unit -> A) -> ({ b : String , b : Unit }))) }))
(if (if (inert [ Bool ]) then (\ d : Bool . b) else (unit "boy")) then (succ (succ true)) else (fix (inert [ Float ])))
(inert [ (({ d : A , d : Unit }) -> ({ e : C , d : A })) ])
(succ (if (fix "boy") then (true . c) else (< e = a > as Float)))
((if (inert [ (< c : Float , a : Unit >) ]) then (< d = c > as ({ e : A , b : B })) else (\ d : ((A -> Unit) -> Unit) . ("boy" unit))) as ({ e : ({ a : String , a : C }) , a : (< c : (C -> Unit) , b : ({ b : String , a : Float }) >) }))
((iszero (if 2 then 0 else unit)) (if (if unit then (inert [ Nat ]) else unit) then (case false of < c = a > => 1 | < c = e > => (true . b)) else ({ e = (\ d : Unit . unit) , c = false })))
(let a = (if ({ e = (< e = true > as String) , d = (pred "apple") }) then (inert [ Nat ]) else ((\ a : String . "apple") (let d = 1 in "boy"))) in (pred ((pred 1) as Unit)))
((let b = (let d = "boy" in 2) in (unit unit)) . e)
(((iszero (fix true)) . d) . a)
(case (iszero (true . a)) of < e = e > => (succ (fix b)) | < a = c > => (case (0 "boy") of < c = e > => (fix (succ 2)) | < c = e > => (unit a)))
(< d = (succ ({ a = false , e = (pred "boy") })) > as ({ c : ((< b : Unit , e : Bool >) -> ({ d : Unit , d : Nat })) , e : ({ e : C , b : C }) }))
(\ e : ((< b : Unit , e : (< b : Float , a : Unit >) >) -> ({ d : (< d : Nat , c : A >) , e : (< c : B , b : Float >) })) . (let a = (1 2) in ({ b = "boy" , a = false })))
(inert [ (({ b : String , e : C }) -> (((String -> Unit) -> (< d : C , e : B >)) -> (< d : Bool , c : Nat >))) ])
((case (("boy" . b) as (Bool -> Bool)) of < b = a > => (pred ({ e = b , c = "boy" })) | < d = b > => (case (inert [ Unit ]) of < d = b > => ({ e = 2 , c = 1 }) | < a = e > => (c as Unit))) . e)
(({ a = (fix (pred b)) , d = (case (case 1 of < d = c > => "boy" | < c = c > => unit) of < a = c > => (pred c) | < c = a > => (b as A)) }) (< d = ("boy" a) > as ({ b : ({ a : C , d : Bool }) , e : (B -> Float) })))
(if (case (({ c = (if c then a else 1) , b = ({ c = true , e = "apple" }) }) ({ a = false , d = unit })) of < a = e > => (< c = (\ a : Bool . unit) > as Float) | < b = e > => ((iszero 1) . e)) then (pred ("apple" as A)) else ((case "apple" of < a = b > => "apple" | < d = e > => (true . c)) (inert [ (< b : C , b : String >) ])))
(< c = (inert [ (< c : Bool , c : (String -> A) >) ]) > as (< e : ({ d : (String -> A) , a : Nat }) , a : ({ a : ({ e : String , e : Bool }) , b : (< d : Float , c : String >) }) >))
(inert [ ({ e : (< a : Float , c : B >) , c : (< b : (({ e : Bool , d : Nat }) -> (< a : C , d : Unit >)) , d : ({ b : Unit , a : B }) >) }) ])
(succ (iszero (let b = 2 in unit)))
(pred (fix (succ (fix (\ b : Unit . c)))))
(let c = (\ e : (< c : (< c : Float , a : A >) , e : (String -> Unit) >) . (\ e : ({ c : Bool , c : A }) . unit)) in (inert [ ({ c : ({ e : C , d : Bool }) , c : (A -> C) }) ]))
(< e = (if (case (succ 1) of < a = d > => (pred a) | < b = d > => b) then (\ e : B . c) else (iszero c)) > as ({ a : (Unit -> Float) , a : (< a : Bool , b : Unit >) }))
(pred (let b = (case unit of < d = e > => true | < b = a > => b) in (c unit)))
(case (fix (if (\ c : Bool . b) then 0 else (pred "boy"))) of < b = a > => (succ (1 0)) | < e = c > => (fix ((true . d) . a)))
(({ b = ({ d = (case "apple" of < d = d > => false | < b = b > => false) , d = (iszero true) }) , d = (let c = "boy" in (fix true)) }) as ({ d : (Unit -> String) , e : ({ e : Nat , b : String }) }))
(inert [ ({ c : (Unit -> Nat) , a : ({ b : (< e : B , e : C >) , c : Unit }) }) ])
({ c = (\ a : (< e : A , d : Unit >) . (if "boy" then 2 else unit)) , c = (succ ({ a = true , b = false })) })
(iszero (if (iszero false) then ({ a = (pred true) , b = ({ a = c , c = "apple" }) }) else (let d = (1 . c) in (\ c : String . c))))
({ e = ((case 0 of < a = c > => (let d = true in c) | < d = a > => "boy") (inert [ String ])) , d = (\ c : ({ b : (B -> Unit) , b : Nat }) . (succ unit)) })
((if ({ e = unit , a = (c as Nat) }) then (iszero (b as Nat)) else (succ (inert [ A ]))) . e)
(succ (let a = (\ c : Nat . c) in (inert [ A ])))
(fix (case (true (pred "apple")) of < c = c > => ((case "apple" of < d = e > => 2 | < a = e > => b) . a) | < a = d > => (\ a : ({ b : Unit , c : Nat }) . c)))
(inert [ ((< d : (< c : Bool , d : C >) , e : (< b : ({ d : A , b : Nat }) , d : (A -> Unit) >) >) -> ((B -> String) -> ({ c : C , d : Nat }))) ])
(if (pred ((< a = c > as A) . b)) then ({ d = ("apple" as Float) , b = (inert [ ({ e : Float , d : C }) ]) }) else (pred (let d = (succ 1) in (if "boy" then "apple" else 2))))
(case ({ b = ("boy" as A) , d = (b . d) }) of < d = b > => (iszero (fix "boy")) | < a = b > => (((iszero c) . b) (pred (c b))))
(let c = (let e = (pred (case (succ 1) of < c = c > => "apple" | < a = c > => false)) in (< d = (inert [ Nat ]) > as (Bool -> B))) in (succ (succ (\ c : Unit . a))))
(fix (if (let e = "apple" in "boy") then (false as Float) else (unit ("boy" as Unit))))
(\ e : (({ d : (< e : String , e : String >) , e : (A -> (Nat -> Float)) }) -> (< d : (A -> B) , b : A >)) . (fix (1 as (Nat -> C))))
(inert [ ((< b : ({ a : A , c : Float }) , c : ({ a : Float , b : A }) >) -> ({ d : C , d : A })) ])
(\ d : ({ e : ({ d : Nat , c : B }) , c : (< a : (< b : B , d : A >) , e : Unit >) }) . ((true . c) ({ d = true , a = (succ b) })))
(< c = (fix (if 1 then (\ d : Unit . false) else false)) > as ({ d : ({ a : Float , c : A }) , e : (< e : ({ b : String , e : Float }) , e : ({ d : C , c : A }) >) }))
(if (iszero (< d = 0 > as String)) then (fix (if (case 1 of < d = a > => 2 | < c = d > => false) then (case unit of < c = d > => 0 | < d = b > => 0) else (succ "boy"))) else (let d = (iszero (fix 2)) in (case "apple" of < c = c > => unit | < c = c > => b)))
((succ (if "boy" then "apple" else c)) . e)
(pred (< a = (let e = 1 in "apple") > as (Unit -> Nat)))
(inert [ (< e : (B -> String) , c : ({ d : C , b : String }) >) ])
(fix ({ e = (inert [ A ]) , c = (false "boy") }))
(pred (succ (case unit of < a = a > => (pred true) | < e = e > => (< b = a > as B))))
((fix ({ d = "boy" , b = a })) as ({ d : ({ c : C , c : Float }) , d : (A -> C) }))
(inert [ (< e : (< b : ({ a : Nat , b : Nat }) , a : ({ e : Nat , d : Float }) >) , b : (< e : (String -> C) , b : (Float -> Float) >) >) ])
(if (fix ({ e = a , d = a })) then (< d = (c 0) > as (({ d : String , d : Bool }) -> (< d : Float , d : Unit >))) else ((succ ({ e = "apple" , a = 1 })) as (Unit -> Unit)))
(inert [ ((Nat -> ({ d : C , d : Bool })) -> ((< b : Unit , e : Nat >) -> ({ e : Unit , e : Unit }))) ])
(inert [ ({ b : (< a : Unit , c : Float >) , a : ((Unit -> Float) -> Float) }) ])
(succ (< b = (let a = "boy" in 1) > as (({ c : B , e : C }) -> Nat)))
((inert [ ({ b : Nat , d : (Float -> A) }) ]) as ((({ e : String , d : Unit }) -> (< d : C , c : Bool >)) -> (< c : Bool , d : ({ b : String , a : Unit }) >)))
(\ e : ((< d : Float , b : Unit >) -> ({ a : (A -> C) , d : (A -> Unit) })) . (succ (< d = (0 "apple") > as B)))
((if ((b . e) . e) then (true (unit as Float)) else (fix false)) as ((< d : ({ c : Unit , c : A }) , e : (Float -> Bool) >) -> ((< d : Nat , c : B >) -> Float)))
(inert [ ((B -> Unit) -> ({ e : A , d : B })) ])
((pred (< c = true > as Float)) as (< b : ({ a : Bool , e : A }) , a : (< d : (< c : Nat , a : Bool >) , c : B >) >))
((iszero (fix 1)) ((pred (\ d : Unit . a)) . c))
({ e = (pred (if true then b else "boy")) , a = (({ e = a , c = (if unit then 2 else unit) }) (\ c : String . "boy")) })
(((pred a) . b) . e)
(inert [ ((C -> Float) -> (< e : ({ a : (C -> B) , e : ({ a : Nat , b : Float }) }) , a : ({ a : C , b : String }) >)) ])
(if (iszero (succ 0)) then (let e = (if (0 . a) then (let d = true in a) else ((\ a : C . "boy") as (< d : B , d : Bool >))) in ({ a = (unit 1) , b = (case "boy" of < d = d > => "apple" | < a = d > => 1) })) else (if (0 . b) then (inert [ Unit ]) else (fix true)))
(if (pred (case unit of < c = c > => "boy" | < e = e > => 0)) then (pred (true . e)) else (inert [ (({ e : (< e : String , e : Float >) , b : Float }) -> (< b : Unit , a : A >)) ]))
(fix (let e = ((case (a . d) of < c = b > => (fix 1) | < e = b > => ({ c = "apple" , a = 0 })) . a) in (if (a . e) then (iszero (succ true)) else (pred b))))
(succ ({ c = (\ d : String . true) , e = (succ false) }))
({ e = (let d = (succ (succ 0)) in (0 . e)) , a = (< a = (pred "boy") > as ((Nat -> String) -> (B -> Unit))) })
(iszero (if ((< d = true > as Float) . b) then (< e = "apple" > as Float) else (inert [ ({ e : Float , c : String }) ])))
(inert [ ({ b : (Nat -> Unit) , e : (< d : Float , b : A >) }) ])
(if (if (let a = (pred (\ c : String . unit)) in (pred 2)) then (false . e) else (< a = (fix unit) > as ({ e : ({ d : Float , c : B }) , c : ({ c : C , e : B }) }))) then ((< c = 2 > as Bool) (if 1 then false else 2)) else (let d = (pred true) in ({ e = "apple" , a = unit })))
(succ (iszero (succ (pred true))))
(let d = (pred ((fix (< e = false > as Float)) as ({ c : A , a : B }))) in ((iszero "boy") . b))
({ b = (iszero (case false of < b = a > => true | < b = e > => 2)) , b = (inert [ (C -> ({ c : A , a : Unit })) ]) })
(fix (pred (iszero (case unit of < c = d > => false | < c = a > => c))))
((if (if ("apple" "apple") then (0 false) else (2 . a)) then (pred (inert [ A ])) else (pred a)) . a)
(\ c : ((< a : A , a : Unit >) -> (B -> (< e : Float , e : String >))) . ((case b of < d = a > => 2 | < d = b > => unit) . c))
(let d = (let d = (let a = false in (case false of < b = d > => "apple" | < e = d > => false)) in ((true c) as (< d : A , d : Float >))) in (if (if "apple" then 0 else unit) then (< e = b > as Float) else (pred (0 1))))
(fix (case ({ d = ({ c = false , c = "boy" }) , a = (false . e) }) of < d = c > => (case (fix (< d = 1 > as B)) of < b = a > => (< e = unit > as B) | < a = a > => (\ a : Float . (pred unit))) | < b = d > => (case c of < b = e > => (a as C) | < e = b > => true)))
(inert [ (< c : (< d : Nat , c : Nat >) , b : ({ b : B , d : Bool }) >) ])
(pred (inert [ ({ c : (Unit -> Nat) , b : Nat }) ]))
(succ ((({ c = 0 , d = 0 }) ((iszero 1) (let d = 2 in 2))) as (< d : (< c : Unit , b : ({ d : Unit , b : Bool }) >) , b : ({ b : Unit , a : C }) >)))
(let c = (succ (1 as Nat)) in (inert [ ((< c : C , b : Unit >) -> Bool) ]))
(iszero (\ c : (A -> A) . (succ (0 . b))))
((pred (case (\ b : Unit . unit) of < c = b > => (\ b : Unit . unit) | < d = d > => "apple")) as (< d : ({ e : (String -> Nat) , c : Float }) , c : (({ e : (< e : A , b : B >) , b : C }) -> ({ a : Float , e : Nat })) >))
(pred (\ c : ({ e : ({ a : (< e : Bool , b : B >) , d : (< e : C , a : Unit >) }) , e : ({ d : B , d : B }) }) . (iszero (inert [ A ]))))
(inert [ ({ c : (< b : ({ a : Unit , e : Unit }) , d : Unit >) , e : (A -> Float) }) ])
(\ e : (< a : ({ c : (< d : Unit , e : Bool >) , b : (String -> String) }) , a : (({ e : Float , a : Nat }) -> (< d : C , e : (< c : String , b : Bool >) >)) >) . (iszero (inert [ Float ])))
((< a = (inert [ (B -> Unit) ]) > as (Bool -> B)) . e)
(\ e : ({ e : ({ c : Bool , e : Float }) , c : (({ b : Nat , c : (< a : C , e : Float >) }) -> ({ e : Bool , e : (< e : Bool , e : String >) })) }) . ((case b of < a = a > => unit | < a = b > => c) (< b = (pred "apple") > as C)))
(pred (case ({ b = ({ e = 2 , c = false }) , e = (case "apple" of < c = d > => unit | < c = e > => 0) }) of < d = c > => (case (0 "boy") of < d = a > => (fix "apple") | < e = d > => (inert [ Float ])) | < b = b > => (pred "boy")))
((("boy" as B) as (< b : Unit , a : Bool >)) as (< b : (< d : (Bool -> Bool) , e : (< b : (C -> A) , b : (String -> C) >) >) , d : ({ b : (({ c : Float , e : Float }) -> Nat) , b : (B -> Float) }) >))
(< b = (fix (pred (\ d : Nat . 0))) > as (({ a : (Nat -> C) , d : (< d : C , c : Nat >) }) -> (A -> (< a : A , d : C >))))
((< d = ({ b = 1 , d = (case true of < b = a > => "apple" | < c = d > => a) }) > as (< d : A , b : Bool >)) (({ e = unit , d = (let e = b in unit) }) . a))
(let e = (pred (if "boy" then c else 2)) in (((if b then false else b) . b) as ((Float -> String) -> (< b : String , d : A >))))
(if (inert [ (< b : A , c : (C -> String) >) ]) then ((fix (case 2 of < a = b > => false | < a = b > => true)) as ({ c : ({ b : A , d : ({ a : Unit , b : C }) }) , c : (< d : (< b : B , c : C >) , c : Float >) })) else ({ b = (< c = (pred false) > as ({ e : String , a : Float })) , c = (inert [ ({ a : String , b : C }) ]) }))
(((succ unit) . c) . a)
(((< e = 2 > as Float) (inert [ Unit ])) ({ a = (< b = ((pred a) . a) > as (C -> B)) , d = (pred a) }))
(fix (case (("apple" . b) (\ c : B . false)) of < b = a > => (iszero (fix "boy")) | < a = d > => (pred false)))
(case (pred (b . a)) of < a = d > => (let a = (fix (pred ("apple" as A))) in (a as A)) | < b = d > => (iszero ((\ a : Float . 1) . e)))
(iszero (case (< a = (iszero false) > as (Nat -> A)) of < d = b > => (iszero (let a = 2 in 0)) | < a = a > => (inert [ Unit ])))
(pred (fix (fix (\ e : Nat . c))))
(inert [ ({ b : ((Float -> C) -> String) , e : ((< b : ({ c : String , b : Nat }) , a : String >) -> ({ c : A , a : Nat })) }) ])
(< b = (let d = (let c = true in (unit . c)) in (({ e = c , d = a }) . d)) > as ({ d : ({ a : A , e : ({ d : Unit , c : Unit }) }) , e : ({ a : ({ c : A , e : B }) , d : (Unit -> Unit) }) }))
(succ (< a = (if (pred "apple") then (if false then true else 0) else 0) > as (< a : A , b : B >)))
(if (fix (pred a)) then (case (inert [ C ]) of < c = d > => (if (succ b) then (if (pred 2) then true else (b as Float)) else (c . a)) | < d = c > => (let a = (fix 1) in (a as (C -> B)))) else ((if b then unit else 2) (if unit then c else 1)))
({ c = ({ a = (fix (< d = c > as Nat)) , c = (inert [ Nat ]) }) , e = (< b = ((succ b) . b) > as ((Float -> Float) -> (< c : Nat , d : C >))) })
(({ e = (if (case (iszero c) of < e = e > => (\ d : Unit . 1) | < a = a > => 2) then (fix unit) else (if unit then a else 2)) , a = (pred 2) }) . e)
((< a = (({ e = c , d = a }) (let b = false in c)) > as (< d : String , d : B >)) (case (case (let c = false in "apple") of < e = b > => (let b = a in "apple") | < a = e > => (if 2 then ("apple" false) else true)) of < a = a > => (fix (fix b)) | < a = c > => (\ c : (< a : Nat , e : Nat >) . (case false of < b = e > => unit | < d = e > => "boy"))))
(\ c : (({ d : String , c : A }) -> (< c : (Float -> String) , d : Unit >)) . (succ (let d = true in (c b))))
(< c = (iszero (let d = "apple" in 0)) > as (< e : ({ b : B , d : String }) , d : ({ d : A , c : String }) >))
(((pred "boy") . b) as ({ c : (< b : Nat , d : String >) , d : ({ d : Bool , a : ({ c : Float , b : String }) }) }))
(fix ((let c = 0 in 1) (let e = true in "apple")))
((\ d : (C -> Nat) . (inert [ ({ b : Bool , e : Bool }) ])) (fix (unit true)))
(< e = (succ (pred "boy")) > as (({ a : ({ b : B , a : String }) , a : ({ c : A , a : (String -> A) }) }) -> (Unit -> C)))
(\ e : (((Unit -> Float) -> (A -> Nat)) -> ({ b : C , c : String })) . ((pred (let d = (case 0 of < d = d > => b | < b = e > => 0) in 0)) as ({ a : ({ e : Unit , a : Bool }) , e : Nat })))
(fix ((succ (unit (case true of < e = e > => "boy" | < d = b > => "apple"))) . b))
(pred (succ (1 as Float)))
(pred (\ c : (< b : C , e : String >) . (pred false)))
((pred (case "apple" of < d = c > => c | < d = a > => 1)) as ({ e : ({ e : Float , d : (Float -> Unit) }) , e : (< e : (< c : Unit , c : A >) , a : Nat >) }))
(\ c : (({ d : (Unit -> C) , a : String }) -> (A -> C)) . (< c = (false . b) > as (< d : Nat , d : C >)))
(if (case ({ d = (iszero 1) , e = (iszero true) }) of < a = a > => ((< b = "apple" > as Unit) as (Float -> Float)) | < a = d > => (pred (case b of < e = e > => "apple" | < c = a > => 2))) then (let b = (inert [ (C -> A) ]) in (inert [ B ])) else (fix (succ (< b = 0 > as Bool))))
(((iszero (case "boy" of < b = a > => 0 | < d = c > => "boy")) . d) . a)
(let d = ((c as Float) (iszero a)) in (let e = (b . e) in (let c = (\ e : B . false) in (succ false))))
(case (fix (if 2 then (false . d) else (\ a : Unit . "boy"))) of < b = e > => (inert [ ({ e : A , e : Nat }) ]) | < a = b > => (case (2 . a) of < a = d > => ((if c then a else false) (< e = unit > as B)) | < d = a > => ((if a then "boy" else 2) (< c = "boy" > as Nat))))
(inert [ ({ a : (< d : (< d : ({ e : Float , e : Unit }) , c : B >) , c : (Float -> Float) >) , b : (({ d : ({ a : B , b : Unit }) , d : Bool }) -> ({ e : Unit , a : Unit })) }) ])
(\ e : ({ d : (< d : String , c : Nat >) , a : ({ b : ((< e : Unit , a : Nat >) -> B) , e : ({ b : ({ b : Unit , c : C }) , d : (< a : Nat , e : B >) }) }) }) . (("boy" b) as ({ d : Float , a : Bool })))
(pred (fix (succ ({ a = "boy" , a = "apple" }))))
(inert [ (({ b : (< c : Unit , e : Bool >) , d : (B -> Nat) }) -> ({ b : String , a : ({ d : Float , c : Unit }) })) ])
((succ (inert [ Float ])) . b)
(if (({ e = (c as C) , b = (< a = false > as A) }) as (< d : Nat , d : A >)) then (< e = ({ c = (fix 0) , a = (a as A) }) > as ((< c : C , a : String >) -> C)) else ({ c = ((unit as B) (succ "boy")) , e = (("boy" as Nat) (succ c)) }))
(iszero (\ d : ((String -> C) -> String) . (fix ("boy" (\ c : Float . 2)))))
(fix (iszero (pred 0)))
(let d = (inert [ (({ b : B , c : B }) -> (C -> Bool)) ]) in (\ e : (< e : (< e : Bool , d : C >) , b : ({ e : B , a : String }) >) . (pred 1)))
(< c = (fix (inert [ B ])) > as (< d : ({ c : ({ e : Unit , b : Bool }) , e : ({ c : Float , a : Unit }) }) , c : ((< b : Nat , a : C >) -> ({ e : Nat , a : C })) >))
((inert [ ({ d : C , b : C }) ]) . a)
(inert [ (((< e : Unit , b : String >) -> B) -> (C -> Bool)) ])
(succ (if ((case c of < c = c > => "apple" | < b = b > => (b 2)) (b (if c then c else a))) then (case true of < a = e > => (inert [ C ]) | < d = d > => b) else (\ d : B . c)))
(fix (\ d : ((Bool -> Nat) -> Unit) . (pred "apple")))
(({ d = (b . a) , c = (succ (inert [ Bool ])) }) (iszero (("boy" . b) (pred unit))))
(succ (case (fix (if true then 0 else unit)) of < d = e > => (inert [ (< b : C , b : A >) ]) | < c = a > => (iszero (iszero a))))
(fix ((iszero c) . a))
(pred ({ b = ("apple" . c) , a = (pred "boy") }))
(< a = (\ b : (< a : Nat , a : String >) . (pred true)) > as ({ c : (C -> ({ d : Nat , d : C })) , a : ((< e : Nat , e : Nat >) -> Nat) }))
(inert [ ({ d : ((Bool -> C) -> (C -> A)) , b : (< b : ({ c : (String -> Float) , d : B }) , e : (< d : Nat , c : Bool >) >) }) ])
(let d = (< e = (pred "apple") > as (< c : Bool , c : String >)) in (< e = (fix "boy") > as ({ b : Float , d : String })))
(case (\ e : ({ a : (Unit -> A) , a : (< e : Float , c : A >) }) . (if "boy" then 2 else "apple")) of < b = d > => (fix (inert [ String ])) | < b = a > => (< c = ((fix c) . c) > as (({ a : Float , e : A }) -> (Bool -> C))))
(< a = (succ (inert [ (< d : Float , c : Unit >) ])) > as (< c : (< e : C , d : Unit >) , b : ({ d : A , d : Unit }) >))
(< d = ({ e = ((let e = c in true) ((case "boy" of < a = c > => 0 | < e = d > => 1) (inert [ String ]))) , a = (fix (if true then b else 0)) }) > as ((< c : ({ b : C , e : B }) , d : ({ a : C , a : String }) >) -> (< e : ({ a : (Bool -> A) , e : C }) , a : ((Float -> A) -> Nat) >)))
(if (succ (iszero "boy")) then (case (case b of < d = d > => (succ b) | < c = a > => "boy") of < c = d > => (inert [ String ]) | < a = d > => (let a = "apple" in (\ a : B . c))) else ((inert [ Unit ]) . e))
((let e = (let e = "boy" in (pred "apple")) in ((case c of < c = b > => "apple" | < d = b > => "apple") (\ e : Bool . 0))) as (< a : ({ b : (Bool -> String) , c : Unit }) , d : (< a : (< a : Bool , a : A >) , c : (({ e : String , b : String }) -> String) >) >))
(pred (if ((\ d : A . "boy") as Float) then (if true then "boy" else false) else (< b = true > as ({ c : C , a : Float }))))
(< c = (inert [ ({ a : String , a : ({ e : Bool , c : Unit }) }) ]) > as (< a : ((< b : String , a : Unit >) -> ({ c : A , b : Bool })) , b : (< c : A , e : Unit >) >))
({ e = (let c = (succ (0 as B)) in (case (if c then unit else false) of < b = c > => (case 0 of < b = e > => c | < a = b > => (inert [ Float ])) | < b = b > => (pred 0))) , c = (iszero (if unit then 1 else 2)) })
(let a = (succ (iszero unit)) in (inert [ (< c : Unit , e : Unit >) ]))
(((iszero 1) as (Unit -> Unit)) . d)
({ a = (fix (let a = ({ b = 1 , d = 2 }) in (< b = true > as Float))) , a = ({ c = (fix true) , e = (b a) }) })
((let d = (let b = false in "boy") in (case 2 of < c = e > => false | < d = e > => 2)) as ({ a : (Bool -> C) , d : ((< e : B , d : Float >) -> (< b : Nat , e : ({ d : C , e : Float }) >)) }))
((< d = (succ (< a = a > as B)) > as (String -> A)) (pred ("boy" . a)))
(if (case (case "boy" of < c = c > => (let d = 2 in false) | < c = d > => (< c = 0 > as Float)) of < d = d > => (fix 0) | < a = c > => (if false then false else b)) then (\ a : (< e : (Float -> ({ d : Bool , c : C })) , b : ({ e : (B -> String) , e : Float }) >) . (< e = false > as String)) else ((< e = 1 > as (B -> B)) as (< c : (< c : String , b : B >) , d : ({ c : Unit , a : (Nat -> C) }) >)))
(succ (< a = (succ true) > as (< d : A , a : (String -> Float) >)))
((inert [ ({ b : B , d : ({ e : Float , b : B }) }) ]) ((if (b as Bool) then ("apple" as C) else (case true of < a = a > => 2 | < e = a > => "boy")) . e))
(if (inert [ (< d : ({ d : Bool , e : B }) , e : C >) ]) then ((let c = (succ "boy") in (fix "apple")) ((inert [ B ]) (pred true))) else (fix (true (fix unit))))
(\ b : (< c : (Float -> Float) , a : ({ a : ({ b : Bool , c : Unit }) , d : (C -> A) }) >) . ({ a = (unit . b) , e = (pred (pred c)) }))
(fix (let a = (let c = 1 in "apple") in (iszero (iszero 0))))
(< d = (\ d : ({ d : ({ a : Float , a : Nat }) , b : Unit }) . (\ c : Bool . (iszero 1))) > as ({ d : (< b : (< b : (B -> Nat) , a : C >) , e : (< e : ({ a : Nat , e : Bool }) , d : (< a : C , c : C >) >) >) , a : (< b : ({ b : A , b : Bool }) , e : ({ c : Bool , b : C }) >) }))
(case (let d = (< c = b > as (< a : Unit , e : A >)) in (if b then (b b) else false)) of < d = d > => (< c = (case (case 1 of < a = d > => c | < d = a > => 2) of < c = a > => (iszero 0) | < c = b > => (pred b)) > as (< c : (Float -> Nat) , b : B >)) | < c = b > => (if (inert [ (A -> Nat) ]) then (if 0 then b else a) else (if 2 then 2 else false)))
({ c = (if ({ b = c , e = "boy" }) then (pred c) else (inert [ Nat ])) , e = (let c = ({ e = ((unit false) . d) , b = (\ e : ({ e : Nat , c : String }) . (if 0 then unit else 1)) }) in (< a = (pred a) > as ({ a : String , b : Unit }))) })
(< b = ((< b = "apple" > as ({ c : String , c : String })) (fix (a c))) > as ({ c : (< d : String , d : C >) , e : (< b : String , e : A >) }))
((inert [ (< d : ({ c : (B -> Unit) , c : (A -> Nat) }) , b : (< a : String , b : C >) >) ]) as ({ a : ({ e : (Unit -> String) , d : (< d : B , e : B >) }) , b : (< d : B , d : ({ e : A , a : Unit }) >) }))
(\ d : ((< b : ({ a : C , b : (< a : Unit , b : B >) }) , a : ({ c : A , e : B }) >) -> (B -> B)) . (succ ((succ false) "boy")))
(inert [ ((< d : (< c : Unit , a : Unit >) , b : Bool >) -> (B -> (< d : Float , d : A >))) ])
(fix (let d = ((1 1) b) in ("boy" as C)))
(inert [ ({ d : ({ d : Unit , b : (< c : A , b : Nat >) }) , b : ({ c : Unit , b : Bool }) }) ])
(((case ("apple" "apple") of < c = a > => ({ b = "apple" , c = true }) | < e = e > => false) . e) as ((< a : (C -> B) , e : ({ c : Unit , e : (< e : A , e : Unit >) }) >) -> ({ c : Float , c : Float })))
(case (\ c : (< e : Nat , d : Nat >) . (2 . e)) of < b = b > => ((if ("boy" as Bool) then ("apple" unit) else (inert [ Float ])) (succ (a as B))) | < a = a > => (pred (unit . a)))
(\ d : ({ d : ({ d : B , e : A }) , d : ({ b : B , b : Nat }) }) . (\ c : ({ d : Nat , d : (< a : B , e : C >) }) . (succ (\ e : Float . a))))
(fix (fix (\ a : ({ c : Unit , d : A }) . (fix (case c of < b = c > => 0 | < a = d > => unit)))))
(pred ({ b = (2 false) , c = (iszero "boy") }))
((inert [ ({ e : (Bool -> A) , a : (< e : Bool , a : Nat >) }) ]) ({ c = (let c = (inert [ Unit ]) in false) , e = (iszero c) }))
(\ a : (< d : (B -> B) , a : (< a : Bool , a : String >) >) . (fix (succ 2)))
(\ a : ((< c : (Float -> Bool) , c : (< d : Unit , d : Float >) >) -> (({ b : B , a : Bool }) -> ({ b : Float , a : Bool }))) . (let d = ({ d = (if b then (if 0 then 2 else c) else (inert [ C ])) , c = (if true then 1 else b) }) in (< c = 0 > as (< b : Nat , c : String >))))
((iszero ({ b = (unit . b) , e = (case a of < d = a > => (inert [ A ]) | < d = e > => a) })) as (< e : (Unit -> A) , d : (Bool -> Unit) >))
((\ e : ({ d : (A -> Float) , c : ({ d : C , e : C }) }) . (succ (iszero "apple"))) as (< d : ({ a : B , d : C }) , c : ({ b : A , d : Bool }) >))
(fix (pred (pred unit)))
(\ b : (({ b : ({ d : String , a : B }) , d : (< b : Nat , a : C >) }) -> (Unit -> C)) . ((\ d : (< b : Nat , d : Nat >) . b) (succ "apple")))
(\ b : (< c : ((< c : B , d : Unit >) -> (Float -> Unit)) , e : ({ c : (A -> B) , a : C }) >) . ((fix (\ c : (< c : Nat , c : Unit >) . (0 as A))) . b))
(succ (succ (< d = 0 > as Float)))
(if ({ e = (2 . c) , b = (pred "boy") }) then (if ({ e = (let c = unit in c) , d = ("boy" . e) }) then (< e = ({ a = (case false of < e = e > => "boy" | < c = e > => 1) , c = 2 }) > as ({ e : Nat , d : B })) else (iszero ("boy" 2))) else (pred (pred c)))
(succ (fix ("apple" . b)))
(iszero (fix (< a = "boy" > as ({ e : A , d : Nat }))))
((case (({ c = 1 , b = 2 }) (false . c)) of < d = d > => (let c = 0 in 2) | < e = a > => (let d = 0 in (true b))) ((if a then c else (case 2 of < e = d > => 2 | < a = c > => b)) (pred c)))
((let e = (< a = (unit . a) > as (({ a : C , a : String }) -> (< c : String , a : B >))) in ((pred c) as (< c : Nat , a : B >))) as (< b : (String -> ({ a : A , b : A })) , a : (< a : A , c : ({ d : A , e : Nat }) >) >))
(fix ((< b = (if (iszero false) then (< a = a > as A) else (pred b)) > as ((< e : Nat , c : Bool >) -> C)) as ({ b : ({ a : C , e : C }) , b : ({ a : String , b : String }) })))
(pred ((let c = (fix ("boy" as C)) in (iszero true)) . c))
(case ((\ e : ({ c : String , e : String }) . true) . d) of < e = c > => (\ a : (< a : A , d : Nat >) . ((succ "boy") (2 . b))) | < e = c > => ({ a = (({ c = a , a = a }) . d) , e = (let c = (case "boy" of < a = c > => 2 | < a = c > => unit) in 1) }))
(succ ((let b = c in 1) ({ a = ({ d = false , d = 2 }) , c = (fix true) })))
(fix (inert [ (String -> Unit) ]))
(pred (succ (\ a : Unit . unit)))
(\ a : (< a : (Unit -> A) , b : (< c : B , e : Unit >) >) . (< e = (iszero c) > as (Bool -> Bool)))
(if (pred (a as B)) then (let c = (succ false) in (b (case 1 of < e = e > => 1 | < e = c > => a))) else ((\ c : ({ d : String , c : Float }) . ("boy" . b)) as ((B -> A) -> (Nat -> Float))))
(iszero (let c = (pred a) in (let e = true in a)))
(iszero (pred (fix (< e = "boy" > as Bool))))
((pred ((let e = "apple" in true) ("apple" as A))) ({ e = (let d = (fix 1) in (\ b : C . 1)) , c = ((let c = c in true) 0) }))
((succ (if (succ true) then a else false)) . a)
(succ (succ (fix (iszero a))))
(\ a : ((< a : (< c : B , d : Float >) , e : B >) -> ({ c : Nat , a : (< e : Nat , b : Bool >) })) . (\ c : (< d : ({ c : C , c : Float }) , c : (< c : C , b : A >) >) . (({ e = 2 , b = true }) (let c = (2 . a) in 0))))
(pred (\ d : ({ e : C , e : Float }) . (fix unit)))
((< b = (\ b : (Bool -> Nat) . b) > as (< e : String , e : Unit >)) (pred (fix 2)))
(succ ({ d = (fix b) , e = (pred "apple") }))
(succ (let e = ((case true of < a = b > => b | < a = e > => "boy") (case "boy" of < b = c > => 2 | < a = e > => unit)) in (\ c : Float . "apple")))
(inert [ ({ b : (< b : String , a : ({ b : Bool , b : String }) >) , d : ({ c : Float , a : Nat }) }) ])
(iszero ({ d = (\ c : (< d : Nat , b : String >) . 1) , b = (inert [ Nat ]) }))
(< a = (let e = (unit ({ e = true , a = b })) in (< e = 2 > as B)) > as ({ b : (({ a : B , e : Bool }) -> ({ a : A , d : (String -> C) })) , b : (< c : ({ b : C , a : Nat }) , c : (< c : Unit , d : Unit >) >) }))
(case (iszero (succ ({ c = b , a = c }))) of < b = c > => (\ b : (< a : A , b : ({ b : B , c : Float }) >) . (succ 2)) | < e = e > => (iszero (fix (if a then 1 else "apple"))))
((case (pred false) of < c = d > => (1 as B) | < d = a > => (let e = true in "apple")) . a)
((pred ((succ (case c of < b = c > => "apple" | < e = d > => 2)) as (({ a : String , c : B }) -> Unit))) as ({ b : ({ b : ({ c : B , e : C }) , a : ({ b : A , a : Float }) }) , b : (B -> (C -> String)) }))
(fix (inert [ (< c : ({ d : (< b : Bool , c : String >) , c : Float }) , c : ({ c : Bool , a : Nat }) >) ]))
((inert [ (Nat -> Nat) ]) (inert [ ({ b : (({ c : C , c : A }) -> Bool) , a : ({ c : A , b : (< a : String , d : Float >) }) }) ]))
(fix (iszero (< a = "apple" > as String)))
(succ (if (iszero (iszero false)) then ((iszero unit) (\ e : B . (\ e : Unit . "boy"))) else ({ a = (\ c : Nat . unit) , d = (\ a : ({ b : Unit , e : A }) . (fix "boy")) })))
(iszero (iszero ((0 as String) as ({ b : Float , a : C }))))
((iszero (fix a)) (succ ({ c = (iszero c) , b = (pred 1) })))
({ e = (((pred a) as ({ c : Bool , e : B })) (inert [ String ])) , b = (\ c : (A -> A) . (fix c)) })
((iszero (< a = (\ e : (< b : String , e : B >) . (< b = c > as A)) > as (< e : Nat , e : B >))) as (< d : (< b : B , d : C >) , c : ({ b : ({ e : String , c : C }) , c : Bool }) >))
(\ a : (((< a : String , e : Nat >) -> ({ c : Unit , e : A })) -> ({ e : (String -> B) , b : (< d : (< c : Float , b : C >) , c : Float >) })) . (< a = (\ d : Unit . "boy") > as (({ c : Float , b : Unit }) -> (Nat -> String))))
(case (inert [ (< a : Nat , b : Nat >) ]) of < a = a > => (succ (iszero (iszero (inert [ B ])))) | < a = e > => (fix (case (fix c) of < c = d > => false | < c = c > => true)))
(iszero (pred (fix (inert [ Bool ]))))
(inert [ ({ c : (B -> C) , b : (< d : Unit , a : Unit >) }) ])
({ a = ((unit as String) . b) , e = (case (let e = (if 0 then true else "apple") in 0) of < e = a > => (let a = (succ c) in ({ d = true , a = false })) | < c = b > => (fix "apple")) })
(let b = (< b = (\ a : (< d : (< c : C , b : A >) , e : (< c : Float , b : Bool >) >) . (iszero (iszero false))) > as ({ a : ({ d : B , d : Float }) , c : B })) in (succ (pred ({ b = 0 , a = a }))))
(if ((case (if c then 2 else 0) of < d = e > => (case false of < d = a > => false | < d = e > => b) | < d = b > => (a "boy")) . a) then (let c = (let a = a in unit) in ({ b = 0 , e = b })) else (({ b = ((if false then unit else a) . b) , d = (false . e) }) . c))
(if (iszero ({ a = (true . c) , b = unit })) then ((pred unit) as (< d : (Float -> String) , d : Float >)) else (fix ((if unit then c else 1) as ((< b : A , d : Float >) -> Float))))
(fix (iszero (let b = 2 in "apple")))
(fix (pred (if a then (fix true) else 2)))
((succ (0 . a)) as ((Float -> B) -> (Float -> Bool)))
(\ b : (< e : (Float -> (B -> String)) , b : ({ e : ({ e : B , d : Float }) , a : ({ d : Bool , a : Nat }) }) >) . (case (iszero (pred "apple")) of < a = c > => ((0 . b) . c) | < e = e > => (< e = (inert [ Float ]) > as (Float -> (B -> Nat)))))
(let a = (fix ({ d = 1 , c = 2 })) in (\ d : (< a : (String -> Bool) , c : (< c : Nat , c : Bool >) >) . (case (true as Unit) of < b = c > => c | < e = d > => a)))
(((fix (case "apple" of < b = a > => (fix b) | < a = e > => 2)) . a) as (< a : (< b : Unit , d : String >) , d : ({ c : (Float -> C) , e : A }) >))
({ c = (succ ("apple" . e)) , c = (("boy" as ({ d : Unit , a : Unit })) (case (succ 0) of < c = a > => (fix true) | < d = a > => (inert [ C ]))) })
(pred (fix (pred (case unit of < e = a > => 2 | < a = a > => false))))
(< c = (succ ((true as String) . d)) > as (< c : ((String -> Unit) -> ({ b : ({ c : Nat , d : B }) , a : C })) , a : ({ b : (< b : Unit , d : B >) , b : ({ d : B , d : Bool }) }) >))
