\x :Unit. 0
"hello"
\x:A. x
\x:Bool. x
(\x:Bool->Bool. if x false then true else false) (\x:Bool. if x then false else true) 
\x:Nat. succ x
(\x:Nat. succ (succ x)) (succ 0) 
\f:T. \x:Nat. f (f x)
\f:Rec X.A->A. \x:A. f x
{x=true, y=false} 
{x=true, y=false}.x
\x:<a:Bool,b:Bool>. x
\t:Rec P. {get:Nat, inc:Unit->P}.unit
let create = fix (\cr: {x:Nat}->Counter.\s: {x:Nat}. {get = s.x, inc = \t:Unit. cr {x=succ(s.x)}}) in create {x=0}
p.inc unit
p1.get
\p:Counter. p.get
\p:Counter. p.inc
\t:Rec A. Nat -> A.unit
fix (\f: Nat->Hungry.\n:Nat.f)
\f:T->T. (\x:(Rec A.A->T). f (x x)) (\x:(Rec A.A->T). f (x x))
\f:D->D. (\x:(Rec A.A->D). f (x x)) (\x:(Rec A.A->D). f (x x))
\t:Unit. fix_D (\x:D. x)
let x=true in x
unit
<nil=unit> as Rec X. <nil:Unit, cons:{h:Nat,t:X}>
\n:Nat. \l:NatList. <cons={h=n,t=l}> as Rec X. <nil:Unit, cons:{h:Nat,t:X}>
\l:(Rec X. <nil:Unit, cons:{h:Nat,t:X}>). case l of <nil=u> => true | <cons=p> => false
\l:(Rec X. <nil:Unit, cons:{h:Nat,t:X}>). case l of <nil=u> => 0 | <cons=p> => p.h
fix (\p:Nat->Nat->Nat. \m:Nat. \n:Nat. if iszero m then n else succ (p (pred m) n))
fix (\s:NatList->Nat. \l:NatList. if isnil l then 0 else plus (hd l) (s (tl l)))
(< b = (succ (if "apple" then unit else 1)) > as ({ b : ((< b : A , a : B >) -> (Rec A . Nat)) , e : (< e : (Rec B . (A -> C)) , c : ({ b : Bool , e : Nat }) >) }))
(inert [ ({ b : (C -> (Rec A . Unit)) , e : (< b : (Float -> (Rec D . Nat)) , d : (Rec B . Unit) >) }) ])
(case (pred (({ d = "boy" , c = "apple" }) (0 a))) of < c = b > => ((pred true) . d) | < e = b > => (iszero (iszero b)))
((iszero ((let d = "apple" in "apple") as (< d : (B -> String) , d : String >))) . a)
(fix (inert [ ((< c : C , d : B >) -> ({ d : Bool , c : Bool })) ]))
(succ (< a = (if (< d = (case "apple" of < d = b > => a | < e = a > => 2) > as A) then (< c = (pred 1) > as (Rec C . Unit)) else (case true of < e = e > => c | < a = a > => true)) > as (({ c : String , b : (Rec E . String) }) -> (String -> B))))
(case ((fix 0) . c) of < c = b > => (iszero (let a = 0 in true)) | < b = c > => (pred (succ (pred true))))
(< a = ({ e = (if (pred true) then (if 0 then (< c = 2 > as Nat) else "boy") else (fix 1)) , c = (inert [ Bool ]) }) > as ((C -> C) -> (< c : Bool , e : Float >)))
(< a = (fix (unit "apple")) > as (((Rec A . A) -> Float) -> ({ c : Unit , e : Unit })))
(pred (< c = ({ b = (fix "boy") , d = 2 }) > as ((< d : Nat , d : B >) -> Float)))
((< e = (pred "boy") > as (Rec D . Float)) as ((Rec A . (Rec C . Unit)) -> (Rec B . A)))
(inert [ ({ e : (< d : B , d : (C -> Float) >) , d : ({ c : ({ c : Unit , d : C }) , e : (Rec E . Unit) }) }) ])
(let c = ({ e = (pred unit) , d = (inert [ Float ]) }) in (pred (\ d : (< c : String , a : String >) . (case "apple" of < b = a > => true | < d = b > => 1))))
(pred (case ((c as String) a) of < b = e > => (if (inert [ A ]) then (if unit then (case c of < d = a > => true | < c = d > => "apple") else (< d = a > as Float)) else (case "apple" of < b = d > => b | < b = c > => "apple")) | < b = d > => ({ e = (succ c) , e = c })))
({ d = (let a = (fix false) in (case c of < e = e > => (\ c : String . 1) | < b = d > => b)) , d = ({ a = (if (inert [ Bool ]) then (let a = false in false) else c) , d = (let c = (true false) in a) }) })
(fix (pred ((\ d : (Bool -> Bool) . false) as (< e : Nat , e : Nat >))))
((< d = (pred (inert [ Nat ])) > as (< e : Float , c : C >)) as ({ b : ({ d : String , e : Float }) , c : ({ b : A , c : B }) }))
((inert [ (({ d : B , d : Float }) -> ((< e : B , d : String >) -> ({ b : Unit , b : String }))) ]) as ((({ e : Bool , d : Float }) -> (Rec B . C)) -> ({ e : Nat , a : A })))
(let a = ((\ e : (A -> A) . (succ a)) as ({ c : (< c : (B -> String) , c : B >) , d : (({ a : Bool , d : Bool }) -> (Rec C . Float)) })) in ({ e = (\ d : ({ c : String , c : Unit }) . "boy") , d = (< e = true > as Bool) }))
(inert [ ({ b : (Rec D . ({ a : (Rec B . B) , a : (< c : Float , d : Unit >) })) , e : (Rec A . (Rec A . B)) }) ])
(iszero (iszero (let b = (pred 0) in (case true of < a = c > => false | < e = e > => "boy"))))
({ d = (if (pred (< c = "apple" > as C)) then (if "apple" then (case unit of < b = a > => "apple" | < e = c > => a) else (2 unit)) else ({ e = unit , c = true })) , e = ((\ b : Bool . "boy") as ({ b : A , e : A })) })
((\ e : ({ c : (< d : B , b : Float >) , a : (Rec D . B) }) . (iszero 2)) as (Rec D . (Rec D . Bool)))
(inert [ (< a : (Rec C . (Bool -> Unit)) , b : ({ e : ({ a : ({ b : B , d : B }) , c : (< d : Bool , b : C >) }) , c : (Rec A . Unit) }) >) ])
({ d = (iszero (succ (inert [ Unit ]))) , a = (succ (if (fix a) then a else 2)) })
(pred ((((if 0 then c else false) . d) as (String -> B)) . e))
(((succ 0) . c) as ({ d : (< b : String , a : Nat >) , d : ({ c : B , b : C }) }))
(succ (let e = (\ c : (< a : ({ d : A , e : Bool }) , a : B >) . (< b = 0 > as Float)) in (let c = (succ 0) in (succ (if 2 then false else b)))))
(succ ((inert [ Bool ]) as (< b : Float , c : Nat >)))
(if ((succ b) as (C -> (String -> C))) then (< d = (iszero true) > as (String -> Float)) else (succ (succ a)))
(case (iszero (a . c)) of < a = e > => ({ e = (if (if b then true else (c a)) then ((b 2) (pred c)) else (fix 0)) , d = (\ e : (< c : C , d : Float >) . b) }) | < c = d > => (fix (let b = (fix a) in (a . e))))
(\ a : ({ a : (< d : B , c : C >) , a : (Float -> B) }) . (\ d : (Rec E . Bool) . (succ ({ b = c , e = c }))))
(case (iszero (fix 1)) of < a = e > => ((\ e : ({ a : B , d : Nat }) . b) (< a = false > as Float)) | < b = e > => (pred (< b = "apple" > as (< a : String , d : B >))))
(succ (((inert [ Nat ]) (case true of < b = a > => 1 | < e = d > => true)) as ({ e : Unit , c : ({ c : Nat , d : C }) })))
(succ ((inert [ (B -> Float) ]) (pred (inert [ B ]))))
(iszero (succ ((succ c) (inert [ Bool ]))))
(fix (if (fix (fix (\ e : Unit . 0))) then (succ 2) else (succ (case true of < c = d > => 2 | < b = b > => c))))
(succ (if (succ unit) then ("boy" . b) else (case a of < a = e > => b | < e = c > => true)))
(case ((pred false) (unit as String)) of < d = b > => (let e = (iszero "apple") in (pred (if "boy" then "apple" else "apple"))) | < c = a > => (fix (succ 2)))
((pred (succ true)) . b)
(let a = (if (< b = c > as Float) then ((unit . e) . d) else (case true of < d = a > => false | < b = c > => unit)) in ((let e = "boy" in (< b = true > as Unit)) as (A -> A)))
(succ (if (case (fix c) of < d = a > => (let e = (inert [ Bool ]) in (let c = 1 in false)) | < d = d > => (case unit of < c = c > => a | < c = b > => b)) then (succ a) else (pred b)))
((succ (succ 2)) ({ d = (succ (let b = b in 0)) , b = (inert [ (Rec D . Unit) ]) }))
(if (iszero ((iszero a) "apple")) then (\ c : (Rec C . (Rec B . C)) . ((0 . c) . e)) else ((pred (if "boy" then 2 else false)) (case (({ c = 1 , a = "apple" }) (iszero true)) of < b = d > => (pred a) | < a = d > => ("apple" (let d = 1 in b)))))
(\ d : (< c : ((B -> String) -> ({ b : ({ d : Bool , c : Nat }) , b : (Nat -> Bool) })) , d : ({ c : B , b : (Rec A . String) }) >) . ((succ true) . d))
(succ (\ c : (< a : Unit , c : A >) . (let c = c in 0)))
(fix (succ (if (fix true) then true else 0)))
((< d = (if (case a of < d = b > => a | < d = c > => true) then 0 else "boy") > as ((B -> Unit) -> ({ b : String , d : (< c : C , e : A >) }))) (\ b : ({ e : Unit , b : C }) . (< c = (pred 2) > as (Rec E . Bool))))
(inert [ (({ d : (< e : ({ b : C , a : String }) , a : Bool >) , c : ({ d : C , a : (< d : Unit , d : Unit >) }) }) -> (< b : (< a : C , e : C >) , e : (A -> Nat) >)) ])
(iszero (pred (\ e : (Unit -> C) . (unit true))))
({ c = ((iszero 1) (unit false)) , c = (iszero (iszero b)) })
(if (succ ((succ false) as A)) then ({ c = ({ d = (pred c) , d = (\ e : Float . 2) }) , c = (if ("boy" . c) then (\ b : C . 2) else (case true of < d = c > => c | < c = b > => a)) }) else (iszero (inert [ Float ])))
(let a = ({ e = (if (\ a : C . true) then (inert [ Float ]) else (< a = false > as Unit)) , a = ((fix (let a = false in "apple")) (case false of < a = a > => true | < a = e > => "boy")) }) in (pred (\ e : Bool . true)))
(inert [ (< b : (C -> Nat) , a : (A -> Bool) >) ])
(pred (pred (false . a)))
(fix ((\ b : Float . (let e = true in true)) (case a of < d = b > => a | < b = e > => 0)))
(< a = (fix (fix (0 . a))) > as ({ a : (< a : (< c : B , d : Bool >) , c : ((< d : B , a : Float >) -> Unit) >) , b : ({ b : ({ a : Nat , d : Bool }) , d : (Unit -> String) }) }))
((inert [ (Rec A . Float) ]) as ((< c : ({ d : Unit , b : (< a : Nat , b : Bool >) }) , e : (Nat -> C) >) -> ((< c : Unit , c : Float >) -> (< a : C , a : B >))))
(iszero (let b = ({ d = (let e = 0 in true) , e = ({ c = (pred 0) , a = true }) }) in ({ c = c , a = c })))
((let b = (pred "apple") in (\ e : (< b : C , d : B >) . (a 1))) (\ e : (B -> Float) . (pred (fix false))))
(inert [ (Rec D . ((< b : C , e : Bool >) -> Nat)) ])
(inert [ ({ e : (< c : String , c : (Float -> A) >) , d : ({ d : ({ c : String , b : A }) , d : B }) }) ])
(fix (iszero (if (let b = c in "boy") then (succ 2) else ((fix c) (succ c)))))
(pred (iszero (inert [ Nat ])))
(inert [ (< a : (< a : String , c : C >) , b : (Unit -> (< b : String , b : B >)) >) ])
(\ c : (< b : (Rec A . String) , b : (< c : Float , e : ({ d : C , b : Float }) >) >) . ((iszero a) as (Rec D . (C -> B))))
(inert [ (Rec A . (< b : A , d : Nat >)) ])
((fix (succ (2 . c))) as ({ e : ((< d : Bool , d : Bool >) -> (Rec C . A)) , e : (Rec A . C) }))
(fix ((if (inert [ Unit ]) then 1 else "apple") (case 1 of < e = a > => 2 | < e = d > => c)))
((let d = (b 1) in (pred false)) . c)
(inert [ (({ c : Nat , c : B }) -> (< b : String , a : Unit >)) ])
(((succ (("boy" . c) as (A -> Nat))) . d) . b)
(succ (case (fix (fix 2)) of < a = b > => (pred unit) | < a = a > => (case true of < b = c > => (0 as A) | < c = b > => unit)))
(({ c = (\ d : (< e : A , c : String >) . (2 as String)) , b = ((let a = unit in true) (succ b)) }) as (< a : ({ e : (< e : Nat , a : B >) , d : (Rec E . Unit) }) , d : ({ d : (Rec C . A) , b : (Rec A . String) }) >))
(case (succ (case (\ c : C . true) of < d = a > => "boy" | < e = b > => unit)) of < c = c > => ((true a) as ({ e : A , a : A })) | < c = e > => ((b true) (b . c)))
(succ (let b = (let a = c in ("boy" 1)) in (pred (let e = (inert [ Nat ]) in (iszero unit)))))
(case (if (< b = "apple" > as ({ c : C , b : C })) then ({ d = (if true then "boy" else c) , c = (iszero "apple") }) else (pred "apple")) of < b = d > => ((pred (fix 0)) as (Rec D . (Unit -> Unit))) | < e = c > => ({ a = (if 2 then true else b) , d = (case a of < a = a > => unit | < b = d > => (fix "boy")) }))
(let e = ({ a = (< c = 0 > as A) , e = ("boy" as Bool) }) in (succ (let a = a in "boy")))
(inert [ ((< b : Float , b : Bool >) -> (B -> (Rec D . A))) ])
(inert [ (< a : ({ d : (C -> Unit) , e : B }) , a : ({ c : (Rec C . Unit) , a : (< d : Nat , e : Nat >) }) >) ])
(if (fix (pred 1)) then (case (pred "apple") of < b = d > => (succ (true b)) | < c = d > => (pred (case unit of < a = d > => 0 | < d = d > => "boy"))) else (let d = (let a = unit in b) in (< e = a > as ({ c : String , e : Nat }))))
(succ ({ d = (< b = 0 > as (< b : String , a : B >)) , a = (\ e : (Rec D . Float) . (if 0 then 2 else 2)) }))
(inert [ ({ a : ((< d : Bool , c : String >) -> ({ b : String , b : String })) , a : ({ a : ({ a : Nat , e : Float }) , a : (< d : Nat , e : (Rec A . Float) >) }) }) ])
((case ({ a = "boy" , b = 2 }) of < b = d > => (\ b : String . (pred c)) | < b = d > => (case (fix "boy") of < e = e > => a | < a = d > => (false . d))) (inert [ ((< b : (< a : B , c : Float >) , e : ({ d : Float , d : Float }) >) -> (< a : Unit , d : (Rec B . A) >)) ]))
(case (case (a 2) of < e = a > => (1 . c) | < b = b > => (inert [ Unit ])) of < b = d > => ({ c = (pred "apple") , b = (({ d = "apple" , b = 2 }) (iszero (< a = a > as Bool))) }) | < b = b > => (\ d : (< c : B , b : Nat >) . (b a)))
(fix (fix ((inert [ Float ]) . a)))
(pred (\ b : ({ c : Unit , b : Unit }) . (inert [ Float ])))
({ c = (inert [ (((Rec E . Nat) -> Unit) -> ({ a : Float , d : Unit })) ]) , d = (case (< e = "apple" > as (< d : B , a : String >)) of < e = b > => (case (case "apple" of < d = b > => a | < d = b > => a) of < e = a > => (let b = "boy" in "apple") | < a = d > => 2) | < d = b > => ((pred (if unit then false else 1)) . b)) })
(succ (iszero (< a = "boy" > as A)))
((((iszero c) . a) as (< a : ({ d : (Rec D . C) , e : ({ d : Float , b : B }) }) , d : ({ b : C , d : Nat }) >)) ((inert [ Bool ]) . e))
(case ((fix false) . a) of < a = b > => (< d = (let e = 1 in true) > as (< e : Bool , d : C >)) | < c = d > => (\ e : (< e : B , d : B >) . (if a then 1 else "boy")))
(if ((if (case "boy" of < a = a > => true | < b = d > => 1) then (case (let b = "apple" in c) of < e = e > => (case "apple" of < e = c > => 2 | < a = e > => c) | < e = e > => (let d = false in a)) else (2 as C)) ((\ a : ({ a : A , e : B }) . true) as (Bool -> A))) then ((if "apple" then (0 . b) else (c as Nat)) as (< e : Nat , b : String >)) else (< c = ((\ b : Unit . "boy") 1) > as ({ a : Float , d : B })))
(if (< b = (0 . c) > as ((< d : C , a : Bool >) -> (< b : C , e : C >))) then (succ ((if b then b else unit) . b)) else (let b = ({ a = false , a = c }) in (\ d : String . c)))
(\ b : (< b : (Rec A . (Rec E . Bool)) , b : ({ d : (Rec C . C) , a : ({ e : (Rec C . C) , d : B }) }) >) . (succ (fix (case 1 of < e = a > => 1 | < a = a > => b))))
(inert [ (Rec E . (Rec D . (< c : B , b : Unit >))) ])
(iszero ((succ unit) (iszero "boy")))
(\ b : (({ c : (Float -> String) , d : Bool }) -> ((Float -> C) -> (< e : C , e : String >))) . (succ (if "apple" then true else 1)))
(let a = (succ (inert [ String ])) in (iszero (\ d : (Rec B . Float) . (0 as A))))
(iszero ((succ unit) . d))
(iszero (case (fix 2) of < b = b > => (inert [ (< e : String , d : B >) ]) | < e = d > => (if 1 then c else (succ 0))))
({ e = (inert [ ({ e : Float , d : B }) ]) , d = ((\ d : (Bool -> Bool) . (iszero 0)) . c) })
(succ ((let a = (succ true) in (\ e : B . c)) . e))
(if (iszero (if (unit 0) then (if unit then "boy" else b) else "apple")) then (case ((case a of < b = d > => b | < e = e > => 1) as A) of < e = a > => (succ (inert [ Unit ])) | < d = d > => (fix b)) else (inert [ ({ e : B , c : (C -> A) }) ]))
({ a = ((iszero (inert [ B ])) ({ e = (a as Nat) , c = (\ d : C . (if 0 then 2 else b)) })) , d = (if (pred "boy") then (case unit of < a = c > => 1 | < d = c > => 0) else ("boy" unit)) })
(< c = (pred (2 . b)) > as ({ a : (B -> (String -> Unit)) , d : (C -> Nat) }))
(let b = (if ({ d = (fix unit) , e = (1 as Float) }) then (< d = "apple" > as (Nat -> B)) else ((\ c : (Rec D . Bool) . (1 as B)) . c)) in (let c = (< b = ({ d = "boy" , a = "apple" }) > as C) in (fix (iszero 1))))
({ a = (let a = (if c then unit else false) in (< a = 2 > as Nat)) , c = (iszero (fix (let e = 1 in "apple"))) })
(succ (fix (\ d : ({ a : Unit , d : B }) . (iszero unit))))
(pred ((if false then "apple" else true) (let e = b in ("apple" . b))))
(pred (succ (inert [ (Rec E . String) ])))
(pred ((fix (fix b)) (iszero (\ b : Nat . b))))
(let c = (((if unit then 2 else "apple") . d) (succ (succ b))) in (\ a : (Rec D . (Rec A . B)) . (let e = (pred ("boy" as Float)) in (case "boy" of < c = d > => a | < b = d > => true))))
(case (({ c = "apple" , d = unit }) as (Rec A . String)) of < e = d > => (if (pred (case false of < b = c > => 2 | < b = b > => false)) then (pred (fix ({ b = "boy" , c = c }))) else (\ d : (Rec A . Float) . ((pred false) as String))) | < e = a > => (\ a : (({ b : String , d : Nat }) -> A) . (< d = (succ "boy") > as Unit)))
(case (< e = (inert [ A ]) > as ({ e : B , b : Float })) of < e = d > => (inert [ (< d : Bool , c : Float >) ]) | < b = a > => (fix ((let a = "boy" in "boy") as (Bool -> Unit))))
((iszero (true as (Rec D . Float))) as (< c : (B -> Bool) , d : (Rec C . Unit) >))
((\ b : ({ b : Nat , d : Nat }) . (if 0 then (succ c) else (inert [ String ]))) as ({ e : (Rec B . String) , c : ({ c : (< a : Nat , e : (Rec D . Bool) >) , b : (Rec E . (Bool -> String)) }) }))
(case (succ ({ c = 2 , a = true })) of < c = a > => (fix (< b = (let c = true in false) > as (Rec C . Float))) | < e = b > => (\ a : ((Unit -> Nat) -> (Rec D . (< a : A , e : C >))) . (case true of < c = c > => (if a then false else 0) | < e = c > => (pred b))))
(((succ (\ e : Unit . a)) as ({ a : Bool , c : C })) . c)
(fix (fix ((case "apple" of < c = d > => 1 | < b = b > => 1) as ({ a : C , c : String }))))
(case ((2 . e) as ({ b : Bool , c : C })) of < c = a > => ((let a = 0 in (\ c : B . 0)) . c) | < a = b > => (let a = (pred "apple") in (inert [ B ])))
((iszero (let b = (inert [ String ]) in (case c of < b = b > => true | < a = d > => 0))) ({ d = (inert [ A ]) , e = (c as C) }))
(\ c : (Rec A . ({ d : (B -> B) , a : (Rec A . Nat) })) . ({ d = (pred (2 . e)) , c = (inert [ String ]) }))
(case ((succ 0) as (String -> Float)) of < e = c > => (inert [ (< d : (String -> Float) , c : Nat >) ]) | < e = c > => (case (\ a : ({ d : String , b : Nat }) . (case unit of < d = d > => "apple" | < b = a > => unit)) of < a = c > => (pred (fix "boy")) | < a = d > => ({ a = (case c of < d = c > => "apple" | < e = e > => 2) , c = (1 as Nat) })))
({ d = (let b = (if 1 then 2 else unit) in (let b = unit in (iszero "apple"))) , a = ((iszero (iszero c)) as ((< a : Bool , d : Unit >) -> (< b : Nat , c : (Float -> Nat) >))) })
(((\ c : C . a) . d) (if (pred (let a = 2 in a)) then ({ c = a , e = (iszero unit) }) else (\ e : String . "apple")))
(iszero (pred (false as (Rec E . C))))
({ a = (({ a = true , c = 1 }) as (String -> Float)) , d = (inert [ (Rec C . Float) ]) })
(pred ({ e = ("apple" . e) , e = ((succ unit) as (Rec E . Bool)) }))
(((iszero ({ b = "apple" , a = true })) as ({ d : (< c : String , d : B >) , b : Bool })) as (< e : (Rec C . (Rec C . A)) , c : ((Rec A . C) -> Bool) >))
((\ d : (< d : (Rec D . Bool) , e : (Rec B . Unit) >) . (< c = c > as (< c : Float , e : Float >))) . c)
(({ a = (succ b) , c = (iszero unit) }) as (Rec E . ((< a : Float , a : Bool >) -> ({ c : ({ d : String , d : Unit }) , a : (Nat -> Nat) }))))
({ c = ((if (if 2 then 0 else false) then (case "apple" of < a = a > => true | < d = b > => unit) else (\ a : Bool . 1)) (< c = (pred "boy") > as String)) , d = (case (< a = "boy" > as C) of < a = a > => (b . e) | < c = a > => (case false of < e = a > => 1 | < a = e > => 1)) })
((if (case (\ c : Unit . false) of < c = d > => (if "boy" then b else b) | < a = b > => c) then (< a = (pred ({ e = a , a = 1 })) > as (< a : Unit , d : String >)) else (\ c : ({ c : Nat , e : Float }) . c)) as (Rec D . (Rec B . Bool)))
(iszero (let c = (inert [ (Rec D . String) ]) in (pred (succ 2))))
(pred (< c = (if a then b else a) > as (Rec C . (< d : Bool , d : Bool >))))
(\ a : (< a : (Rec D . B) , c : (Bool -> String) >) . (pred (< d = a > as (< c : String , a : Nat >))))
((inert [ ({ b : ((Rec A . Nat) -> (Nat -> B)) , a : (< b : B , a : C >) }) ]) as ((< c : (Rec E . String) , b : ({ e : B , d : C }) >) -> (Rec B . (Nat -> String))))
(\ d : ({ d : ({ c : C , e : (< a : C , d : A >) }) , c : ({ b : (String -> C) , c : (Rec B . B) }) }) . (pred (fix ((< d = "boy" > as String) . a))))
(pred (if (c 1) then (case 2 of < a = b > => ({ a = "boy" , a = 1 }) | < e = a > => (inert [ Float ])) else (let b = (if true then unit else "apple") in 0)))
(succ (pred ({ e = "apple" , e = 1 })))
(inert [ ({ b : (< e : (Rec D . A) , a : (Rec E . Unit) >) , b : ((C -> C) -> (Rec C . String)) }) ])
((if (if (false "apple") then (\ e : String . "boy") else (if false then a else c)) then (pred (< c = unit > as A)) else (pred (false . c))) . d)
(succ (pred ((succ (let a = unit in b)) (fix b))))
(((< a = (case b of < e = d > => (succ "apple") | < b = a > => c) > as ({ d : Bool , e : String })) . e) . b)
(inert [ (< b : (Rec D . (< a : A , c : Float >)) , a : ({ e : C , c : Nat }) >) ])
(iszero (let a = (1 as B) in (b as A)))
(succ ((inert [ B ]) . c))
({ c = ((case 1 of < a = a > => unit | < b = e > => true) . d) , b = (< d = (< e = "boy" > as String) > as (Rec A . ({ b : String , d : Float }))) })
(succ ((< a = "apple" > as Nat) (1 . d)))
(< a = (fix (b . a)) > as (({ b : Float , b : (< e : B , b : A >) }) -> (Rec D . Bool)))
(case (\ a : (Rec A . (Float -> Float)) . (inert [ (C -> String) ])) of < d = d > => (fix (iszero "apple")) | < e = d > => ({ e = (case ({ b = "apple" , b = 2 }) of < b = d > => (if 2 then 2 else (1 as Float)) | < d = b > => (let c = 0 in (case a of < c = b > => false | < e = d > => unit))) , d = (unit (pred unit)) }))
(< c = ((pred (unit 2)) as (Rec E . (< c : Nat , a : String >))) > as (Rec E . (Bool -> B)))
(inert [ (< b : (String -> String) , e : (< b : String , d : Unit >) >) ])
((iszero (< c = (let d = 0 in false) > as (< e : B , a : Unit >))) as ((({ e : Unit , c : Bool }) -> ({ b : Bool , a : A })) -> (Rec A . (Rec B . Nat))))
(pred (\ c : ({ e : (Rec B . A) , a : ({ c : B , c : String }) }) . (succ true)))
((if ({ c = (if "boy" then unit else true) , a = (let c = (case false of < a = e > => false | < c = b > => false) in (fix 0)) }) then (succ 2) else (iszero (let c = a in 0))) ((iszero (pred unit)) (succ ({ c = "boy" , e = c }))))
(let b = (inert [ ({ c : (C -> Bool) , b : ({ e : String , d : Unit }) }) ]) in (\ e : (< e : ({ d : String , a : Nat }) , a : Bool >) . (< a = "apple" > as (< a : Float , b : Nat >))))
(let d = (fix (pred (succ b))) in ((< c = (succ "boy") > as ({ c : Unit , d : Nat })) as (({ d : Bool , c : Nat }) -> (String -> String))))
(case (succ (inert [ (String -> Bool) ])) of < a = e > => ((if 2 then "apple" else b) (2 as String)) | < a = e > => ({ d = (fix (false as Bool)) , e = (let b = (0 . d) in (< b = "boy" > as Nat)) }))
((case (fix 2) of < d = e > => (if b then false else 2) | < b = b > => (let e = b in b)) . d)
(\ e : ((< a : (< b : Float , a : A >) , d : Bool >) -> ((Rec C . Bool) -> (Rec E . C))) . (((inert [ Bool ]) . d) . d))
((< a = (pred false) > as (Rec B . (Rec C . C))) (fix (\ c : (< a : ({ b : A , e : Nat }) , d : A >) . (case (inert [ A ]) of < a = c > => false | < d = a > => 2))))
(let a = (succ ({ d = (case a of < e = d > => b | < d = e > => "boy") , a = true })) in (iszero ((inert [ Float ]) ({ e = b , e = (succ 0) }))))
(\ a : (< c : (< e : (< d : B , c : (Unit -> Nat) >) , b : (< b : C , d : C >) >) , b : (< e : (< d : A , b : A >) , d : (B -> (< b : Unit , c : Bool >)) >) >) . (let b = (inert [ (Nat -> A) ]) in (pred false)))
({ b = (succ (\ a : ((< d : Nat , d : Float >) -> C) . (\ a : A . false))) , e = (let e = ((fix b) . d) in (iszero 1)) })
(pred (pred ((\ d : Bool . "boy") as A)))
(iszero ((0 . b) . b))
({ d = (succ (({ b = b , d = 2 }) as Unit)) , d = (succ (\ e : Float . false)) })
(< a = (if (({ d = (\ a : Float . true) , e = (let c = 1 in 2) }) as (< d : (Rec A . B) , b : (A -> Bool) >)) then (case (c as B) of < b = e > => (< d = false > as Unit) | < b = e > => (< e = "apple" > as Float)) else (if (inert [ A ]) then (false as A) else (let d = c in (\ e : Nat . true)))) > as (< d : ({ b : (Rec D . B) , d : B }) , c : (Rec B . (< e : A , a : String >)) >))
(\ c : ({ c : ({ c : Nat , b : C }) , c : (({ d : String , e : Unit }) -> Bool) }) . (< a = (let b = "boy" in true) > as ({ c : Nat , c : A })))
(if (< d = (case (0 as String) of < e = e > => ((iszero "apple") . b) | < b = e > => ({ c = true , c = "boy" })) > as (< e : ({ b : B , d : Float }) , c : (Float -> Float) >)) then (\ b : (< d : ({ b : B , d : String }) , a : (< e : String , b : ({ d : Nat , d : A }) >) >) . (inert [ String ])) else (< e = ((inert [ Nat ]) . e) > as ({ c : Float , d : Unit })))
(case (fix (succ "apple")) of < b = d > => (let a = (succ a) in ("apple" . b)) | < b = d > => ((a c) (iszero unit)))
(fix ((fix (fix b)) . e))
(\ d : (< e : (Rec A . ({ e : Unit , b : Bool })) , a : (Rec C . (String -> A)) >) . (((let c = unit in "apple") unit) . c))
(iszero (\ a : (< a : Bool , b : A >) . (pred (\ a : C . unit))))
(iszero (succ (\ a : Bool . "boy")))
(case (< e = (succ (1 a)) > as (Rec B . (A -> Unit))) of < e = e > => (< c = (let e = true in false) > as (< e : B , a : Unit >)) | < d = e > => (fix (iszero (unit b))))
((< e = (let a = unit in (case 0 of < a = e > => true | < b = a > => true)) > as (< d : (< c : A , c : String >) , b : ({ b : Unit , b : Unit }) >)) as (< d : (Rec D . Nat) , c : (< b : A , a : Nat >) >))
(fix (pred (inert [ (Rec E . Bool) ])))
((succ ({ a = (case "apple" of < e = c > => unit | < c = c > => a) , e = (case c of < e = c > => "apple" | < a = c > => "apple") })) . a)
(succ (iszero (let e = "apple" in unit)))
(\ e : ({ b : (Rec D . A) , a : (< a : String , d : C >) }) . (inert [ (Rec C . (Nat -> Nat)) ]))
(if (pred (inert [ Unit ])) then (< c = (fix (if false then a else "apple")) > as (({ c : ({ b : B , d : C }) , b : Bool }) -> (Bool -> Bool))) else (< a = (pred (inert [ A ])) > as (< d : (< c : B , e : Bool >) , d : ({ e : Nat , c : String }) >)))
(succ (pred (< b = (fix ("apple" . a)) > as (Rec B . Nat))))
(inert [ ((String -> Bool) -> (Rec D . C)) ])
(let d = (pred (case b of < b = b > => 0 | < e = e > => true)) in ((let e = (inert [ Float ]) in true) (pred "apple")))
(fix ({ a = (inert [ String ]) , d = (pred "boy") }))
(fix ({ a = ((0 as Nat) (false as Unit)) , c = (< b = (case c of < a = b > => true | < a = e > => b) > as ({ e : Unit , b : Unit })) }))
(\ a : (Rec C . (< a : (< b : (Rec E . A) , c : ({ c : B , e : Bool }) >) , e : (Unit -> Nat) >)) . (pred (if false then true else b)))
(if (succ ((2 . b) (case unit of < e = e > => c | < d = b > => 1))) then (if (case unit of < a = d > => "boy" | < b = d > => false) then (0 ("apple" b)) else (inert [ Float ])) else (inert [ ({ e : (Rec E . B) , e : (Rec B . Nat) }) ]))
(({ e = (case a of < d = e > => 0 | < c = d > => 2) , c = (pred false) }) as ((< e : B , e : (Nat -> B) >) -> (Nat -> Float)))
(iszero ((iszero ({ b = c , e = (case 1 of < c = e > => a | < a = c > => false) })) ({ c = (let e = b in a) , d = unit })))
({ b = ((case "boy" of < e = a > => b | < d = d > => false) . a) , c = ({ e = (case ("apple" . e) of < d = d > => (let d = 2 in true) | < d = d > => ({ c = true , d = b })) , b = (pred b) }) })
(succ (succ (inert [ (Rec B . ({ e : String , a : String })) ])))
((\ d : (< c : Nat , a : Bool >) . (if (succ a) then false else (fix b))) . a)
(fix (let a = (if b then 2 else b) in (inert [ (< e : Nat , a : String >) ])))
(succ ({ c = (pred b) , c = (case (let c = a in "boy") of < d = c > => (case 0 of < c = a > => a | < c = e > => c) | < c = c > => (case true of < a = a > => 1 | < e = d > => a)) }))
(let e = ((unit . d) ("apple" true)) in (succ (pred (pred 1))))
(pred (succ (0 2)))
(fix (succ (if (\ e : String . 2) then (\ b : Nat . (a as Float)) else (0 as A))))
(succ (pred (\ a : ({ b : Float , b : (B -> Float) }) . (succ true))))
((({ c = (succ unit) , a = (< c = "boy" > as Nat) }) as (Rec C . ((< c : String , a : Nat >) -> Float))) as (({ e : Nat , a : B }) -> ({ d : B , b : String })))
(pred (if (if "boy" then false else false) then (succ "apple") else (iszero "boy")))
(inert [ (Rec E . (Rec A . ({ b : String , c : (< a : C , a : C >) }))) ])
(inert [ (Rec D . ({ c : Unit , c : B })) ])
((let e = ((let e = (inert [ Bool ]) in (2 as String)) as (< a : A , c : C >)) in (case a of < a = b > => (b 0) | < c = a > => "boy")) (fix (false as Unit)))
(({ b = (\ b : (Rec B . Unit) . true) , a = (pred (fix b)) }) . b)
(iszero (succ (iszero 1)))
((< b = (succ a) > as (Unit -> Bool)) as ((Rec B . C) -> (B -> (Rec B . Bool))))
({ d = (fix (if a then 1 else 0)) , a = ({ b = (1 c) , c = (unit . a) }) })
(case (inert [ (({ c : Nat , d : C }) -> Float) ]) of < a = b > => (\ b : (Rec B . (C -> B)) . (succ true)) | < c = c > => (((pred 2) as C) as (< e : String , c : (A -> Bool) >)))
(< e = (\ c : (Rec A . (Nat -> Bool)) . ({ a = (iszero false) , a = (case "boy" of < d = a > => true | < e = e > => a) })) > as (< a : (B -> Nat) , c : ((Rec A . C) -> (Rec E . Float)) >))
((let d = ((b . a) as (< a : Nat , b : A >)) in (1 as C)) as ({ d : (< c : B , c : (< b : B , b : B >) >) , a : (< e : ({ d : (< d : Bool , c : Bool >) , e : (Rec E . Float) }) , b : ({ c : Bool , d : (< d : Nat , d : B >) }) >) }))
({ d = ((< a = true > as Float) . e) , c = (< b = (iszero c) > as (Rec B . Float)) })
(succ (< c = (inert [ Bool ]) > as (Rec A . Bool)))
(case (pred (true as Float)) of < e = b > => (if (a (succ 0)) then (if unit then (if b then 0 else "apple") else (fix a)) else (succ (fix true))) | < c = a > => ({ a = (pred (0 as Float)) , e = (if c then 2 else unit) }))
(inert [ ({ c : ({ d : Unit , c : (Rec B . Bool) }) , e : ({ e : (Float -> Nat) , b : A }) }) ])
(let d = ((1 unit) . d) in (if (succ (pred true)) then (< d = c > as (String -> C)) else (({ e = (iszero true) , e = false }) as (< b : C , e : Bool >))))
((((iszero b) as A) (< a = false > as (Rec A . Float))) (< d = (if true then ({ e = 1 , a = 2 }) else 1) > as (B -> (Rec E . B))))
(iszero (let a = (succ c) in (< b = (if ("boy" a) then (< c = 1 > as C) else ({ b = 2 , c = "apple" })) > as (< d : C , a : C >))))
(inert [ (Rec A . ({ c : Unit , d : Float })) ])
(iszero (if (if 1 then 0 else b) then (let e = (pred b) in (case 0 of < e = c > => 1 | < d = b > => "apple")) else (if (fix c) then "apple" else (pred b))))
(let a = ({ c = ((let b = true in ({ a = c , b = b })) as ({ a : C , b : B })) , a = (if (2 2) then "apple" else "boy") }) in ((((case true of < c = e > => 2 | < e = e > => unit) false) ((if 1 then b else "apple") as (Rec E . String))) . b))
(let e = ((succ ((iszero 2) (case false of < b = c > => 0 | < d = d > => a))) ({ d = (c . a) , a = (\ e : Float . false) })) in ((succ (< a = 2 > as Bool)) . a))
((< b = (pred ({ d = 2 , e = a })) > as (< d : (< c : Unit , e : Nat >) , e : (Float -> A) >)) as (Rec A . (< c : (A -> Nat) , c : (Rec A . ({ e : Float , a : String })) >)))
((if (inert [ ({ c : String , c : C }) ]) then (iszero b) else (let e = (if "apple" then unit else true) in (< a = "apple" > as A))) . c)
(iszero (if (case unit of < e = e > => unit | < b = e > => (inert [ Float ])) then ({ e = (false unit) , c = (case 0 of < d = c > => 1 | < d = b > => unit) }) else (\ c : A . (unit as String))))
(inert [ ((< c : (Rec B . String) , b : (Rec C . A) >) -> (Unit -> (C -> C))) ])
(inert [ (Rec E . ((Rec E . Float) -> Nat)) ])
(pred (\ c : ({ a : A , b : Float }) . (succ true)))
(\ b : ({ a : (Unit -> Float) , d : ({ b : Nat , e : Bool }) }) . (((let b = "apple" in a) as (< b : A , b : C >)) . c))
(if (< b = (c as A) > as (Rec A . (Unit -> A))) then (((iszero 2) . c) . a) else (\ b : (Unit -> Float) . (pred c)))
(case ((let a = (inert [ Bool ]) in (let c = 0 in true)) . d) of < c = c > => (iszero (\ a : (Bool -> (Bool -> C)) . ({ d = b , c = "apple" }))) | < d = e > => (let c = ((succ 0) as (< c : B , d : String >)) in (a as (< b : Unit , d : Nat >))))
(< d = ((succ 1) . e) > as (Rec B . (B -> Bool)))
(< b = (pred (\ d : (< d : Float , d : C >) . (let e = "apple" in 2))) > as (({ b : (Rec B . C) , d : (Float -> Float) }) -> ({ c : A , e : Float })))
(succ (inert [ ({ b : Float , b : B }) ]))
(succ (succ (inert [ Float ])))
({ b = (if (({ d = (b . c) , e = 0 }) as (C -> Unit)) then ((< e = 1 > as Unit) . a) else (if (unit . e) then (pred (< b = 2 > as C)) else (< e = a > as Unit))) , b = (if (inert [ C ]) then (iszero (\ d : Float . true)) else (iszero (unit 2))) })
(pred (pred (if true then "apple" else false)))
({ c = (({ d = 1 , b = 0 }) as (Rec A . Float)) , b = ({ e = (if (\ e : String . "apple") then (\ b : A . 0) else ((iszero false) . e)) , b = (fix (inert [ Nat ])) }) })
({ e = (pred (let c = c in (inert [ Nat ]))) , a = (\ b : ((A -> Bool) -> (String -> Nat)) . (fix true)) })
(iszero (succ ({ d = (< a = (0 1) > as C) , e = (fix a) })))
((fix (< c = (fix "boy") > as (< d : Nat , a : Nat >))) (succ (succ 2)))
(pred ((if (pred unit) then false else "boy") (unit "boy")))
(iszero (succ (inert [ A ])))
((let d = (if c then (a as Bool) else (pred 1)) in ((let b = (pred b) in false) . a)) (case (let a = (iszero 1) in (< e = "boy" > as Float)) of < e = c > => ((\ e : C . "apple") (if a then 1 else c)) | < d = c > => (inert [ Nat ])))
(\ b : (< c : (< b : B , c : String >) , e : (Unit -> Unit) >) . ((if c then false else b) . a))
(pred (({ b = "boy" , c = unit }) . b))
(pred (succ (succ false)))
({ b = (\ e : ({ c : (Bool -> Unit) , c : (Rec D . B) }) . ((< a = true > as Bool) as String)) , e = (case ((iszero "boy") 0) of < a = a > => (c . a) | < b = c > => ({ d = a , a = unit })) })
(succ (let d = (inert [ String ]) in ((iszero false) . a)))
(if (succ (< e = unit > as Unit)) then (succ (let c = (succ false) in (("apple" as Nat) (case 0 of < c = b > => a | < e = b > => false)))) else (< c = ({ c = (let b = b in true) , e = (inert [ Float ]) }) > as (Rec E . (< b : Unit , c : Float >))))
(inert [ (Rec B . (Nat -> Float)) ])
(\ c : (Rec D . (Rec A . (B -> Bool))) . (if (case ((2 . c) as A) of < a = d > => (1 . e) | < b = b > => (if c then true else false)) then (pred (succ 1)) else ((if c then (iszero c) else "apple") as (< b : A , e : C >))))
(inert [ ({ c : (< c : (Rec C . C) , e : (({ e : Nat , b : Bool }) -> (Rec E . C)) >) , e : (< c : (Rec D . C) , e : (< c : A , c : A >) >) }) ])
(({ b = (fix (let a = false in a)) , b = (let a = ("apple" . c) in (< a = ("boy" false) > as (String -> Bool))) }) as ({ c : (Rec C . ({ e : B , e : Unit })) , e : (Rec B . A) }))
((pred (let d = (pred unit) in 0)) . c)
(let d = ((\ b : C . false) (false . a)) in ({ a = (inert [ C ]) , c = (pred (2 . e)) }))
(\ a : ({ c : (Rec E . B) , e : (< d : A , c : C >) }) . (inert [ (Bool -> A) ]))
((iszero (iszero a)) as ({ d : (B -> Bool) , a : (< e : (< d : Unit , b : C >) , e : ({ b : A , c : B }) >) }))
(pred (if (iszero ((fix false) c)) then ((if (pred b) then c else (2 . c)) as (Rec B . (Rec E . A))) else (\ d : (Rec C . C) . 0)))
(inert [ (< a : ({ c : A , d : A }) , c : (< a : C , a : B >) >) ])
(let d = (iszero (((\ e : Unit . "boy") as String) as ({ e : (C -> A) , c : C }))) in (case (\ c : C . true) of < d = a > => (let b = a in 1) | < e = d > => ((< c = unit > as String) (pred "boy"))))
(((\ e : C . b) as ((< d : Nat , e : B >) -> (Bool -> (Rec B . String)))) . c)
(< e = (< e = (\ e : (B -> (Bool -> Float)) . (< c = b > as B)) > as (Rec D . Unit)) > as ((String -> Unit) -> (< b : ({ b : A , d : B }) , b : ({ e : Float , c : A }) >)))
(< c = ((0 as Float) as ({ e : Nat , b : Nat })) > as ({ e : ({ b : (Nat -> A) , c : (Rec B . Nat) }) , c : ({ d : Nat , d : (Rec C . Float) }) }))
(pred (< b = ({ e = (let a = (inert [ Float ]) in (inert [ String ])) , e = (succ (let d = false in true)) }) > as (< d : String , c : Unit >)))
(iszero (< b = (succ true) > as (Rec A . C)))
(succ (iszero (let e = 0 in ({ e = b , c = "boy" }))))
(iszero (fix (< d = (false . c) > as (C -> B))))
(case ((succ ((false false) as Bool)) as ({ c : ({ e : Unit , c : Bool }) , d : Unit })) of < b = a > => (\ b : (({ d : B , e : Float }) -> (Rec B . (Rec A . String))) . ((a . c) as ({ c : String , a : C }))) | < d = b > => (pred (if a then b else 2)))
(({ d = ({ c = "apple" , b = unit }) , b = (true as Nat) }) as ({ b : (Rec B . String) , e : (Rec E . (Rec B . Nat)) }))
(if (fix (c . c)) then (iszero (let b = b in unit)) else ({ d = (pred ({ e = ({ d = 1 , a = c }) , b = ("boy" a) })) , d = (succ c) }))
(succ ((fix c) . b))
(if (inert [ (Rec E . (Unit -> Float)) ]) then ({ c = (\ e : (< d : String , b : Unit >) . (c as B)) , e = (case ("boy" b) of < d = e > => (let a = 0 in a) | < a = c > => ({ a = (iszero false) , a = (succ unit) })) }) else (((case "apple" of < b = b > => "boy" | < c = a > => a) b) as ({ e : Float , d : C })))
(\ d : ((Rec A . (String -> B)) -> (< c : Nat , a : A >)) . (iszero ((succ (inert [ Unit ])) (iszero ({ b = a , e = false })))))
(\ e : (Rec A . (Float -> (Rec C . B))) . (inert [ (< d : String , e : C >) ]))
(pred ((2 . c) . c))
((inert [ (Rec E . ({ e : B , a : String })) ]) . b)
(let b = (succ (< e = c > as ({ b : String , c : Unit }))) in ((pred (a true)) as (Rec C . (String -> A))))
((pred ({ e = 2 , a = false })) as (Rec D . (Bool -> Bool)))
(let c = ((case (b a) of < a = a > => (pred b) | < e = e > => (inert [ String ])) . d) in (inert [ (< c : Bool , c : String >) ]))
((pred (case "apple" of < c = b > => b | < a = e > => false)) . a)
(if (let b = (\ a : (< a : String , b : Float >) . (inert [ ({ a : B , b : C }) ])) in (iszero (iszero 2))) then (fix (if c then (let d = b in true) else (b . e))) else (let c = (iszero (pred b)) in (pred false)))
(if ((inert [ (< e : Unit , d : B >) ]) . a) then ((succ b) . d) else ((fix c) as (< b : (Float -> Float) , b : (Unit -> A) >)))
({ c = ({ e = (\ e : (Rec A . A) . (\ b : B . 0)) , e = ("apple" true) }) , b = (iszero (1 . e)) })
(let c = ((c as Nat) ({ c = 2 , e = b })) in (inert [ (< d : String , e : String >) ]))
(if (let c = (let e = (c . a) in 0) in (fix a)) then (succ (let b = (a . d) in 0)) else (iszero (if 2 then "boy" else (let e = c in c))))
(pred (let e = (case (case true of < e = d > => true | < a = a > => unit) of < b = d > => a | < a = a > => a) in (succ (iszero 2))))
(if (inert [ (Bool -> A) ]) then (< d = (< c = false > as (< c : A , a : Nat >)) > as (< d : (< d : A , b : A >) , e : C >)) else (inert [ (Rec B . (C -> C)) ]))
(((succ (inert [ String ])) as ({ e : Float , d : Unit })) . b)
(fix (< e = (pred (fix ("apple" . e))) > as (Rec D . ({ b : Float , e : C }))))
((pred (iszero (let b = "boy" in 2))) as ((< d : Unit , b : String >) -> (Rec A . (< e : A , d : C >))))
(let b = (succ (2 . a)) in (if ((0 . a) (case 2 of < c = d > => (c as Float) | < b = e > => ({ b = 1 , c = 0 }))) then ({ a = "apple" , d = (iszero 2) }) else (fix (\ c : (Float -> Unit) . (case "boy" of < a = d > => c | < d = c > => b)))))
(((fix (false . b)) as (Rec D . (Rec E . (C -> A)))) (case (\ a : Float . unit) of < b = b > => (let a = 2 in unit) | < b = e > => (a . e)))
((succ (succ (if 0 then unit else (pred 1)))) . a)
(\ e : (Rec C . (({ d : A , b : (Float -> B) }) -> (< b : Float , c : Unit >))) . (pred (case ("boy" . c) of < d = c > => unit | < a = e > => (case true of < d = e > => true | < d = b > => 0))))
(iszero (if (inert [ C ]) then (iszero b) else (fix false)))
(< a = ((a . d) . b) > as ((Rec C . Float) -> (< b : Nat , c : Nat >)))
((pred (\ b : (< b : Nat , d : A >) . ({ b = b , a = unit }))) . a)
(fix (case (iszero (iszero (\ d : C . 1))) of < e = e > => (let c = (iszero (< c = true > as Unit)) in ({ a = "apple" , a = "boy" })) | < a = d > => (pred c)))
(< c = ((case (inert [ (Rec A . String) ]) of < b = d > => (let e = 1 in 0) | < d = c > => (\ b : ({ d : Nat , b : Bool }) . (case false of < b = d > => true | < c = e > => unit))) (case ({ e = true , d = a }) of < c = e > => ({ c = true , a = unit }) | < d = d > => (iszero 1))) > as ((< d : (Float -> String) , a : (C -> C) >) -> (A -> Bool)))
(let e = (if (iszero 1) then (case 2 of < b = c > => c | < a = b > => (iszero false)) else (< c = 0 > as Nat)) in (pred (a "apple")))
(succ (iszero (case a of < a = d > => 2 | < c = e > => (pred true))))
(fix (fix (fix (case true of < c = b > => "apple" | < a = e > => (iszero 0)))))
(iszero (pred (< d = 2 > as Float)))
(case ((pred false) . c) of < c = b > => ((iszero a) . b) | < a = a > => (iszero (inert [ Unit ])))
(iszero (< b = ((inert [ B ]) as ({ c : B , d : Bool })) > as (< c : Float , e : Bool >)))
(if (succ ((unit true) . e)) then (succ (pred 2)) else ((pred (fix c)) . a))
(\ e : ((Rec C . String) -> (Nat -> (Unit -> Nat))) . (pred (fix (succ 2))))
({ e = ((\ a : A . (inert [ Bool ])) . a) , d = ((case (if unit then c else 0) of < d = d > => (let c = true in "apple") | < e = b > => (inert [ String ])) (inert [ (< d : (Unit -> C) , c : Bool >) ])) })
(case (case (< e = unit > as A) of < a = b > => (\ b : ({ d : Float , e : B }) . (fix (pred false))) | < b = e > => ((if true then unit else "boy") . b)) of < a = a > => (fix (\ e : ({ d : A , a : Float }) . 2)) | < e = e > => (iszero ({ c = (1 as C) , b = 0 })))
(inert [ (Rec D . (String -> Bool)) ])
(\ a : ({ a : (< a : ({ d : Nat , b : A }) , b : ({ b : (Rec D . C) , b : (C -> Float) }) >) , e : ({ c : (Rec B . String) , c : (< e : B , e : (< d : Bool , c : Float >) >) }) }) . ((false b) as (< a : (< c : String , a : Nat >) , c : C >)))
(let b = (inert [ ({ e : (Rec B . B) , e : (< e : Nat , e : String >) }) ]) in (let c = (inert [ Bool ]) in (succ (iszero ({ c = "boy" , d = "boy" })))))
((\ a : ((Unit -> Float) -> (< a : C , a : Float >)) . (iszero ({ b = 0 , c = 2 }))) as ({ d : ({ e : String , c : (< b : Nat , d : A >) }) , d : (Rec B . ({ a : Float , e : String })) }))
(let a = ((\ e : (< b : (< a : B , c : Unit >) , a : Float >) . (< d = 2 > as String)) . c) in (fix (inert [ (< e : Unit , c : Unit >) ])))
(case (inert [ ({ c : (Rec A . Nat) , b : (Rec D . ({ b : Bool , e : Float })) }) ]) of < a = e > => ({ d = (iszero ("apple" . d)) , c = (2 . c) }) | < e = b > => (pred (let d = b in 0)))
(iszero (((iszero "apple") . e) . b))
(fix (case (if (iszero a) then ({ d = "apple" , e = c }) else (succ c)) of < c = d > => ({ e = ({ a = 2 , b = c }) , b = c }) | < b = a > => ((pred 2) 0)))
((if ({ c = ({ d = false , e = 0 }) , d = (succ 0) }) then (let e = false in 0) else (fix (case 1 of < c = d > => unit | < e = d > => true))) (succ (false as String)))
(case (pred (if (iszero b) then 2 else (< b = 1 > as Bool))) of < c = a > => (let b = (succ ({ a = 1 , c = true })) in (succ (let b = (< e = b > as String) in (if "apple" then 1 else b)))) | < e = a > => (case ({ b = ("apple" 0) , e = (case b of < a = e > => true | < b = e > => b) }) of < e = c > => (iszero c) | < e = c > => (if (case (< a = "apple" > as String) of < d = e > => (let a = b in "apple") | < e = d > => 2) then (if (< d = 1 > as Bool) then 1 else (\ c : Unit . 1)) else (1 as Unit))))
(succ (pred (< d = ("apple" . c) > as (< a : (B -> Float) , a : C >))))
(((succ unit) as (C -> String)) as ((< b : A , d : B >) -> (Unit -> Nat)))
((succ (1 . e)) (((fix 0) . a) . a))
(((case b of < a = a > => (case 0 of < c = c > => "apple" | < a = d > => c) | < e = a > => (iszero c)) (\ d : Float . (< c = "apple" > as String))) as ((< c : (Unit -> Float) , d : (< b : Bool , d : A >) >) -> ((Unit -> A) -> ({ d : B , d : Nat }))))
((let c = (0 . e) in (if 0 then "apple" else a)) (succ (< d = (let a = unit in true) > as (< c : Float , a : Unit >))))
(\ b : ((< e : (< e : Unit , a : String >) , e : B >) -> ((C -> Unit) -> (Rec D . Unit))) . (let b = (\ d : (Rec C . Unit) . (false . a)) in (succ (if true then 2 else c))))
(\ e : (Rec B . (Rec D . ({ b : A , d : (Rec D . B) }))) . (\ a : (< b : (Rec C . Unit) , c : Nat >) . (fix "boy")))
(case (fix (case 1 of < a = d > => c | < c = d > => "boy")) of < d = d > => ({ a = (\ a : (< e : Float , e : B >) . "apple") , e = ((2 as A) . e) }) | < d = e > => ((1 false) (< a = a > as B)))
(< d = (inert [ (Unit -> ({ d : Unit , b : Bool })) ]) > as (Rec B . (Rec E . Unit)))
((iszero (iszero (pred b))) . a)
(let d = ((< d = (false a) > as ({ c : Nat , b : Float })) . d) in ((if (b . a) then b else "boy") . b))
((succ (case a of < b = d > => "boy" | < d = c > => "apple")) . d)
((case ("apple" . a) of < d = c > => (\ d : B . 1) | < a = a > => ({ c = (true 0) , e = (pred 2) })) . e)
(iszero (succ ({ d = 0 , d = a })))
(fix (inert [ (({ d : Bool , b : Nat }) -> Bool) ]))
(((let d = (unit 0) in a) (case c of < a = e > => c | < e = e > => 2)) ((let b = 2 in a) as ((Rec D . Float) -> Bool)))
((fix ((case c of < e = e > => 0 | < a = d > => c) . c)) (pred (succ (\ c : Unit . 1))))
(\ d : ({ a : (< e : B , e : A >) , c : (< b : String , a : ({ d : String , a : Float }) >) }) . (if (< d = (let d = b in b) > as (({ e : String , d : Nat }) -> Unit)) then (fix (fix unit)) else ((succ 1) (iszero "boy"))))
(< c = (if (inert [ (String -> B) ]) then (inert [ String ]) else (< b = 2 > as C)) > as (Rec A . ({ c : ({ c : Float , e : Unit }) , c : (Rec D . C) })))
((if (\ c : (Bool -> B) . (< b = c > as ({ a : B , d : B }))) then (pred (fix true)) else (case (\ b : B . 1) of < a = d > => (case 0 of < d = e > => false | < e = b > => b) | < d = d > => (\ b : (Rec B . A) . (case "boy" of < b = e > => b | < c = a > => a)))) as (Rec B . (< e : Float , a : B >)))
(\ a : (< b : ((Rec A . Bool) -> ({ b : C , d : Unit })) , e : ((< d : (Rec D . String) , c : (< d : String , a : C >) >) -> (< d : C , c : Unit >)) >) . (pred (< c = (unit true) > as (Rec C . (A -> Bool)))))
((inert [ (< a : ({ c : A , b : Unit }) , e : Bool >) ]) (succ (pred (succ "apple"))))
((pred (iszero 2)) as (Rec C . ((< c : String , e : Unit >) -> (Rec B . String))))
(< b = ((fix false) as (Rec D . ({ d : Float , b : A }))) > as (Rec C . (< a : (Rec A . (B -> Float)) , e : (Unit -> Unit) >)))
(((inert [ (< d : (B -> String) , c : (< a : Bool , d : Nat >) >) ]) (case (< d = 1 > as Unit) of < a = c > => (pred "apple") | < e = d > => false)) . b)
({ c = (case (case (b true) of < a = b > => (pred unit) | < e = c > => (case 0 of < a = b > => 1 | < a = a > => false)) of < a = c > => (pred (fix 2)) | < b = a > => (case true of < b = c > => (< b = unit > as A) | < c = e > => (inert [ C ]))) , e = (< a = (c as (Rec C . Bool)) > as ((Rec A . Unit) -> Float)) })
((case (if "apple" then a else false) of < d = a > => (inert [ ({ d : Bool , c : C }) ]) | < c = b > => (pred 2)) (pred ("apple" "apple")))
(pred (case (b . e) of < d = c > => (let d = "boy" in (let d = c in b)) | < a = a > => (fix true)))
(case ((false (pred unit)) (succ b)) of < a = c > => (inert [ ((Rec A . (< e : B , d : C >)) -> (< b : Nat , e : C >)) ]) | < e = b > => (case ({ a = 1 , d = b }) of < b = c > => ((inert [ String ]) true) | < e = b > => (2 . e)))
(pred (iszero (\ b : String . true)))
({ d = ({ c = (1 as Float) , a = (1 as C) }) , c = (succ (fix "apple")) })
(\ d : (Rec C . ({ d : C , e : B })) . (\ e : (Rec B . (< e : A , b : B >)) . (iszero (if false then 2 else (true unit)))))
(iszero (succ (succ (if true then 0 else 1))))
(if (if (let b = unit in c) then (inert [ (Nat -> Unit) ]) else (({ b = "apple" , b = a }) . a)) then ((succ false) (((\ d : String . false) . b) as (Float -> Float))) else ({ e = ("apple" false) , b = ((unit unit) . a) }))
((inert [ ({ d : (Rec E . A) , a : C }) ]) as (< e : ({ c : (B -> B) , c : (C -> Bool) }) , c : (Rec C . ({ b : Nat , a : String })) >))
(case (case (iszero (\ c : Unit . unit)) of < e = b > => (\ e : Nat . (< e = b > as Nat)) | < b = a > => ({ e = (iszero "boy") , c = 1 })) of < d = a > => (inert [ (Rec B . (< c : A , e : (Rec B . Nat) >)) ]) | < d = a > => (succ (fix 1)))
(< e = ((< e = "boy" > as B) . e) > as (({ d : Nat , b : (Rec A . B) }) -> (Rec D . Unit)))
(let e = (succ (if 0 then 1 else false)) in (< d = (c as Nat) > as (Rec E . B)))
(fix ((b 2) (succ (let d = true in b))))
(\ a : (Rec A . (< b : (Float -> Unit) , a : (< d : Nat , a : Unit >) >)) . (iszero ("boy" . a)))
(pred ((let b = a in 0) (inert [ (Rec A . B) ])))
(< b = ({ b = (let c = (case c of < b = c > => b | < c = b > => c) in (c . e)) , b = ({ a = 2 , b = "apple" }) }) > as ((C -> B) -> (< c : (< e : C , e : A >) , e : ({ d : Nat , c : A }) >)))
(iszero (< b = (let c = true in 0) > as (Rec B . B)))
(succ (< b = (if (unit as Nat) then 1 else (fix "apple")) > as ((Rec C . A) -> C)))
(inert [ ((< b : Float , c : Unit >) -> (Rec A . (< d : Bool , c : Float >))) ])
(succ (iszero (case (pred false) of < c = c > => (2 . d) | < c = e > => (let e = c in c))))
(let a = (inert [ ((Bool -> (< c : A , e : Float >)) -> ({ d : (< c : String , e : B >) , a : Bool })) ]) in ({ c = (fix (case a of < a = c > => 1 | < c = d > => 0)) , e = (case (iszero 0) of < e = a > => (succ true) | < e = d > => (if a then (\ d : Unit . a) else 0)) }))
(iszero (let c = ("boy" . d) in (let c = a in b)))
(inert [ (((B -> Unit) -> (< e : B , a : Float >)) -> ((Rec C . ({ a : String , b : Float })) -> (< c : B , a : String >))) ])
(inert [ (Rec C . ({ d : (Rec A . A) , c : ({ e : B , d : Bool }) })) ])
(succ (let e = (fix a) in (iszero "boy")))
(\ c : (Rec D . (< a : A , e : String >)) . ((a . a) . a))
(inert [ (Rec C . (< b : A , d : A >)) ])
(pred (let c = ({ c = 0 , d = "boy" }) in (if "apple" then false else unit)))
(case (let e = ((iszero false) (inert [ C ])) in (b as Nat)) of < b = c > => (\ e : (< e : A , e : Bool >) . (succ 2)) | < a = e > => ({ d = (inert [ B ]) , a = (case (let e = c in b) of < b = c > => ({ a = b , c = c }) | < d = d > => "apple") }))
(iszero ((fix false) . c))
(if (\ c : (< d : (Rec E . ({ a : Bool , d : String })) , b : ({ a : C , c : A }) >) . (succ (if ("apple" as C) then false else 0))) then (succ (\ a : ({ b : Bool , b : (Rec C . B) }) . (unit . c))) else (iszero (if ("apple" b) then ({ a = false , a = false }) else ({ a = false , e = 2 }))))
(if (if (< c = 1 > as (< c : Bool , d : Float >)) then ((inert [ C ]) "boy") else (let d = (pred c) in (pred false))) then (case (b as (A -> A)) of < d = e > => (inert [ Nat ]) | < e = d > => ({ a = (inert [ Bool ]) , d = (succ unit) })) else (succ (inert [ (Rec A . Unit) ])))
(case (pred (succ (iszero 0))) of < e = d > => (pred (case b of < a = d > => (unit as Unit) | < a = a > => false)) | < e = d > => (\ c : ((< e : (Rec B . C) , a : ({ a : String , e : Float }) >) -> (C -> String)) . (({ e = "apple" , d = true }) "apple")))
(fix (if (< c = (inert [ (< b : A , d : Float >) ]) > as (Rec A . Unit)) then ({ a = false , b = (\ d : B . a) }) else ((fix false) as (< e : C , c : B >))))
({ e = (\ e : (< a : Unit , c : Float >) . (if c then true else false)) , b = ((({ c = "boy" , c = (\ b : String . "boy") }) (let d = b in b)) . b) })
(succ (if (succ (let e = 1 in (< c = 1 > as Float))) then (let e = (case true of < c = d > => true | < b = a > => 1) in (case "apple" of < a = d > => (unit as Nat) | < e = a > => (inert [ B ]))) else ((succ c) (if (succ unit) then c else 0))))
((inert [ (< d : String , c : Nat >) ]) . d)
(inert [ (< a : (Rec D . ({ d : ({ d : C , c : Nat }) , a : (Nat -> Bool) })) , c : (< c : (< a : (Nat -> Nat) , d : B >) , b : (< c : A , d : B >) >) >) ])
(\ b : (Rec D . ({ d : (< a : Nat , c : A >) , d : A })) . (inert [ ((A -> Unit) -> A) ]))
(iszero (iszero (fix (1 . d))))
(iszero (< e = (let e = unit in (iszero 2)) > as (< c : Nat , b : String >)))
(({ b = (unit b) , e = (case false of < c = c > => 1 | < e = a > => a) }) as ({ c : (< c : ({ b : Unit , e : String }) , e : ({ e : C , b : Unit }) >) , c : (Rec D . ({ a : Bool , e : (Rec D . C) })) }))
(iszero (pred ("boy" . b)))
({ d = (< b = (inert [ Float ]) > as (({ a : (< a : C , a : Bool >) , c : A }) -> (Rec C . String))) , d = ({ d = (\ d : A . false) , e = (succ (let a = 1 in 2)) }) })
((succ (< b = false > as (B -> Bool))) . a)
({ d = (succ (fix 1)) , a = (inert [ (Rec A . (< e : Bool , a : B >)) ]) })
(< c = (inert [ (Rec A . Float) ]) > as (Rec D . (< c : Nat , a : ({ d : A , c : Float }) >)))
(if (pred (succ 1)) then (fix (unit as (Rec C . C))) else (pred (case 0 of < b = a > => 2 | < a = c > => b)))
(((pred 0) . e) ({ b = (inert [ (B -> Bool) ]) , c = (let e = (\ d : Float . c) in (let d = unit in "boy")) }))
(< c = (inert [ ({ b : B , c : ({ e : Unit , e : Nat }) }) ]) > as ((String -> Unit) -> (C -> Unit)))
({ d = (case (if (case b of < e = c > => 0 | < c = b > => 1) then (if unit then "apple" else c) else (pred unit)) of < b = d > => (iszero 2) | < e = a > => ((case 1 of < c = d > => b | < c = e > => c) . d)) , e = (let d = (case "apple" of < c = c > => 1 | < b = b > => (case 0 of < b = c > => c | < e = e > => 0)) in (succ (pred 1))) })
((pred (unit . e)) . b)
({ e = (\ b : (< c : A , b : Bool >) . (< b = a > as Unit)) , d = (succ (c as Nat)) })
(if ((fix "boy") ({ e = true , a = "boy" })) then (< b = (pred (iszero b)) > as (Rec E . ({ e : Nat , c : Unit }))) else (succ (inert [ (Rec A . Unit) ])))
(let a = (< e = ((2 . d) as ({ e : Unit , d : Float })) > as (Nat -> Float)) in (fix ((inert [ Bool ]) (0 . d))))
((inert [ (({ c : C , d : A }) -> (< d : Bool , c : Unit >)) ]) (< a = (case false of < d = e > => (pred false) | < d = e > => (c . e)) > as (Rec B . Bool)))
(((\ c : (Nat -> C) . (a . c)) ({ a = 0 , b = (fix "boy") })) (fix (inert [ (Rec A . C) ])))
(< d = (fix (case unit of < d = a > => 1 | < b = a > => 0)) > as ((Unit -> (< e : Bool , a : Unit >)) -> (Unit -> String)))
(pred ((case ("apple" . c) of < a = e > => (pred c) | < b = c > => a) as ({ e : Unit , b : Unit })))
(pred ((iszero (fix 0)) as ((String -> (A -> Nat)) -> ((< c : String , a : B >) -> (Rec C . A)))))
(let a = (case (let d = 1 in (if 2 then 1 else c)) of < c = b > => ({ e = false , c = (if b then unit else true) }) | < e = e > => (succ false)) in (iszero ((iszero true) ({ b = a , b = b }))))
(succ ((succ (unit as Bool)) (iszero (case 0 of < d = b > => "boy" | < a = b > => unit))))
((({ a = "apple" , d = "apple" }) as (< c : B , d : String >)) as ((Float -> C) -> ((Nat -> B) -> ({ a : A , e : A }))))
(fix (case (succ "boy") of < e = a > => (let c = "apple" in false) | < b = a > => ((< b = 0 > as String) as ({ d : A , a : A }))))
(fix (pred (pred 0)))
(if (succ (pred 1)) then ((case (fix (1 as Bool)) of < e = e > => ({ d = "apple" , b = a }) | < d = a > => (\ e : Unit . false)) (("apple" 1) as ({ d : B , e : ({ a : Float , a : Unit }) }))) else (let d = (a (1 . c)) in (succ c)))
(pred (pred (fix true)))
((iszero ("apple" . c)) as ((< a : A , e : Bool >) -> (< c : Bool , c : ({ a : Bool , d : Unit }) >)))
(inert [ ((Nat -> (< a : B , b : Nat >)) -> (Nat -> Bool)) ])
({ b = (inert [ (({ b : Bool , c : String }) -> C) ]) , b = ((if (< d = false > as B) then ({ a = false , c = (succ 1) }) else (inert [ String ])) as ({ d : ({ a : String , c : Float }) , d : (< b : C , e : B >) })) })
(if (case (iszero (2 . e)) of < d = c > => ({ c = "apple" , b = 1 }) | < c = d > => (iszero 1)) then (case (fix 1) of < a = d > => (inert [ (< e : B , a : A >) ]) | < c = b > => (case false of < c = d > => 0 | < d = b > => b)) else (iszero (pred "apple")))
(({ b = (c "boy") , b = (pred 2) }) as ((Rec D . String) -> ({ e : Float , c : A })))
((< c = (< e = (case ({ d = false , c = b }) of < e = b > => (iszero unit) | < a = c > => true) > as (< c : Unit , b : Float >)) > as (Rec E . C)) ((case b of < c = c > => true | < c = a > => a) as (Rec C . C)))
(fix (succ ({ a = (pred "apple") , e = "apple" })))
(< a = ((pred 0) ((inert [ ({ e : Nat , e : Bool }) ]) (fix a))) > as ((Rec C . A) -> (< c : (Rec A . Bool) , a : ({ d : Unit , d : C }) >)))
(if ((pred (inert [ Float ])) (case (inert [ String ]) of < b = a > => "apple" | < e = c > => (pred "boy"))) then (succ (inert [ (B -> Nat) ])) else ((inert [ ({ b : A , d : Unit }) ]) (\ a : ({ d : (Rec C . Float) , c : C }) . (case true of < e = e > => (fix 1) | < e = e > => 0))))
(pred ((case "boy" of < c = e > => "boy" | < e = b > => unit) . d))
(inert [ ({ e : (< e : (< b : Bool , e : String >) , d : (Bool -> String) >) , b : (Rec B . Bool) }) ])
(inert [ ({ b : (< c : B , c : (Float -> String) >) , e : (Rec B . (< b : Bool , b : Unit >)) }) ])
(if (pred (let b = "boy" in (pred "apple"))) then ((b as B) (if 0 then unit else unit)) else (pred (0 as String)))
(let d = ((< d = (iszero unit) > as A) . b) in (let c = (let b = (iszero a) in (succ c)) in (case 0 of < b = e > => (let e = true in c) | < a = c > => 2)))
(if (\ c : ({ d : ({ a : Nat , d : C }) , d : (C -> Float) }) . (iszero 0)) then (\ a : ({ b : B , b : String }) . (fix (iszero 0))) else (({ e = (let e = a in 2) , a = true }) (< c = (if c then 0 else false) > as ({ d : A , d : String }))))
(let c = (if ((if c then 1 else "boy") . c) then (case (iszero 0) of < d = d > => ({ e = true , c = (if true then "boy" else 2) }) | < b = b > => (case (case a of < a = c > => false | < b = c > => "boy") of < d = c > => (fix 1) | < d = a > => ({ e = a , c = a }))) else (if (iszero false) then (\ d : (Nat -> String) . 0) else (1 "boy"))) in (iszero ({ b = (a . d) , e = "apple" })))
(inert [ ((< a : B , e : String >) -> (Rec B . String)) ])
(pred (case (fix 1) of < a = a > => (fix "boy") | < a = b > => (let a = (case c of < b = a > => "boy" | < b = c > => a) in (inert [ A ]))))
(fix (iszero ((fix 1) . e)))
((iszero (\ c : (Rec E . B) . (case ({ d = "boy" , b = 0 }) of < c = b > => 2 | < d = a > => (succ "apple")))) as (Rec B . (Rec C . ({ d : Nat , e : C }))))
(iszero (\ e : (< c : C , b : (Float -> Float) >) . (< b = ({ d = "boy" , b = unit }) > as C)))
((case ({ e = 1 , b = (inert [ Bool ]) }) of < d = d > => ((let e = 1 in c) "apple") | < e = d > => (fix (fix c))) (let a = (fix false) in (if 0 then true else (< b = false > as Bool))))
(iszero (case (fix false) of < c = d > => (if 2 then true else 0) | < e = a > => (< b = 2 > as Float)))
(iszero (case (fix (\ a : (Nat -> String) . (1 . d))) of < e = c > => ({ c = (inert [ Nat ]) , d = (inert [ Unit ]) }) | < d = a > => ("apple" as (Float -> B))))
(\ b : (< c : ({ c : Float , d : Bool }) , c : (Unit -> A) >) . (iszero (fix "apple")))
((\ a : ({ d : String , e : Nat }) . (iszero (pred c))) . e)
({ a = (inert [ (Rec A . Float) ]) , e = ((iszero (case (if 1 then true else "apple") of < e = d > => ("apple" "apple") | < a = c > => 2)) (let c = (iszero b) in (if false then (inert [ Float ]) else (pred c)))) })
(succ (({ d = 1 , e = c }) as (Rec B . Float)))
(iszero ((succ "boy") . c))
(if (< c = (fix (case false of < c = e > => 2 | < d = d > => false)) > as (< b : (< d : C , b : Float >) , d : (< a : (< b : String , c : Bool >) , d : Unit >) >)) then ({ b = (\ b : (Float -> String) . true) , d = (inert [ (< d : B , b : C >) ]) }) else (\ d : (Rec C . ({ b : Bool , a : Bool })) . (let c = (case b of < c = e > => 2 | < d = d > => unit) in unit)))
(let b = (succ (iszero c)) in (if (\ d : (C -> Nat) . c) then (case c of < c = c > => true | < b = e > => "boy") else (\ e : Float . "apple")))
(if (let d = (let c = a in (fix c)) in (< b = true > as Bool)) then ({ a = ({ c = (let e = 0 in 1) , d = (case (\ e : B . b) of < c = d > => (iszero a) | < a = a > => b) }) , c = (inert [ (< e : A , a : String >) ]) }) else ((let d = (let a = 1 in 2) in (fix unit)) . a))
(succ (case ((succ false) as (Rec A . Unit)) of < a = e > => (\ c : Unit . (inert [ Unit ])) | < b = b > => (< a = (\ a : ({ b : Unit , c : Nat }) . a) > as ((< a : Unit , b : A >) -> C))))
(if ((\ a : A . unit) (pred (case unit of < a = c > => 0 | < e = b > => 1))) then (inert [ ((String -> Float) -> (Rec A . Float)) ]) else (\ b : ({ e : (< a : C , a : A >) , a : (< c : Nat , b : ({ c : A , b : Bool }) >) }) . (let c = (< d = "boy" > as Unit) in (pred unit))))
(fix (case ((let d = "apple" in 1) as B) of < c = e > => (succ true) | < a = a > => ({ d = 0 , c = (inert [ C ]) })))
(inert [ (< c : (Rec B . Unit) , b : (Nat -> C) >) ])
((fix (succ b)) . b)
(let e = (\ d : (Rec D . (Rec A . ({ b : Bool , a : String }))) . (b . d)) in (fix (let a = b in "boy")))
(pred ((inert [ Float ]) . e))
(fix ({ b = (inert [ A ]) , a = (\ d : (A -> (A -> A)) . (\ a : Unit . 1)) }))
(succ ({ a = ({ a = (a . d) , d = (case unit of < a = b > => (iszero unit) | < a = b > => (pred 1)) }) , c = (succ (inert [ A ])) }))
(pred (succ (succ (if "apple" then true else (\ c : B . c)))))
(case (({ a = ("apple" as (Rec E . Float)) , c = ({ e = (case "apple" of < a = d > => 1 | < d = b > => 0) , a = (inert [ A ]) }) }) as (< b : ({ c : Bool , e : A }) , c : Float >)) of < d = e > => (\ e : ({ a : (< a : ({ b : String , c : B }) , d : (Rec B . Unit) >) , b : ((Unit -> Float) -> (< e : A , a : String >)) }) . (pred b)) | < a = b > => (\ b : (({ d : (< b : Nat , a : Unit >) , b : (Rec A . Bool) }) -> (< d : C , b : String >)) . ((inert [ Unit ]) as (Rec D . Bool))))
(pred ((fix (true b)) . b))
(< d = (fix (inert [ String ])) > as ({ a : ({ d : (< a : Bool , b : String >) , e : ((Float -> B) -> (< c : B , d : B >)) }) , e : ({ a : (< b : B , b : String >) , b : ({ c : Unit , e : C }) }) }))
(iszero ((inert [ Bool ]) (pred ({ b = 2 , b = 1 }))))
((\ a : ({ a : (< d : B , a : Bool >) , b : (Rec A . Bool) }) . (< e = b > as A)) (fix (inert [ Unit ])))
(\ a : ({ e : (Rec C . C) , a : (< c : Nat , c : A >) }) . (case ({ a = (pred 0) , c = (succ 0) }) of < a = a > => (unit as (< e : Nat , c : Unit >)) | < d = e > => (let d = (iszero "apple") in 2)))
(succ ({ e = (case a of < d = b > => "boy" | < b = a > => 1) , a = (case 1 of < e = e > => a | < d = b > => 2) }))
(pred ((let a = ({ b = 1 , b = c }) in (pred "apple")) . a))
(< e = (pred ((let a = unit in true) . b)) > as ({ b : (< e : A , d : Float >) , a : ({ b : Unit , e : Bool }) }))
(let a = ({ a = (0 . a) , c = ((1 . d) . b) }) in (fix (b . c)))
((succ (false . b)) . a)
(\ a : (< b : ({ b : (Rec B . A) , e : (Float -> C) }) , b : (A -> C) >) . ({ e = (let b = (\ c : Bool . b) in ({ a = b , e = "boy" })) , a = ((({ e = "apple" , a = b }) . a) . b) }))
