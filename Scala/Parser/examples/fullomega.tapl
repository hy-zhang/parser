x
if x then false else x
\x:A.x
\X:Star=>Star.unit as X Bool
(\X:Star.\x:X.x) [All X:Star.X->X]
\x:({Some X:Star, {c:X, f:X->Nat}}).x
{*All Y:Star.Y, \x:All Y:Star.Y.x} as {Some X:Star, X->X}
{*Nat, {c=0, f=\x:Nat.succ (x)}} as {Some X:Star, {c:X, f:X->Nat}}
let {X,ops} = {*Nat, {c=0, f=\x:Nat.succ (x)}} as {Some X:Star, {c:X, f:X->Nat}} in (ops.f ops.c)
(if ((succ "apple") [ (Ref C) ]) then (! (ref (fix (a . d)))) else ({ e = (succ "apple") , c = (a as Unit) }))
(pred (succ (c [ A ])))
(iszero (inert [ (All D : Star . Unit) ]))
((! (inert [ Float ])) ((({ * Unit , unit } as C) := (\ d : C . true)) [ ({ e : (All A : Star . Unit) , d : (\ D : Star . Bool) }) ]))
(pred ({ * (\ A : (Star => Star) . ({ Some C : Star , A })) , (c "boy") } as (C -> Float)))
((fix (pred (if false then "apple" else 1))) (let e = ((false [ Nat ]) . d) in (1 := true)))
((ref ((if "apple" then unit else true) as B)) (inert [ (Ref ({ b : (C -> Bool) , b : ({ b : A , d : B }) })) ]))
(inert [ ({ Some E : ((Star => Star) => (Star => Star)) , ((\ C : Star . Unit) -> (All A : Star . C)) }) ])
({ * ({ Some C : (Star => Star) , ({ a : Bool , b : Nat }) }) , ((true := true) := ({ * ({ a : Nat , b : Unit }) , ((pred 0) := unit) } as ({ Some C : Star , Unit }))) } as (\ D : (Star => (Star => Star)) . ((C -> Bool) -> (All E : Star . A))))
(fix (\ d : ({ d : A , e : A }) . (fix (if 2 then "boy" else 2))))
(\ b : ((Nat Bool) -> ({ a : Nat , e : Unit })) . (ref ((succ b) as (Ref A))))
(let e = (if (unit := (c [ Nat ])) then (\ E : (Star => Star) . (c unit)) else (pred true)) in ((fix c) [ (\ B : (Star => Star) . ({ e : Float , d : String })) ]))
((ref ((\ D : Star . 1) [ (Ref B) ])) as ({ e : (All C : Star . Bool) , d : ({ c : Float , c : Unit }) }))
((ref (fix unit)) := (pred ({ e = (inert [ C ]) , e = (let { C , c } = "boy" in (let c = false in a)) })))
((inert [ ({ e : (All D : Star . B) , b : (C -> B) }) ]) as ({ Some E : (Star => (Star => Star)) , (A Nat) }))
(iszero ((! ((! "apple") [ (Bool -> A) ])) as (((Ref C) B) (All E : Star . Bool))))
(inert [ ({ Some C : ((Star => (Star => Star)) => (Star => (Star => Star))) , (All C : (Star => Star) . Unit) }) ])
((ref (let a = true in a)) (iszero (inert [ ({ d : Nat , d : B }) ])))
(\ C : ((Star => Star) => (Star => Star)) . (inert [ (\ B : ((Star => Star) => Star) . (Ref B)) ]))
((if (iszero c) then (iszero a) else (! c)) . d)
(iszero ({ * ((Unit -> B) (\ A : Star . (C String))) , (\ C : (Star => Star) . "apple") } as (All B : (Star => Star) . ({ Some C : Star , Bool }))))
(fix (({ * String , (pred false) } as (All D : Star . Nat)) . e))
(\ e : (All B : ((Star => Star) => ((Star => Star) => (Star => Star))) . ({ b : (Ref B) , e : A })) . (! (inert [ Nat ])))
(let { C , c } = ({ a = (1 [ Unit ]) , e = (ref 2) }) in (! (let e = 1 in 0)))
(ref ((let { E , c } = c in "boy") as (Bool -> B)))
(let { C , e } = (((\ D : Star . unit) as (Float -> Float)) as (Float ({ Some C : Star , A }))) in ((a false) := (fix (inert [ Bool ]))))
(succ ((let c = (pred 1) in (pred "apple")) ((succ false) false)))
(\ E : (((Star => Star) => (Star => Star)) => (Star => Star)) . ((if (iszero 0) then ((if "boy" then false else "apple") . b) else (true as Nat)) [ ((\ C : (Star => Star) . ({ c : String , d : Bool })) (B B)) ]))
(fix (let { D , b } = (inert [ (All D : Star . Float) ]) in (iszero unit)))
(\ B : (((Star => Star) => (Star => Star)) => ((Star => Star) => Star)) . (fix (true as (C -> Bool))))
(iszero (\ E : (Star => (Star => Star)) . ({ * (All D : Star . Nat) , (\ a : Bool . 2) } as A)))
({ * (All E : (Star => Star) . (({ a : Bool , d : Unit }) (Ref String))) , (! (if (let { E , b } = true in (if 0 then unit else 1)) then (! a) else (false [ String ]))) } as ((A Nat) ({ d : Float , b : Unit })))
((pred (iszero (fix (\ D : Star . a)))) := (({ * ({ Some B : Star , Bool }) , a } as ({ d : Float , c : C })) . b))
(\ D : ((Star => Star) => ((Star => Star) => (Star => Star))) . (((if (\ B : Star . true) then unit else (true false)) . c) as (\ C : Star . (C -> Unit))))
({ * ({ c : ((({ Some E : Star , C }) -> (All A : Star . Bool)) (Ref Bool)) , b : ({ e : String , c : Nat }) }) , (! ((1 0) as Unit)) } as (Ref ({ Some C : Star , B })))
(let c = (\ c : (C -> Unit) . (let { A , b } = ((! "boy") [ (String -> A) ]) in (let e = "apple" in c))) in (fix (a as ({ Some B : Star , Unit }))))
((ref (pred (0 false))) := (({ c = (\ D : Star . b) , d = (let e = false in 2) }) ({ * (All A : Star . A) , (pred b) } as ({ Some E : Star , Bool }))))
(inert [ ((Ref A) (All D : Star . Bool)) ])
(let c = (ref (\ b : A . unit)) in (let d = (if c then 0 else (fix 1)) in (pred "apple")))
(pred (succ ({ e = "apple" , b = (ref c) })))
(if (({ * String , (pred 1) } as Nat) := ({ * Unit , b } as Bool)) then ({ c = (ref (inert [ Unit ])) , c = (! "boy") }) else ((inert [ B ]) [ (Ref A) ]))
(let { D , a } = ((iszero 2) . e) in (pred (! c)))
(\ E : ((Star => Star) => (Star => Star)) . (fix (\ C : (Star => Star) . (0 as Bool))))
(succ (if (ref (pred false)) then (! (pred unit)) else ((iszero (let a = "boy" in 1)) [ (String -> A) ])))
((fix (let b = (inert [ ({ Some C : Star , B }) ]) in (let { A , c } = (let a = 2 in b) in (let { B , c } = unit in a)))) [ (Ref (Ref A)) ])
(\ C : ((Star => (Star => Star)) => (Star => (Star => Star))) . (! (! true)))
({ c = (let a = (\ E : Star . false) in (({ b = 2 , e = (ref 2) }) [ (All C : (Star => Star) . A) ])) , c = (if (\ c : (\ B : Star . A) . (ref unit)) then (b . e) else (let { B , d } = 1 in (iszero false))) })
(iszero (((let { D , c } = c in 2) as (Float Bool)) [ (({ Some C : (Star => Star) , (C B) }) (All B : Star . Unit)) ]))
(\ d : ((Ref (Float String)) ((Unit ({ d : A , b : Float })) -> (Ref A))) . (succ (if a then c else false)))
((fix (ref unit)) . e)
(ref (pred ((let b = 1 in "boy") . e)))
(((iszero unit) . e) . a)
(\ d : ({ Some B : ((Star => Star) => (Star => Star)) , ((All E : (Star => Star) . String) (All B : Star . (All D : Star . Unit))) }) . ((({ * Bool , (inert [ Unit ]) } as B) (c as Unit)) (pred (false := 1))))
((fix ((! 1) := (b as A))) . a)
((let { E , c } = (((b . b) as (All A : Star . String)) as ({ e : Unit , a : String })) in ((let { E , d } = 0 in c) [ (Nat -> Nat) ])) . b)
(fix ((let d = ({ c = unit , d = 2 }) in 0) [ ({ Some A : Star , (Ref A) }) ]))
({ a = ({ * ({ Some B : Star , (\ A : Star . Nat) }) , (fix b) } as (String -> Bool)) , a = (if (let e = "apple" in (\ a : Unit . b)) then (\ A : Star . "boy") else (unit . b)) })
((((iszero (iszero 0)) as (String -> C)) [ (Ref (Ref C)) ]) (\ c : (Nat -> A) . (unit 2)))
(inert [ (All D : ((Star => Star) => (Star => Star)) . ({ Some E : Star , ({ b : Bool , b : Unit }) })) ])
((inert [ (Ref ({ Some C : Star , B })) ]) (pred (! unit)))
((\ B : ((Star => Star) => (Star => Star)) . (succ (\ A : Star . true))) [ ((Ref ({ Some B : Star , Bool })) (\ D : (Star => Star) . (Float Bool))) ])
(let { D , b } = (ref (ref (ref 1))) in (succ (({ d = false , a = 1 }) := unit)))
(succ (let d = (1 := a) in (let { E , a } = unit in (\ b : Unit . a))))
(inert [ (Ref (All C : (Star => Star) . (Ref Nat))) ])
({ * (Ref (Ref (All B : Star . String))) , (pred ({ * ({ c : Float , a : A }) , (iszero "apple") } as Bool)) } as (All A : ((Star => Star) => Star) . (All C : Star . Nat)))
(inert [ (All B : (Star => Star) . (Ref Nat)) ])
({ * ({ Some B : (Star => Star) , ((\ A : Star . Bool) Float) }) , (inert [ (Float -> Unit) ]) } as (All C : ((Star => Star) => (Star => Star)) . (\ A : (Star => Star) . Nat)))
(ref (fix (pred true)))
(((\ B : Star . 2) (0 . d)) as (Ref (\ A : (Star => Star) . ({ c : Unit , c : String }))))
(\ b : (Ref (C -> (Ref B))) . ((iszero false) := (fix 2)))
(({ * ({ b : ({ Some C : Star , Float }) , a : Bool }) , ((\ e : Float . 0) := ({ b = 2 , a = c })) } as ((A -> String) -> ({ b : String , b : Bool }))) . a)
((let { A , b } = ((inert [ A ]) := (succ 2)) in (iszero (c . a))) as (Ref (All D : (Star => Star) . Unit)))
(let d = (pred ("apple" "boy")) in ((c true) as (C (\ E : Star . Float))))
(inert [ ({ Some B : (((Star => Star) => (Star => Star)) => (Star => Star)) , (All A : (Star => Star) . (All B : (Star => Star) . String)) }) ])
((let { B , b } = (fix ((succ unit) 1)) in ((ref a) as ({ a : B , c : A }))) := (let e = ({ * ((String -> Nat) ({ e : B , e : Unit })) , (fix a) } as ({ Some B : Star , Bool })) in ((if 1 then 0 else 0) . c)))
(((let { A , c } = 1 in a) [ (({ Some C : Star , Bool }) Nat) ]) := ((if (fix unit) then (\ c : C . 2) else (pred true)) := (ref true)))
(\ A : ((Star => Star) => (Star => Star)) . (if (false [ String ]) then ((! c) [ (Ref Bool) ]) else (inert [ Unit ])))
({ * (Ref (All D : Star . Unit)) , (let b = (inert [ Nat ]) in (\ B : Star . (c 1))) } as ({ Some B : ((Star => Star) => Star) , (String -> C) }))
(pred (\ a : (Ref C) . (\ d : (Ref Bool) . c)))
(({ * ({ b : Float , a : (A -> Nat) }) , ((pred 2) as A) } as ((Float Bool) -> String)) [ ({ d : (\ C : (Star => (Star => Star)) . (All E : Star . Unit)) , a : (C -> B) }) ])
(! (((a b) (\ c : Nat . unit)) as (Ref ({ a : (Ref Unit) , a : Bool }))))
(\ c : (\ E : ((Star => Star) => (Star => Star)) . (All C : (Star => Star) . B)) . ({ d = (pred (let a = false in 0)) , e = (\ B : Star . unit) }))
(inert [ (\ E : (Star => Star) . (B (\ B : Star . A))) ])
(succ ({ * ({ Some E : Star , (Ref C) }) , (true as Float) } as (\ B : Star . (\ D : Star . Bool))))
((((inert [ String ]) as Nat) (\ B : (Star => Star) . (let { E , b } = ("boy" as C) in false))) [ (Ref (\ D : Star . String)) ])
(({ * (Ref C) , (let { B , d } = "boy" in unit) } as ({ a : (String String) , b : Nat })) as (Ref ({ e : Unit , e : Unit })))
({ * (All A : ((Star => Star) => (Star => Star)) . ({ a : (Ref (Ref Unit)) , b : (Ref (Ref Nat)) })) , (succ ({ * B , "boy" } as Nat)) } as ({ Some D : ((Star => Star) => Star) , ({ Some A : (Star => Star) , Unit }) }))
((let a = (iszero (unit . c)) in (\ B : Star . (pred "boy"))) . c)
(({ * (A -> Unit) , ({ d = 0 , b = (let b = true in "boy") }) } as ((B String) -> (Float B))) := (\ C : ((Star => Star) => Star) . (ref true)))
(\ d : (Ref ({ Some D : Star , A })) . ((iszero c) ({ a = (if ({ e = b , d = 1 }) then true else (1 := 2)) , a = ((pred false) as B) })))
((let d = (fix (if "boy" then ("boy" := 0) else (pred 0))) in ((\ e : Float . "apple") [ C ])) [ (({ e : (\ A : Star . Float) , d : (\ E : Star . Nat) }) ({ Some B : Star , Unit })) ])
(let c = (\ D : (Star => (Star => Star)) . (inert [ (All B : Star . Bool) ])) in ({ a = (\ a : String . "apple") , d = (pred ({ * B , "boy" } as Bool)) }))
(pred (let { D , b } = (iszero (succ b)) in (let a = 1 in 2)))
(if ((! unit) := (let e = "apple" in true)) then (! (pred (! "apple"))) else (\ E : ((Star => Star) => (Star => Star)) . (! (iszero 1))))
(! (let b = (let c = "apple" in a) in (2 := (! false))))
({ * (Ref ({ e : (({ Some A : Star , Bool }) String) , b : ({ Some B : Star , A }) })) , (! (2 as Float)) } as (Ref ({ b : A , e : (Nat A) })))
(let a = (inert [ ({ Some B : Star , Unit }) ]) in (let { A , b } = (let { D , a } = (0 unit) in (inert [ Bool ])) in (\ a : ({ c : Nat , c : Float }) . "apple")))
({ * (Ref ({ a : String , d : (All B : Star . B) })) , (({ d = (inert [ Float ]) , d = (iszero 0) }) . d) } as ({ Some D : (Star => Star) , (B B) }))
(let { E , e } = ((a [ ({ Some D : Star , B }) ]) as (\ A : Star . B)) in ((inert [ Unit ]) := (false as Nat)))
(fix (pred (let e = (inert [ String ]) in (inert [ C ]))))
({ c = (\ d : ({ Some C : (Star => Star) , ({ Some B : Star , A }) }) . (fix a)) , d = ((false . e) [ (Nat ({ Some B : Star , A })) ]) })
(\ e : ((Ref B) -> ({ Some C : Star , B })) . (iszero ({ d = 1 , c = unit })))
(fix ({ * ((C -> C) -> ({ Some D : Star , Unit })) , (iszero ({ * C , 0 } as B)) } as (C -> (\ A : Star . Bool))))
(fix ({ * ({ a : Nat , c : ({ a : Nat , d : String }) }) , (({ * B , b } as C) := b) } as ({ Some D : (Star => Star) , (All A : Star . Bool) })))
(! (inert [ ((Ref String) -> ({ Some E : Star , C })) ]))
(pred (\ C : (Star => Star) . (c := 1)))
(({ * ((Float C) -> (\ C : Star . A)) , ((fix true) "apple") } as (Ref ({ Some C : Star , Float }))) as ({ d : ({ b : (Ref A) , e : Float }) , d : ({ Some C : Star , Unit }) }))
(((iszero false) ((true a) := a)) as (Ref (({ e : A , d : B }) (Unit -> C))))
(succ ({ * (Ref ({ a : A , e : Unit })) , (\ c : ({ c : Nat , c : Unit }) . ({ a = "apple" , d = 0 })) } as ({ Some C : ((Star => Star) => Star) , ({ Some B : Star , ({ e : B , b : String }) }) })))
(! (let e = (iszero 1) in (inert [ A ])))
((inert [ (All A : Star . C) ]) := (\ D : (Star => Star) . (succ (\ c : Float . c))))
(! ((iszero true) as (All E : Star . Float)))
(succ (let { E , b } = (unit . e) in ("boy" . c)))
(({ * (Bool -> A) , (inert [ (Ref C) ]) } as ({ c : String , a : Float })) . b)
((pred (\ b : ((All B : Star . C) -> (String A)) . (if unit then unit else true))) := (iszero (fix (! 0))))
(iszero (iszero (succ true)))
((ref (succ ((ref unit) := unit))) as (All D : (Star => Star) . (C Nat)))
(iszero (fix (0 := 1)))
({ * (All A : ((Star => Star) => (Star => Star)) . ({ e : (All B : Star . String) , b : Float })) , (\ E : (Star => Star) . (fix a)) } as (Ref ((Ref String) -> (Bool -> (Ref Bool)))))
(\ d : ((All E : Star . (Ref String)) -> (All C : (Star => Star) . (Ref (String -> Nat)))) . (pred (\ a : Nat . (pred false))))
(iszero (pred (false := true)))
(let c = ((("boy" as String) := ({ b = "boy" , b = c })) := (iszero true)) in (let { E , a } = (ref (fix 0)) in ({ a = true , a = 1 })))
(((iszero c) (\ D : Star . a)) [ (({ Some B : (Star => Star) , ({ Some D : Star , String }) }) -> ((\ C : Star . A) (C B))) ])
(\ B : ((Star => Star) => ((Star => Star) => (Star => Star))) . (((fix 1) [ (Ref A) ]) (iszero (if a then a else 1))))
(fix (\ a : (Ref Nat) . (2 c)))
(succ (inert [ ({ d : ((Ref Nat) String) , c : ({ Some C : Star , C }) }) ]))
(fix ((\ D : Star . true) [ (\ A : Star . B) ]))
(\ E : (((Star => Star) => (Star => Star)) => (Star => (Star => Star))) . (((fix unit) := (if b then unit else a)) := (({ e = "boy" , a = b }) as ({ Some D : (Star => Star) , (Ref C) }))))
(pred ({ b = ((if "boy" then "apple" else c) (let d = "apple" in 2)) , d = ({ b = (false as String) , b = (fix (inert [ Float ])) }) }))
(inert [ ((All B : Star . B) ((Bool -> Nat) -> String)) ])
((\ a : ({ Some C : Star , String }) . (\ c : String . 1)) := (if (c := "boy") then (unit as (String -> Float)) else (ref 1)))
(((c := 1) (succ 1)) (\ B : (Star => Star) . (! (unit := b))))
((\ A : ((Star => Star) => (Star => Star)) . ({ c = ("apple" [ B ]) , e = 1 })) (ref (\ e : B . 0)))
({ * (Ref ({ Some E : Star , (B String) })) , ({ * (Unit -> A) , (inert [ A ]) } as (All E : Star . ({ e : String , c : Bool }))) } as ({ c : ({ a : Float , b : ({ Some B : Star , C }) }) , a : (Unit -> String) }))
((fix ((iszero true) := (iszero 1))) (let { C , d } = (if 2 then "apple" else c) in (c c)))
((({ a = ({ * Bool , unit } as B) , d = (fix false) }) [ ({ a : (C -> C) , e : (Unit -> Nat) }) ]) := (({ e = (2 [ (\ B : Star . String) ]) , d = (inert [ String ]) }) as ({ e : (\ E : Star . Float) , b : ({ Some E : Star , C }) })))
((iszero (\ e : ({ Some A : Star , Float }) . ({ * C , 1 } as Float))) . e)
(\ A : ((Star => (Star => Star)) => ((Star => Star) => (Star => Star))) . (if (succ (succ false)) then (iszero (2 := false)) else (let b = (! (pred true)) in ({ * String , ({ d = 2 , b = "boy" }) } as Unit))))
((\ e : (\ E : Star . Unit) . (iszero true)) as ((All D : (Star => Star) . ({ b : String , d : Float })) -> ((Ref B) -> (Nat Unit))))
(inert [ ({ Some B : (Star => Star) , (Bool -> Bool) }) ])
(pred (inert [ (All E : Star . (\ C : Star . A)) ]))
(let d = (succ ((! "apple") := (unit := 0))) in (let { B , d } = (let { D , d } = a in (let d = c in "apple")) in (\ e : (All C : Star . A) . b)))
((! (succ false)) as ({ Some D : ((Star => Star) => Star) , ({ e : A , e : Nat }) }))
(! (! (fix true)))
(\ c : ({ a : ((Bool B) -> ({ c : ({ Some B : Star , A }) , b : B })) , e : ((All A : Star . String) (All B : Star . A)) }) . (if ("boy" . d) then (true as Nat) else (if 0 then a else unit)))
(fix (succ (! "apple")))
({ * (\ D : (Star => Star) . (Unit B)) , (iszero (! "apple")) } as ({ Some B : (((Star => Star) => (Star => Star)) => (Star => Star)) , ({ c : (Ref C) , b : (Ref B) }) }))
(! (if ((c unit) [ (All C : Star . Bool) ]) then ({ e = (1 . e) , a = (if (inert [ Unit ]) then b else (succ "boy")) }) else (let { A , d } = (pred unit) in (a [ Unit ]))))
({ d = ((if "boy" then 0 else a) := (iszero 0)) , b = (ref (true as Float)) })
((inert [ (Ref Nat) ]) as (Ref (Ref A)))
(inert [ ({ e : (\ D : (Star => Star) . (B C)) , c : ((All D : Star . Unit) -> (Ref Nat)) }) ])
(let { A , d } = ((let { A , b } = (\ B : Star . unit) in (if 1 then b else false)) := ((2 [ Float ]) . e)) in (ref (let { E , b } = unit in b)))
(succ ({ * (\ E : Star . A) , (unit [ Nat ]) } as (\ D : (Star => Star) . ({ Some B : Star , Nat }))))
(succ (inert [ (({ Some B : Star , Float }) -> (Ref Bool)) ]))
(({ * (\ E : Star . Float) , (1 a) } as ({ Some E : Star , B })) := (ref (\ c : (B -> Bool) . (pred (pred "boy")))))
(ref (\ B : (Star => Star) . (inert [ B ])))
(succ ((if (\ C : Star . (if true then false else c)) then (0 := 1) else ((1 := c) (unit as Float))) := (ref "apple")))
(pred (\ a : (Nat -> Bool) . ((\ c : C . "apple") as ({ Some C : Star , Float }))))
(let { B , d } = (({ * String , 2 } as Bool) . a) in (if (iszero false) then (let { D , c } = 0 in c) else (! true)))
(! ((false as B) . a))
(pred (pred (let a = b in "apple")))
(pred ((! (ref true)) . e))
(((! false) . e) . d)
((let { E , b } = (\ B : ((Star => Star) => Star) . (ref b)) in (! true)) [ (\ A : (Star => (Star => Star)) . ((Nat String) Float)) ])
(let c = ({ * (All B : Star . B) , ({ d = (pred b) , b = unit }) } as ({ a : (B A) , d : B })) in ((iszero "apple") (true [ C ])))
(! (! ((let e = 1 in a) . e)))
(\ E : ((Star => Star) => (Star => Star)) . ({ a = ({ a = "apple" , d = "boy" }) , c = ({ b = a , b = 1 }) }))
(iszero ((let { B , c } = (fix false) in (let a = c in false)) as ({ a : String , c : Float })))
(pred ({ d = (({ b = false , c = 0 }) (pred ({ a = "boy" , e = 0 }))) , e = (fix (true as A)) }))
(\ B : (((Star => Star) => Star) => (Star => (Star => Star))) . (\ C : (Star => (Star => Star)) . ({ d = (iszero true) , c = a })))
(pred ({ * ({ e : (All A : Star . Float) , b : (Ref Unit) }) , (c := b) } as (Ref String)))
(! (if (let e = 2 in 0) then (inert [ Unit ]) else (inert [ ({ a : A , c : B }) ])))
(({ * (Ref String) , (ref "apple") } as (\ A : Star . Unit)) := (\ A : (Star => Star) . (unit [ String ])))
(\ E : ((Star => Star) => (Star => Star)) . ({ b = (pred true) , c = (iszero (iszero "apple")) }))
({ a = (\ d : (\ D : Star . Float) . (! ({ * Nat , c } as Float))) , c = (let { B , e } = (({ * String , true } as String) (let { E , e } = true in 1)) in ((ref unit) := (inert [ Nat ]))) })
((if (pred 0) then (inert [ (All C : Star . B) ]) else (ref ({ * Unit , "boy" } as B))) as ((\ D : (Star => Star) . (Float String)) ({ Some A : (Star => Star) , (C -> A) })))
(let a = (\ E : ((Star => Star) => (Star => Star)) . (((b as A) . d) [ (B Float) ])) in (let a = (inert [ ({ Some C : (Star => Star) , (All D : Star . Nat) }) ]) in (\ b : B . (! "apple"))))
(if (fix (pred (if unit then "boy" else 2))) then (if (fix unit) then (succ b) else (a := 2)) else (({ * C , (1 unit) } as String) as (Nat -> Bool)))
(\ c : (All B : (Star => Star) . ({ c : (A -> (Ref Bool)) , e : ({ Some D : (Star => Star) , C }) })) . (succ (! unit)))
({ e = (! (2 2)) , e = (succ (iszero ({ a = unit , c = unit }))) })
(\ E : ((Star => Star) => (Star => Star)) . (\ A : (Star => Star) . (\ D : Star . 1)))
(iszero (pred (! false)))
(iszero (inert [ (\ B : Star . Float) ]))
((iszero ((true . b) (1 . a))) . b)
({ d = ((let c = (1 [ Unit ]) in (let { D , b } = "boy" in false)) [ ({ e : (\ B : Star . B) , b : (Ref A) }) ]) , a = (let a = (pred (! 0)) in (let { E , b } = (succ b) in (if (1 false) then 1 else ({ b = c , a = 2 })))) })
(({ * ((\ B : Star . String) (B -> C)) , (\ a : (Unit Unit) . 1) } as (Nat -> Nat)) as (\ D : ((Star => Star) => (Star => Star)) . (Ref ({ a : C , b : Float }))))
(pred ((pred ({ d = "apple" , e = true })) [ (String Nat) ]))
(iszero ({ * (All D : Star . C) , (\ D : (Star => Star) . (1 as B)) } as ((Ref String) C)))
(fix (! ((iszero (fix unit)) as ({ b : Float , a : Unit }))))
(((unit (\ E : Star . a)) (c "boy")) [ ({ b : (Ref ((B C) Float)) , b : (All E : (Star => (Star => Star)) . ({ Some A : Star , Float })) }) ])
(((let { A , a } = unit in true) := (let b = unit in ({ d = "apple" , c = "boy" }))) as (({ d : B , a : B }) -> (All D : Star . String)))
({ * ({ Some E : ((Star => Star) => (Star => Star)) , (\ D : (Star => Star) . Float) }) , (! (! (if (let { B , c } = a in 0) then (fix false) else unit))) } as (All B : ((Star => Star) => (Star => Star)) . (All E : (Star => Star) . ({ c : String , b : (Nat -> String) }))))
(if ({ * ({ a : (All E : (Star => Star) . String) , e : (Ref String) }) , ({ * Unit , 1 } as Bool) } as (All E : (Star => Star) . ({ b : Nat , a : B }))) then ((inert [ A ]) as ({ Some B : Star , Unit })) else (let { C , d } = (fix "apple") in (1 as (B -> Unit))))
(({ b = (0 1) , d = (let { E , b } = ("apple" := 1) in "apple") }) . a)
((let { B , a } = (succ (true := ("apple" as A))) in ((! c) . e)) [ ((Ref (All E : Star . Bool)) (\ D : Star . (All C : Star . B))) ])
(iszero (((let e = 1 in 1) . c) := (\ d : ((B Nat) (Unit -> String)) . (fix c))))
(\ A : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => Star))) . (\ b : ({ a : Nat , d : B }) . ({ * String , ({ * B , 1 } as Nat) } as ({ c : Nat , b : B }))))
(\ c : ({ e : ((A -> C) -> (B A)) , a : (\ A : Star . (Ref Bool)) }) . (iszero (pred (ref c))))
(let { E , b } = ((fix (ref unit)) . c) in (\ c : ({ b : (Ref Bool) , b : (Float -> B) }) . (\ D : Star . c)))
({ d = (ref ((if 2 then c else 1) (! "apple"))) , e = ((pred (iszero b)) := (fix unit)) })
(((! (false a)) := (succ ("apple" . e))) as ({ Some C : (Star => Star) , (Ref A) }))
(((let e = (fix 2) in (if true then 0 else 2)) . a) [ ((All C : Star . A) -> ({ d : Float , e : A })) ])
(pred (! (\ C : Star . 2)))
({ a = ({ d = (({ e = true , b = false }) := (inert [ Float ])) , d = (pred true) }) , d = (\ e : (\ C : (Star => Star) . Unit) . (ref (\ b : C . "apple"))) })
((\ d : (All B : (Star => Star) . ({ Some E : Star , C })) . (\ B : Star . a)) (if (let { B , a } = true in unit) then (b as B) else (if a then a else "boy")))
(pred (ref (0 [ Unit ])))
(if (! (a := a)) then (succ ((({ * A , false } as B) as ({ Some C : Star , Bool })) as (All D : Star . ({ a : B , e : C })))) else (if ({ b = (ref c) , b = ((b [ C ]) true) }) then (! (\ e : Nat . 0)) else ((iszero "apple") as ({ Some A : Star , B }))))
(iszero (let { E , b } = (b as A) in (let e = "apple" in a)))
(inert [ (Ref (B ({ b : Float , b : String }))) ])
(\ B : ((Star => Star) => ((Star => Star) => Star)) . (\ D : ((Star => Star) => Star) . (fix ((unit . b) true))))
(let { B , a } = (iszero (! (ref "apple"))) in (iszero (inert [ (Float -> Unit) ])))
((ref ("apple" [ Unit ])) (if (! (! "boy")) then (let { D , e } = ("boy" [ C ]) in 1) else (ref (b := b))))
({ c = (\ d : ((All A : (Star => Star) . A) (Ref String)) . ((a "boy") . d)) , d = ({ d = (false := 0) , b = (\ E : Star . a) }) })
(let a = (let { E , c } = (1 "apple") in (\ A : (Star => Star) . 1)) in (\ b : (\ E : Star . String) . (\ E : (Star => Star) . 2)))
(iszero (((if unit then false else "apple") [ Float ]) as (All A : Star . String)))
(pred (if (\ A : (Star => Star) . (let { C , b } = "apple" in c)) then (fix (if "apple" then c else b)) else (inert [ (Unit A) ])))
(((fix a) [ (Ref (All D : Star . B)) ]) ((fix (iszero unit)) [ (\ B : Star . (Ref Bool)) ]))
(let { A , d } = ({ * (Ref Bool) , (let { B , d } = 0 in true) } as (Ref String)) in (let { A , b } = (inert [ Unit ]) in (inert [ Nat ])))
(let { B , b } = ({ c = ((if c then false else unit) [ C ]) , e = (pred (pred c)) }) in ({ c = (inert [ ({ Some C : Star , C }) ]) , b = (! (let { B , c } = b in c)) }))
(inert [ (Ref (Float (Nat Nat))) ])
(fix (inert [ (({ b : C , b : A }) -> C) ]))
(let { A , c } = (iszero (inert [ (Ref Unit) ])) in (let b = ((if unit then (true := b) else 0) [ (All B : Star . A) ]) in (pred (\ c : C . unit))))
(\ c : (\ E : (Star => (Star => Star)) . ((Ref Nat) ({ b : Unit , c : A }))) . (fix ({ c = c , b = b })))
(pred ({ b = ({ * A , "boy" } as A) , c = (\ a : String . 2) }))
(! (let { A , b } = (inert [ (All C : Star . Unit) ]) in (\ c : (\ A : (Star => Star) . A) . (if 1 then false else b))))
(inert [ ({ c : (Ref (\ B : Star . (Unit -> Unit))) , d : ({ Some C : Star , ({ Some A : Star , B }) }) }) ])
(inert [ (Ref (Ref Float)) ])
((let { A , a } = ((ref c) as (All A : Star . Unit)) in (unit as ({ Some D : Star , Float }))) [ (Ref (Bool Nat)) ])
(((2 (b := c)) [ (Ref Unit) ]) := (({ * ({ b : Nat , e : C }) , ({ * C , 2 } as Bool) } as (\ E : Star . B)) [ ({ a : ({ Some A : Star , Bool }) , b : (Ref B) }) ]))
(inert [ (All A : ((Star => Star) => (Star => Star)) . ({ a : B , d : Unit })) ])
((\ B : (Star => Star) . (let { D , d } = c in (! c))) [ (\ D : ((Star => Star) => (Star => Star)) . (All B : (Star => Star) . (\ A : Star . Unit))) ])
({ * ({ a : (All C : ((Star => Star) => (Star => Star)) . (All D : Star . Unit)) , a : (Ref (Float -> A)) }) , (((fix (succ a)) as ({ Some D : Star , B })) := (! ({ d = (2 . e) , c = true }))) } as (\ B : (((Star => Star) => Star) => (Star => Star)) . ({ Some A : (Star => Star) , (A -> Unit) })))
(pred ((succ (inert [ B ])) := ({ c = a , a = (pred c) })))
(inert [ ((All D : Star . ({ Some A : Star , Unit })) (All C : Star . Unit)) ])
({ * (\ D : ((Star => Star) => Star) . (Ref (B Bool))) , (! ((inert [ Unit ]) (\ A : (Star => Star) . false))) } as (({ b : (All B : Star . B) , a : (Ref Unit) }) -> ({ Some D : (Star => Star) , (All B : Star . A) })))
(let a = ({ e = (\ E : (Star => Star) . b) , e = (succ "apple") }) in ((\ b : (All C : Star . String) . false) [ (All C : (Star => Star) . (\ E : Star . Nat)) ]))
(inert [ (Ref (Ref C)) ])
({ * ({ a : ({ Some B : Star , ({ Some D : Star , Unit }) }) , e : ((\ E : Star . String) (A (\ A : Star . B))) }) , (fix (iszero 0)) } as ({ b : (\ D : (Star => Star) . ({ e : A , b : Bool })) , b : (All E : (Star => Star) . Float) }))
(({ e = (if (inert [ Unit ]) then (if "apple" then 1 else 1) else (! c)) , d = (c as C) }) . d)
((let e = ((2 [ Nat ]) as (\ E : Star . C)) in (let e = (let { E , b } = "boy" in unit) in (a . e))) as (All D : ((Star => Star) => (Star => Star)) . ({ Some B : (Star => Star) , String })))
((\ C : (Star => Star) . (succ (let { D , a } = 2 in "boy"))) as (All A : (Star => Star) . (Ref ({ e : Bool , a : A }))))
(if (fix (let { C , e } = ("apple" := false) in (if c then ({ b = 1 , d = b }) else (false := 0)))) then (succ ((if 0 then 2 else c) . e)) else (\ d : ((\ C : Star . B) -> ({ e : String , c : C })) . (pred (inert [ Float ]))))
(let { B , c } = (fix ({ b = (2 := false) , c = false })) in (! (if (if true then b else unit) then (iszero false) else (0 . d))))
((fix ((\ B : (Star => Star) . unit) . d)) . b)
((({ d = (\ A : Star . "boy") , e = (inert [ Float ]) }) (succ (\ d : (Ref Bool) . "apple"))) [ ((All A : ((Star => Star) => (Star => Star)) . ({ e : Nat , a : A })) -> (Ref (All B : (Star => Star) . (All E : Star . Bool)))) ])
({ * ((Ref C) -> (B C)) , (inert [ ({ d : (Ref (\ C : Star . B)) , b : (C -> Float) }) ]) } as (({ e : (C -> C) , e : ({ Some A : Star , C }) }) -> (All E : ((Star => Star) => Star) . (\ C : (Star => Star) . (A -> A)))))
((iszero (inert [ ({ a : Unit , d : C }) ])) as ((\ C : Star . B) -> ({ e : Unit , e : (All D : Star . B) })))
(let { C , e } = (! ((if 1 then "apple" else ({ a = true , a = 0 })) := (inert [ Unit ]))) in ((iszero true) (2 [ Unit ])))
(\ e : (All D : (Star => (Star => Star)) . ({ Some C : (Star => Star) , (C Nat) })) . (inert [ (All A : (Star => Star) . (All C : (Star => Star) . (Float -> String))) ]))
((\ a : (Ref Bool) . (\ e : Float . false)) [ ((All C : (Star => Star) . ({ Some B : Star , Float })) (\ A : (Star => (Star => Star)) . (\ D : Star . Nat))) ])
(! ({ d = (fix 2) , c = (false . b) }))
(\ C : ((((Star => Star) => Star) => (Star => Star)) => (Star => Star)) . (ref (inert [ ({ a : (B -> B) , e : (Bool -> Nat) }) ])))
(iszero (\ E : ((Star => Star) => Star) . (let { D , a } = ({ * B , true } as A) in unit)))
((pred (inert [ Unit ])) (succ (! (fix unit))))
({ * ((Ref (Ref Unit)) (All B : Star . Bool)) , (let c = (2 1) in (ref (0 [ Float ]))) } as (((Float String) -> C) ({ Some C : Star , Nat })))
((succ (({ * (\ E : Star . A) , (ref "apple") } as ({ Some C : Star , Nat })) ({ b = b , e = "boy" }))) (pred ({ e = (pred false) , a = ({ * Bool , unit } as Float) })))
(let { B , d } = ({ * ({ Some D : (Star => Star) , (Float String) }) , (succ (if "boy" then a else unit)) } as ({ d : Float , e : C })) in (let b = (a . e) in (({ * A , 1 } as String) := (true . e))))
(! ((pred a) [ (Ref C) ]))
((\ b : (\ E : (Star => Star) . ({ Some B : Star , C })) . (iszero (iszero unit))) as (Ref (C (All B : Star . A))))
(! (let e = (iszero (iszero 0)) in (! (ref "boy"))))
((if (((let c = a in 2) := (iszero 2)) . b) then (inert [ (Float A) ]) else (0 as (Ref Nat))) . d)
(inert [ (Ref ({ Some A : Star , C })) ])
(let { E , b } = (\ D : (Star => Star) . (let { C , e } = a in 1)) in ((a . b) as ({ Some A : (Star => (Star => Star)) , (\ E : Star . C) })))
(fix (pred (let { A , a } = 2 in 0)))
(succ (({ * Nat , b } as Bool) ({ * String , c } as Unit)))
({ c = (inert [ ({ a : ({ Some E : Star , Float }) , b : Bool }) ]) , c = (\ D : ((Star => Star) => (Star => (Star => Star))) . ({ e = "apple" , c = 0 })) })
((\ b : (All B : Star . (Ref A)) . (false true)) := (iszero (ref 1)))
(if ((if (succ (if 1 then a else true)) then (if false then (let { A , a } = 1 in 0) else (iszero a)) else (fix a)) [ ({ Some A : ((Star => Star) => (Star => Star)) , ({ Some A : Star , String }) }) ]) then (let { B , d } = ((succ (0 := true)) := ({ * (Ref Float) , b } as ({ Some E : Star , C }))) in (\ c : ({ Some E : Star , Unit }) . (inert [ Nat ]))) else ({ a = (false := "boy") , b = (if "apple" then b else "boy") }))
(succ (succ ({ e = (let b = c in true) , a = (let { A , c } = c in 2) })))
(({ e = (\ D : ((Star => Star) => (Star => Star)) . (let { C , e } = "boy" in a)) , c = (\ C : (Star => Star) . (false . a)) }) . e)
(! (("boy" as Bool) as (B -> String)))
({ c = (fix (inert [ B ])) , b = (\ B : (Star => Star) . (2 := a)) })
(pred (! (iszero true)))
(\ c : (({ c : B , b : ({ e : C , c : C }) }) -> (All A : ((Star => Star) => (Star => Star)) . ((Nat B) -> B))) . (\ c : ({ a : ({ Some A : (Star => Star) , Float }) , e : (\ E : (Star => Star) . Nat) }) . (if "boy" then "boy" else (! unit))))
(({ d = (\ D : (Star => (Star => Star)) . (fix 1)) , a = (\ A : Star . 0) }) ((pred a) . a))
(let a = (let { D , c } = (true as C) in ({ e = "apple" , b = b })) in (succ ((unit . b) [ ({ e : C , c : Bool }) ])))
({ d = (({ b = 0 , e = "apple" }) [ (All D : (Star => Star) . Bool) ]) , c = (iszero ((pred false) (b as B))) })
(ref (((! "boy") as B) . c))
({ a = (pred (true as A)) , d = (pred (fix 0)) })
(let { A , c } = (iszero (false false)) in (iszero (\ b : Bool . "boy")))
((let { B , e } = (\ d : A . a) in (iszero "apple")) . a)
({ * (Ref (All D : (Star => Star) . ({ Some B : Star , Float }))) , ((\ D : (Star => Star) . b) . c) } as ((All D : (Star => Star) . (A -> Bool)) -> (Ref Unit)))
(if (ref ((let { C , e } = b in (ref "boy")) as (A -> Float))) then ((let { C , b } = 1 in "boy") [ (Nat Nat) ]) else (iszero (succ 2)))
(\ B : (((Star => Star) => ((Star => Star) => (Star => Star))) => ((Star => Star) => (Star => Star))) . ({ d = ({ b = a , a = (\ a : Unit . "apple") }) , b = (\ c : String . (fix "boy")) }))
(((\ A : (Star => Star) . c) . e) as ({ Some D : ((Star => Star) => Star) , ({ Some A : Star , Float }) }))
(! ({ b = ({ d = ({ a = c , b = 0 }) , e = "boy" }) , e = (unit := 0) }))
((let c = (succ (c as B)) in (({ b = 2 , e = 0 }) [ String ])) := (let d = (iszero (pred unit)) in ((fix unit) [ (Nat -> C) ])))
((iszero (iszero false)) as ({ Some D : (Star => Star) , (B -> Unit) }))
(let a = (pred (! 0)) in (({ * (\ C : (Star => Star) . C) , (succ (pred "apple")) } as (All A : Star . Nat)) . c))
(({ * ({ e : Unit , b : Nat }) , ((iszero 1) as ({ b : (Nat C) , e : ({ Some A : Star , Nat }) })) } as (C (All B : Star . A))) (iszero ({ * Float , "boy" } as (All E : Star . Bool))))
((fix (let d = a in (true := true))) . a)
(let b = (\ E : ((Star => Star) => Star) . (let { E , c } = (! true) in (! c))) in ((({ * ({ a : B , c : C }) , false } as B) as ({ a : String , a : A })) := (let { D , c } = a in ({ * Bool , "boy" } as String))))
(iszero (! (pred (let { C , c } = "apple" in c))))
((inert [ (\ C : Star . A) ]) [ ({ Some C : (Star => (Star => Star)) , (Ref A) }) ])
(fix (if ({ * Nat , (1 as Nat) } as (Ref Float)) then ((succ unit) := (inert [ String ])) else (({ * Bool , (! "boy") } as B) as (Unit -> A))))
(((fix ({ * Float , a } as Float)) [ ({ d : ({ Some C : Star , B }) , b : (Ref Float) }) ]) . c)
(succ (succ (if 2 then 1 else 1)))
((let { B , c } = ({ * ({ Some C : (Star => Star) , Nat }) , (a := "boy") } as (All D : (Star => Star) . Nat)) in ((2 . d) [ (String (\ A : Star . A)) ])) ({ e = ({ * (All A : Star . Bool) , (unit := b) } as (C -> A)) , d = (pred (pred a)) }))
(((if ("apple" [ Unit ]) then "boy" else (b false)) (let { B , d } = unit in false)) . c)
(\ E : (((Star => Star) => Star) => (((Star => Star) => (Star => Star)) => ((Star => Star) => Star))) . ((fix (let { B , a } = c in 0)) (\ C : ((Star => Star) => (Star => Star)) . (let c = unit in 0))))
(let { A , d } = ({ b = ({ d = a , e = a }) , b = ({ e = ({ * (Float String) , (if 1 then c else false) } as B) , a = (\ e : A . "boy") }) }) in (\ c : ({ d : (Nat Bool) , b : (Float -> Bool) }) . (succ (! 0))))
(\ e : ((C String) -> (Ref Unit)) . (({ e = a , d = a }) as ({ Some E : Star , (C -> Bool) })))
(ref (\ E : ((Star => Star) => ((Star => Star) => (Star => Star))) . (! ("boy" [ ({ c : Unit , e : Unit }) ]))))
(\ d : (Ref ({ Some C : ((Star => Star) => Star) , ({ Some C : Star , ({ e : B , c : C }) }) })) . ({ * ({ Some A : ((Star => Star) => Star) , (String -> Bool) }) , ({ d = 0 , b = false }) } as (\ D : Star . Nat)))
(((inert [ ({ c : Float , d : Float }) ]) (fix (! 2))) := (({ d = unit , a = unit }) . c))
(iszero (\ B : (Star => Star) . (! "boy")))
(pred (let { A , c } = (let { A , b } = 2 in (fix "apple")) in (false := c)))
(let b = (pred ({ * B , 0 } as Float)) in (succ (fix ((fix c) as A))))
(({ * (({ b : Bool , e : A }) -> C) , (fix (fix a)) } as ((Bool A) -> Nat)) (\ a : (All E : (Star => Star) . (\ E : Star . Unit)) . (({ e = c , b = b }) := (\ C : Star . 1))))
((! (ref c)) := (\ B : (Star => Star) . (succ 0)))
(\ e : (Ref ((\ C : Star . B) -> ({ Some B : Star , Unit }))) . (ref ({ a = (let c = 0 in true) , c = (let { D , b } = "apple" in c) })))
((ref (ref ({ * (B Bool) , (false := c) } as ({ Some D : Star , A })))) ((fix true) (if (let { B , e } = 0 in a) then 2 else (inert [ B ]))))
({ b = ((! 1) . b) , c = (pred (\ C : Star . 2)) })
({ * (Ref (A -> (Bool -> Unit))) , (let { C , c } = ((let { B , d } = "boy" in 2) . b) in (let a = 2 in "apple")) } as ({ Some A : (((Star => Star) => Star) => (Star => Star)) , (Ref ({ Some A : Star , C })) }))
(let e = (({ * Nat , "boy" } as C) . e) in ((fix false) . a))
(\ C : (((Star => Star) => Star) => (Star => Star)) . (inert [ (Ref (All D : Star . String)) ]))
(iszero (let { A , b } = (let { E , b } = a in true) in (b . a)))
(\ D : ((Star => Star) => (Star => Star)) . ((fix c) [ (Ref Nat) ]))
(inert [ ((\ C : (Star => Star) . C) -> (Ref Bool)) ])
(pred (pred (let d = 2 in 1)))
(succ ({ a = (ref 2) , a = (1 . b) }))
(((ref b) . b) := (fix ("boy" (if "boy" then 0 else 1))))
(fix (\ b : (String -> B) . (iszero 0)))
({ b = ({ * ({ Some A : Star , String }) , (let a = true in 1) } as (B -> Nat)) , a = ({ a = (iszero false) , b = (let c = c in true) }) })
(ref (let c = ({ e = 0 , a = b }) in (({ d = b , a = "boy" }) := "apple")))
(pred (inert [ (B (All B : Star . C)) ]))
(iszero (inert [ (Ref Unit) ]))
(if (pred (let { C , e } = ({ e = ({ * B , 2 } as C) , e = (fix true) }) in (if 1 then 2 else 1))) then (if (if (false as B) then false else (pred "boy")) then (2 := (fix c)) else (\ e : B . (a as Nat))) else ((if "apple" then "boy" else a) as ((\ A : Star . Unit) ({ c : Nat , a : B }))))
({ a = ((fix (inert [ Bool ])) [ ({ Some A : (Star => Star) , ({ b : C , b : Bool }) }) ]) , e = (\ A : (Star => Star) . (0 as (B C))) })
(((\ a : ({ b : A , e : Bool }) . (if unit then "boy" else b)) . b) [ (All B : ((Star => Star) => (Star => Star)) . (\ A : (Star => Star) . (All E : (Star => Star) . Unit))) ])
((inert [ ((C -> (A C)) ({ Some C : (Star => Star) , String })) ]) (({ * B , true } as Bool) (c "boy")))
(let d = ((false false) . b) in ({ e = (! (0 . e)) , c = (true := 1) }))
(! (let a = (succ (b [ Unit ])) in (succ "apple")))
(if (inert [ (\ E : (Star => Star) . A) ]) then ({ b = ({ * Nat , a } as Unit) , a = (ref false) }) else (\ c : ({ b : Unit , c : Unit }) . (iszero "apple")))
((((iszero 2) (let { B , c } = (iszero 0) in (2 := 1))) := ((inert [ String ]) (false c))) := ((a [ String ]) [ (All C : Star . Unit) ]))
(iszero (pred (inert [ (\ D : Star . B) ])))
(succ (fix (if ("apple" 0) then ({ * Bool , true } as Nat) else (c true))))
(! (((inert [ C ]) [ ((Ref C) -> Float) ]) [ (Ref ({ d : B , e : Nat })) ]))
({ * ((Bool -> B) ({ c : B , c : Bool })) , ({ * (All C : (Star => Star) . Bool) , (\ a : ({ Some D : Star , C }) . unit) } as (Ref C)) } as (((Ref Bool) (String Unit)) (Ref (All E : (Star => Star) . ({ b : String , b : Unit })))))
(let { D , c } = (ref (iszero (fix unit))) in ((1 unit) . b))
(pred (\ C : ((Star => Star) => (Star => Star)) . (c := ({ * B , c } as Float))))
(ref ((iszero "boy") ({ d = c , d = 1 })))
(let a = ((succ "boy") as ({ a : (All A : Star . String) , d : (\ C : Star . Unit) })) in ((ref (pred "apple")) as ((String C) (Unit -> Nat))))
(fix ((true := (\ e : Bool . true)) := (inert [ ({ Some A : Star , Unit }) ])))
(inert [ (({ a : (\ E : Star . Nat) , d : (Bool String) }) -> (String -> B)) ])
({ e = (iszero (inert [ Unit ])) , c = (succ (((succ "boy") as (Ref String)) := (iszero "boy"))) })
(fix (! (2 (1 as Unit))))
({ * (((All C : Star . String) (Ref C)) -> (All A : Star . Bool)) , (if (0 0) then (fix c) else (pred false)) } as ({ Some B : ((Star => Star) => (Star => Star)) , (C -> Float) }))
(fix (! (inert [ (Ref Nat) ])))
(inert [ ((All C : Star . (\ B : Star . B)) (All E : Star . (Bool -> Bool))) ])
(\ C : (((Star => Star) => Star) => (((Star => Star) => Star) => (Star => Star))) . ({ b = (iszero (unit [ Bool ])) , b = ({ e = ("boy" [ Nat ]) , b = ({ * Nat , 1 } as Nat) }) }))
(pred (inert [ ({ Some C : Star , Unit }) ]))
({ d = (\ c : (String Float) . (\ e : Bool . false)) , a = ((\ D : (Star => Star) . (fix 2)) as (All B : (Star => Star) . ({ d : C , c : Unit }))) })
(fix (succ (let { A , e } = c in (ref c))))
(succ (let c = (1 as A) in (\ B : Star . a)))
((fix (succ (iszero true))) := (((pred 2) := (1 as Bool)) . d))
({ d = (iszero (iszero (pred c))) , c = (succ (let c = "apple" in "apple")) })
((if (\ D : (Star => Star) . ({ e = b , e = "boy" })) then (fix (! unit)) else (pred ("apple" "apple"))) . d)
(let { B , d } = ((iszero (let { A , e } = 1 in 0)) . b) in (ref (ref true)))
({ d = ((succ (pred "boy")) as ({ Some A : Star , Nat })) , b = ((\ c : ({ Some D : Star , B }) . 0) as ({ Some A : Star , C })) })
(({ * (\ C : Star . C) , ((let d = true in 1) as Float) } as (A (\ D : Star . String))) (ref ({ b = ({ * B , 1 } as Unit) , d = "apple" })))
(succ ({ d = (\ A : (Star => Star) . ({ * (\ A : Star . A) , (iszero b) } as (All E : Star . Unit))) , a = (\ E : Star . "boy") }))
(iszero (\ A : ((Star => Star) => (Star => Star)) . (\ d : (\ E : Star . Unit) . (\ a : Float . true))))
((\ E : ((Star => Star) => Star) . ({ b = (a := a) , c = 1 })) [ (({ b : Nat , a : Nat }) ({ e : Unit , a : String })) ])
(ref (fix (pred true)))
({ d = ((succ c) (\ d : (String -> Unit) . (iszero b))) , a = ((\ A : (Star => Star) . (b as B)) := (succ (! 1))) })
(\ C : (((Star => Star) => Star) => ((Star => Star) => (Star => Star))) . (pred (succ 0)))
(iszero ({ * (All B : Star . (C Bool)) , (fix 2) } as ({ a : Bool , d : Bool })))
((succ (succ c)) (\ e : ({ b : C , a : Nat }) . (iszero c)))
(let { B , d } = ((inert [ (\ E : Star . C) ]) . a) in ({ e = (b . b) , b = ((b [ C ]) (\ E : Star . unit)) }))
(let { D , b } = (pred ({ * Float , 0 } as ({ Some B : Star , C }))) in (! (let { A , c } = (false 0) in (a := true))))
(\ C : (((Star => Star) => Star) => (Star => (Star => Star))) . (fix ((true := "boy") b)))
(succ (iszero (iszero (pred false))))
(ref ({ c = ({ a = (\ C : Star . "apple") , c = (unit as Nat) }) , d = (ref (iszero 2)) }))
(pred (({ * C , 0 } as Unit) ((fix c) as ({ Some C : Star , Bool }))))
(pred ({ * (({ Some A : Star , String }) (Ref (Nat -> Unit))) , (fix (inert [ C ])) } as (\ C : ((Star => Star) => (Star => Star)) . (\ C : Star . C))))
({ * (All C : ((Star => Star) => (Star => (Star => Star))) . (\ A : ((Star => Star) => (Star => Star)) . (\ E : Star . Bool))) , (pred (1 (\ a : C . false))) } as ({ b : ((C -> String) -> (Float -> Unit)) , a : ({ Some D : (Star => Star) , (\ D : Star . Bool) }) }))
((let { C , a } = (ref b) in (let b = ("boy" 2) in unit)) as ((Ref (Ref Bool)) -> ((Ref (A -> Nat)) -> ({ Some D : Star , B }))))
((ref (ref (unit (let { D , a } = true in 2)))) as (All C : (((Star => Star) => Star) => ((Star => Star) => Star)) . ((A -> B) (Float C))))
(\ a : ({ d : (All B : Star . Bool) , c : ({ a : (All B : Star . Bool) , b : (Float String) }) }) . (pred (! a)))
(ref (let { E , c } = (b as Nat) in (inert [ Unit ])))
((\ e : ({ Some B : (Star => Star) , ({ Some B : Star , A }) }) . (\ a : (String -> Nat) . ((fix "apple") as (All D : Star . Bool)))) := (if (let b = (let c = b in 0) in (succ b)) then (ref 1) else ({ * (\ B : Star . Bool) , 2 } as (All B : Star . Bool))))
(let e = (let { B , a } = (inert [ String ]) in ((iszero 2) := (b . b))) in (iszero (\ b : ({ Some A : Star , A }) . (succ true))))
(fix (let d = (let { A , e } = (\ B : Star . "apple") in (unit . a)) in (1 2)))
((ref (ref (0 [ Unit ]))) := (inert [ (\ C : Star . String) ]))
((iszero (c := 0)) (let d = (inert [ C ]) in ((c false) . e)))
(ref (pred (succ true)))
(\ B : ((Star => (Star => Star)) => (Star => Star)) . (\ A : (Star => Star) . (succ (inert [ B ]))))
(\ B : (((Star => Star) => Star) => (Star => Star)) . (let { A , e } = (inert [ (({ Some B : Star , Nat }) -> Unit) ]) in (! (let e = 1 in true))))
((((iszero a) "boy") (\ b : (All A : Star . Unit) . b)) as (((C -> Nat) Unit) (All A : Star . Bool)))
(\ E : ((Star => Star) => (Star => (Star => Star))) . (iszero ((ref "boy") := 0)))
(fix (if (! (succ 2)) then (pred (fix 2)) else (let { E , a } = (pred b) in ({ c = false , b = "apple" }))))
(inert [ (Ref ({ b : B , b : C })) ])
(((let { A , e } = 0 in ({ a = 2 , a = b })) (pred (c [ String ]))) := (ref (! 2)))
(\ c : (\ B : (Star => Star) . (All C : Star . String)) . (succ (! 2)))
((fix ((fix b) (if c then a else a))) := (pred (("apple" := unit) as (Bool -> Bool))))
((let { D , b } = (succ 1) in (pred true)) . b)
(pred ((({ c = 1 , e = unit }) . e) := (let e = (if "apple" then false else "apple") in (1 false))))
(fix (let { E , c } = (iszero unit) in (({ d = 1 , c = a }) as (\ D : Star . C))))
(inert [ ((A -> ({ c : B , b : B })) (\ C : (Star => Star) . ({ d : Nat , c : String }))) ])
(ref (\ a : ({ b : ({ c : C , a : (All C : Star . Nat) }) , c : (C C) }) . (\ d : (All C : Star . String) . (iszero a))))
(let { D , c } = ({ * (\ E : (Star => Star) . ({ d : Bool , b : Nat })) , ((let { C , d } = a in true) := unit) } as (All C : Star . Bool)) in (ref (pred (succ 0))))
(succ ((("apple" "apple") := ({ a = (ref "boy") , a = (a := b) })) := (ref (fix 1))))
(let a = (! (1 "apple")) in (let { A , a } = (let { D , c } = false in (b := false)) in ({ d = ({ a = 2 , c = "apple" }) , c = 2 })))
(inert [ ({ Some E : ((Star => Star) => (Star => Star)) , (({ Some D : (Star => Star) , (All A : Star . Nat) }) ({ Some C : Star , Float })) }) ])
(((({ * C , false } as B) "boy") as (({ e : C , c : (All A : Star . A) }) (\ C : Star . Bool))) as ((\ C : (Star => Star) . A) -> (\ E : Star . A)))
({ * (Ref (\ A : Star . Unit)) , ((pred (ref true)) . a) } as ((C -> ({ Some C : Star , Float })) ({ Some D : (Star => Star) , (All C : Star . Bool) })))
((iszero (\ B : ((Star => Star) => (Star => Star)) . (2 as (\ C : Star . Float)))) . b)
(pred (fix (if unit then a else "apple")))
(((ref b) . b) . c)
({ * (\ A : ((Star => Star) => (Star => Star)) . (All E : (Star => Star) . B)) , (\ D : (Star => (Star => Star)) . (ref a)) } as ({ b : (\ C : Star . String) , d : (Ref B) }))
(fix (iszero (true . e)))
(succ (succ (inert [ String ])))
(fix (\ c : (All B : (Star => Star) . ({ c : Bool , a : Float })) . ((let e = c in "apple") (inert [ A ]))))
(ref ((let b = ("apple" := "boy") in (unit as String)) := (if ({ c = 1 , b = unit }) then (a := c) else (pred b))))
(succ (iszero ((iszero b) [ (B Float) ])))
(fix (\ d : ((B -> B) Float) . (inert [ (C A) ])))
(\ B : ((Star => Star) => ((Star => Star) => Star)) . ((\ E : Star . (unit := "apple")) := ((if unit then (ref 2) else true) [ ({ c : Nat , a : (Float C) }) ])))
(! (ref (inert [ ({ a : (Ref Nat) , b : Nat }) ])))
(fix (! (\ B : Star . c)))
(let { B , e } = (\ c : ({ Some C : Star , A }) . (let { D , c } = false in (if unit then 1 else 1))) in (ref ({ * (All A : Star . Bool) , (let c = 0 in "apple") } as (Ref (\ C : Star . A)))))
(ref ((b . d) as ({ Some E : Star , (String C) })))
((\ d : ({ Some E : Star , (\ C : Star . C) }) . ("apple" := unit)) (let { B , e } = (((pred c) (let e = 2 in unit)) [ (\ A : Star . A) ]) in (\ e : String . (2 0))))
((succ (if "boy" then a else c)) (\ c : (All E : Star . C) . (let e = "apple" in b)))
((\ A : (Star => (Star => Star)) . ({ * (\ C : (Star => Star) . (\ D : Star . A)) , (pred "boy") } as ({ b : (C Bool) , d : String }))) := (iszero ((fix true) := (let { D , e } = 1 in "apple"))))
(if (iszero (succ ({ * Unit , false } as Unit))) then (pred (pred unit)) else ((let { C , d } = ({ b = 0 , a = a }) in (b [ A ])) . c))
(({ * (All C : (Star => Star) . A) , (\ c : (Ref String) . (0 . d)) } as (({ Some B : Star , Nat }) (C String))) . e)
((iszero ({ a = c , c = b })) := (succ (inert [ (Ref Nat) ])))
((\ A : ((Star => Star) => Star) . (ref (0 . e))) . b)
(inert [ ((\ A : ((Star => Star) => (Star => Star)) . ((\ C : Star . C) -> (All B : Star . String))) -> ({ Some C : (Star => Star) , (Ref Nat) })) ])
(! ((false [ String ]) as ((\ C : Star . Bool) C)))
(((let { D , b } = "boy" in true) := (inert [ B ])) (if (\ a : B . 1) then (\ b : (\ D : Star . C) . ("boy" as Float)) else (inert [ (Ref C) ])))
((fix ((b [ Bool ]) (let e = (inert [ Unit ]) in (iszero true)))) [ (Ref (Ref (\ B : Star . Bool))) ])
(iszero (\ B : (Star => Star) . ("apple" [ C ])))
(succ ((\ D : (Star => Star) . (b := b)) as (All A : Star . String)))
(pred (if (let { C , d } = "boy" in 2) then ({ c = 0 , b = "boy" }) else (ref ("boy" [ A ]))))
(\ d : ((Nat C) (\ B : Star . (All B : Star . Bool))) . (ref (ref 2)))
({ a = (\ a : (Ref (Nat B)) . (pred (ref c))) , d = (succ (\ C : Star . 1)) })
(ref ((iszero (false := true)) as (Ref (Unit -> Unit))))
(let { C , d } = ({ a = (let a = "boy" in (b [ Bool ])) , a = (inert [ B ]) }) in ((\ b : (A String) . (! ("boy" := 0))) . b))
(\ E : ((((Star => Star) => (Star => Star)) => (Star => (Star => Star))) => (Star => Star)) . (\ B : ((Star => Star) => ((Star => Star) => Star)) . (ref (unit := b))))
((succ (\ e : (String -> A) . a)) as ((Ref B) -> (All D : Star . String)))
(\ C : (((Star => Star) => (Star => Star)) => ((Star => Star) => (Star => (Star => Star)))) . ({ * ({ c : B , c : (All A : Star . Float) }) , (iszero true) } as (All D : (Star => Star) . (\ B : Star . Nat))))
({ * (({ Some E : Star , Float }) -> (String -> A)) , ({ * (\ C : (Star => Star) . ({ d : Float , c : String })) , (false b) } as (All D : (Star => Star) . (A String))) } as ((Ref A) ({ e : Unit , a : C })))
(succ (! (\ a : (Ref String) . (let { C , e } = true in false))))
(let { B , a } = (! (({ * B , "boy" } as B) as ({ b : String , d : C }))) in (let { D , a } = (let { A , e } = (ref 2) in ((let { A , d } = 1 in 2) as Bool)) in ((let e = ({ * Nat , b } as Unit) in c) [ ({ Some C : Star , String }) ])))
(pred ((fix (inert [ Unit ])) as ({ Some A : (Star => (Star => Star)) , (Ref A) })))
(ref ({ * ({ d : Nat , c : C }) , (pred (! 0)) } as ({ Some E : Star , String })))
(let e = (\ b : ({ e : ({ c : Bool , d : Bool }) , c : (All A : Star . Bool) }) . ({ * ({ Some D : Star , Bool }) , (if a then false else a) } as ({ c : String , d : B }))) in (iszero (2 as (Ref String))))
(ref (! ("apple" [ Bool ])))
(\ c : ((Ref Float) -> ({ Some E : (Star => Star) , B })) . (fix (iszero (pred b))))
(let e = (pred ((iszero 2) (ref 1))) in ((if (inert [ B ]) then false else (false := b)) := (let e = 2 in b)))
((let { C , c } = (iszero (let e = 0 in 2)) in (\ C : (Star => Star) . (false as B))) := (\ d : ({ Some C : Star , C }) . (succ ({ * Unit , 0 } as B))))
(\ E : ((Star => Star) => (((Star => Star) => Star) => ((Star => Star) => (Star => Star)))) . (\ d : (All C : Star . C) . (\ C : Star . unit)))
((fix ({ * String , 0 } as Float)) as (All A : ((Star => (Star => Star)) => (Star => Star)) . ((Unit -> Bool) String)))
(inert [ ((Ref Unit) -> (All D : (Star => Star) . (All C : (Star => Star) . (Ref C)))) ])
(if (let { B , b } = (\ E : Star . false) in (b 0)) then (\ B : ((Star => Star) => (Star => Star)) . (succ false)) else (succ (\ B : (Star => Star) . ("apple" := c))))
(if (fix (if (pred unit) then (true [ (String B) ]) else (succ 2))) then ((true [ Unit ]) (inert [ C ])) else ((let e = (inert [ Bool ]) in unit) [ ({ Some C : ((Star => Star) => Star) , (Ref (Ref C)) }) ]))
(! (let b = (false . b) in (b as String)))
(\ D : (((Star => Star) => (Star => Star)) => (Star => Star)) . (\ C : (Star => (Star => Star)) . (2 true)))
(let { D , d } = ({ * (Ref C) , (inert [ ({ Some C : Star , C }) ]) } as ({ Some A : Star , (Float Float) })) in (pred (({ c = 0 , d = b }) as (C Nat))))
(! (ref (inert [ ({ Some D : Star , Bool }) ])))
(\ c : (\ B : (Star => Star) . ({ a : Nat , b : Unit })) . (! ({ * ({ Some E : Star , A }) , (\ C : Star . false) } as B)))
(pred (({ * Nat , (true := false) } as A) := ((ref unit) as (Ref C))))
((iszero (iszero 2)) as (Ref ({ Some D : (Star => (Star => Star)) , ({ Some C : Star , Unit }) })))
({ * (({ Some A : Star , (All C : Star . Float) }) -> ({ c : ({ a : Unit , a : C }) , d : ({ a : Bool , c : Bool }) })) , ((\ b : Float . a) := (\ b : Unit . 0)) } as (Ref ({ c : ({ Some B : Star , C }) , a : ({ Some A : Star , A }) })))
(pred (let { C , c } = (let c = (b [ Bool ]) in (\ e : Nat . b)) in ({ d = (\ b : (C A) . (! unit)) , c = (inert [ B ]) })))
(let { E , c } = (fix (if ({ * Unit , 0 } as Bool) then (pred c) else (ref "boy"))) in (if (pred ("apple" . d)) then (succ (! (b 0))) else ({ a = ({ a = (iszero c) , e = 1 }) , d = (fix unit) })))
(pred ((let { C , b } = ({ * String , (pred 0) } as ({ Some A : Star , Bool })) in (if ({ * C , true } as C) then false else true)) (if false then unit else (fix "apple"))))
(if (\ C : (Star => Star) . (let { A , b } = (inert [ Bool ]) in "apple")) then (\ c : (C -> Nat) . ("apple" . c)) else ({ a = ((\ c : B . b) as (B Unit)) , e = ((false := true) . c) }))
(fix ((fix c) := (succ true)))
(iszero (((pred 0) . e) [ (Ref B) ]))
(let { E , a } = (\ A : (Star => Star) . (c unit)) in (if (fix (true . a)) then (\ D : (Star => (Star => Star)) . (inert [ C ])) else (ref c)))
((succ (inert [ B ])) . b)
(inert [ ({ Some A : ((Star => Star) => Star) , (({ Some A : Star , String }) -> A) }) ])
(\ d : ({ b : (All A : (Star => Star) . Unit) , e : (\ D : Star . Float) }) . (if (c as Float) then (pred (\ e : Bool . b)) else (succ (pred true))))
(let { D , e } = (pred ((let { E , e } = false in b) as (Bool -> String))) in ({ * ({ e : Nat , e : (\ D : Star . C) }) , (ref ((inert [ Unit ]) . b)) } as (Ref ({ Some B : Star , String }))))
(\ d : ({ a : (A -> String) , d : (Float (\ C : Star . C)) }) . (! (iszero (let { E , b } = ({ c = true , e = a }) in ({ * Nat , 2 } as Nat)))))
(iszero ({ a = ((let { C , b } = 1 in c) . e) , b = (succ (inert [ Nat ])) }))
(((fix unit) as (Ref String)) [ (((All C : Star . String) -> ({ Some B : Star , Bool })) -> ({ Some B : (Star => Star) , C })) ])
({ * (All E : (Star => Star) . ({ d : Unit , b : Bool })) , (let { D , d } = (succ ({ d = false , a = 0 })) in ((true . d) (fix "boy"))) } as ({ a : (Ref String) , c : (Ref C) }))
(! (pred (succ "boy")))
(((\ a : Float . (1 := "boy")) as (\ B : Star . String)) (fix (false [ B ])))
((let b = (if "apple" then 2 else unit) in (let c = c in b)) as (All E : ((Star => Star) => (Star => Star)) . (\ E : Star . (Float A))))
(if (if (iszero b) then (succ c) else ((\ c : String . false) . d)) then (succ (inert [ Unit ])) else ({ e = (let { E , e } = "apple" in (succ c)) , c = (ref (1 0)) }))
(if (let d = ((inert [ B ]) (fix "boy")) in (c := 1)) then ((("boy" [ Float ]) (1 := 1)) ({ c = true , c = false })) else (pred ((let a = false in "boy") as (All E : Star . B))))
(pred (! (0 as Unit)))
(if (\ D : (Star => Star) . (iszero 1)) then (inert [ (All B : Star . (Ref C)) ]) else ((iszero false) := (0 (let { C , a } = 0 in "boy"))))
((\ a : (All B : (Star => Star) . B) . (fix (let { D , d } = (let a = "boy" in false) in (let { C , a } = 1 in unit)))) := (fix ({ d = (pred ({ c = unit , d = b })) , d = ({ e = (\ c : Nat . a) , c = c }) })))
((inert [ (Ref String) ]) . e)
({ * (\ E : (Star => Star) . (Ref (B -> String))) , (fix ({ * (\ B : Star . Nat) , (let { E , e } = c in "apple") } as C)) } as ((({ Some D : (Star => Star) , (A -> C) }) (A -> Nat)) -> ({ c : (All C : (Star => Star) . (A Unit)) , a : (C -> (Float -> Unit)) })))
