\x:Bot. x
\x:Bot. x x 
\x:<a:Bool,b:Bool>. x
\x:Top. x
(\x:Top. x) (\x:Top. x)
(\x:Top->Top. x) (\x:Top. x)
(\r:{x:Top->Top}. r.x r.x) {x=\z:Top.z, y=\z:Top.z}
"hello"
unit
\x:A. x
let x=true in x
{x=true, y=false} 
{x=true, y=false}.x
if true then {x=true,y=false,a=false} else {y=false,x=true,b=true}
\x:Bool. x
(\x:Bool->Bool. if x false then true else false) (\x:Bool. if x then false else true)
\x:Nat. succ x
(\x:Nat. succ (succ x)) (succ 0) 
\f:Nat->Nat. \x:Nat. f (f x)
let x = ref 1 in {get = \t:Unit. !x, inc = \t:Unit. x := succ(!x)}
\a:Ref (Nat->Nat).\n:Nat.(!a n)
\a:Unit.ref (\n:Nat.0)
\a:Ref (Nat->Nat).\m:Nat.\n:Nat.let oldf = !a in a := (\n:Nat.if true then v else (oldf n))
\x:Sink Bool.unit
(\x:Bool->Bool.if x false then true else false) (\x:Bool.if x then false else true)
(pred (fix (! ("apple" . b))))
((ref ((< a = 0 > as Unit) := (b . c))) ((true := 1) := (< d = 0 > as Nat)))
(\ c : (Source (Ref Nat)) . (case (if b then (pred 2) else (true := a)) of < b = c > => (! b) | < d = d > => (< b = (iszero (2 1)) > as (Source Top))))
(iszero (\ c : (Sink (< e : Float , a : C >)) . (ref unit)))
(succ (pred (pred (case unit of < e = a > => false | < d = d > => "apple"))))
(fix (! ({ b = (0 false) , a = (ref 2) })))
(\ c : (Sink (Source Bool)) . (iszero (1 as Bot)))
(\ d : ({ a : (< c : (Sink Float) , b : Float >) , d : (< a : Float , d : String >) }) . (\ a : (Source Top) . (inert [ A ])))
(case (inert [ (Sink ({ d : Nat , b : Top })) ]) of < d = e > => (< e = (case ("boy" := (case "apple" of < b = e > => b | < e = e > => 1)) of < b = a > => (< b = "boy" > as String) | < d = c > => (! (< a = a > as Bool))) > as (Ref (Nat -> Bool))) | < d = b > => (< a = (case b of < a = c > => a | < b = c > => b) > as (Ref (Ref Float))))
(ref ({ d = (fix 1) , c = (ref true) }))
((iszero (ref (let c = "boy" in b))) := (inert [ ({ e : String , b : Bot }) ]))
((\ a : ((< b : Bot , c : Bool >) -> (Sink String)) . (fix b)) . b)
(((if (c := "boy") then (2 := 0) else (iszero "boy")) (b . e)) as (Ref (Sink B)))
(({ e = (case b of < b = e > => c | < a = e > => ("boy" as C)) , d = (fix (case b of < b = a > => 1 | < a = d > => 1)) }) as (Source (< c : Float , c : Top >)))
(fix (fix ((ref "boy") . b)))
(\ a : (< a : (< e : Float , d : Bool >) , a : (({ a : (Sink B) , e : Bool }) -> (Ref Nat)) >) . ((case (! a) of < a = a > => (false . a) | < c = a > => (inert [ String ])) . a))
(< d = (inert [ (< e : B , c : String >) ]) > as (Source ((< c : Bot , e : Unit >) -> (Sink Bot))))
(ref (((true . c) := (c . e)) as (Float -> Bot)))
(case (inert [ ((< e : String , e : String >) -> A) ]) of < e = b > => (if (! 1) then (fix (false := 2)) else ({ b = a , c = a })) | < a = d > => (! (1 as (Ref Unit))))
(! (\ d : ({ d : B , d : ({ d : Bool , e : Unit }) }) . (ref (case c of < a = c > => "apple" | < b = b > => "boy"))))
((\ d : (Source (Source Unit)) . (ref "boy")) := (if (\ d : Bot . 2) then (pred 2) else (fix 1)))
(! (if (fix 1) then (fix b) else (ref 2)))
(< c = (! (inert [ Nat ])) > as (< c : ({ b : Nat , e : (< b : String , c : Unit >) }) , d : ((Sink C) -> (Ref Top)) >))
((fix (! false)) := (if (iszero (2 unit)) then (2 c) else (pred (inert [ Top ]))))
({ a = (let d = (if (let b = "apple" in a) then (inert [ Float ]) else (case "apple" of < c = b > => "boy" | < d = c > => true)) in (succ (succ false))) , d = (let b = ((pred "boy") (case (< c = true > as B) of < c = a > => (fix "boy") | < c = a > => ("boy" as B))) in (pred (\ b : ({ c : B , d : Unit }) . (\ d : Unit . b)))) })
(if ((< b = "boy" > as B) . c) then (pred (let c = ({ e = "boy" , b = 1 }) in (2 . e))) else (if (fix (inert [ (< d : A , c : A >) ])) then (((ref 0) as (Ref Bot)) as (Source Unit)) else (iszero (< a = b > as String))))
(((let b = "apple" in "boy") := (pred (case "boy" of < e = d > => "boy" | < b = b > => 0))) (ref (\ e : Unit . b)))
(case (let d = (< a = 2 > as (Sink B)) in ({ b = 0 , a = unit })) of < c = a > => (inert [ (Source A) ]) | < e = d > => (! ((succ b) := true)))
(! (inert [ (Ref C) ]))
(succ ((iszero 2) as (Ref (< a : Nat , c : (B -> A) >))))
(((< b = "boy" > as Bool) (true as Bool)) as (Ref (Ref Top)))
(ref ((\ a : (< a : String , c : Bool >) . (iszero 2)) as (Sink (< c : ({ c : Float , d : Bool }) , e : (Ref Bot) >))))
((succ ((1 . a) := ({ e = "apple" , e = false }))) as ((String -> Float) -> (Source Float)))
((succ (succ ("apple" . d))) (\ c : ({ c : (Sink Bool) , d : (Sink Top) }) . (! a)))
({ a = (succ ((if "apple" then true else true) . d)) , d = ((< a = a > as Top) (let c = (true . d) in a)) })
(case (pred (< d = "apple" > as (Sink String))) of < c = c > => (< d = (unit . d) > as (Ref A)) | < b = a > => ((iszero ((inert [ Nat ]) := (case c of < a = c > => true | < d = a > => "boy"))) := (a as (Source A))))
(! (if (! 1) then (succ true) else (inert [ Nat ])))
(succ (case (\ b : Unit . (< a = c > as Nat)) of < b = e > => (\ a : (B -> Unit) . (iszero true)) | < b = e > => (fix 2)))
(succ (let d = (\ e : (B -> String) . (ref b)) in (2 := true)))
(if (let e = (fix a) in (ref unit)) then (fix ((pred a) := (\ e : Unit . false))) else ((let d = a in c) . b))
((let a = (case (< a = "apple" > as Float) of < a = d > => (unit as Nat) | < b = b > => (! (unit 2))) in (fix (pred "boy"))) (let c = (iszero (1 . c)) in (pred (ref c))))
(< e = (fix (let d = (pred 0) in 1)) > as (Ref (< a : (< c : (Top -> C) , d : (Source A) >) , d : (Ref (Float -> C)) >)))
(< b = (if (if (if (2 true) then (succ c) else unit) then (iszero 0) else (if b then true else 1)) then ((< e = 0 > as A) := 2) else (inert [ (Source Top) ])) > as (Source (< d : (Unit -> Bool) , a : (Ref A) >)))
(inert [ ({ d : (Source (Ref String)) , d : (Source Bool) }) ])
(case (inert [ (Source (Ref Bool)) ]) of < c = e > => (ref (! "boy")) | < a = c > => (({ c = (inert [ B ]) , d = (fix 1) }) . a))
(if (\ b : (Ref Top) . (let e = true in (iszero 1))) then (({ b = b , e = b }) as (< b : Top , a : B >)) else (inert [ (< d : (String -> Bot) , c : (Source (Ref C)) >) ]))
(iszero (pred (pred (let e = unit in 2))))
(< a = (pred (ref (succ "boy"))) > as (Source (< b : (Ref Float) , d : (< a : Top , b : C >) >)))
(succ (if (inert [ C ]) then (iszero 1) else (unit ({ e = "apple" , e = 0 }))))
(case (succ (\ a : Float . (if true then "boy" else 1))) of < a = d > => (case (case (\ d : Bool . unit) of < d = b > => (inert [ B ]) | < d = a > => (succ "boy")) of < b = d > => (succ (iszero "boy")) | < c = d > => (fix (true 0))) | < b = d > => (iszero (inert [ Bool ])))
(ref ((pred false) . b))
(\ c : (Ref (A -> A)) . ((inert [ (Source Bool) ]) as (Top -> ({ d : Top , b : A }))))
(iszero (< d = (pred (let c = "boy" in "apple")) > as (Sink C)))
(succ ((< e = (true "boy") > as Nat) ((pred (inert [ B ])) (iszero (pred unit)))))
(succ (fix (pred (pred 2))))
(fix (pred (inert [ Bot ])))
(fix (inert [ ({ e : Bot , a : (Ref Bool) }) ]))
(let e = (succ ({ e = unit , d = 1 })) in ((fix (inert [ String ])) (fix 1)))
(succ (if (fix 2) then (("apple" . c) as ((Ref String) -> Top)) else (fix (succ 1))))
(pred ({ a = (\ d : Bool . (iszero "boy")) , a = (case 1 of < c = a > => (iszero b) | < e = c > => "boy") }))
(< a = ((if (2 "apple") then b else b) as (Float -> Nat)) > as ((< e : B , d : Unit >) -> (Sink Top)))
(! (pred (! (inert [ B ]))))
(fix (pred (\ a : (Source String) . 0)))
(case (\ d : (Sink (< e : String , b : String >)) . (< b = (case false of < c = c > => b | < b = b > => unit) > as (Nat -> (Source Bool)))) of < e = e > => (< a = ((pred "apple") . b) > as (Sink Unit)) | < b = c > => ({ e = (< b = (let e = unit in a) > as ((Sink Unit) -> B)) , b = (ref true) }))
(\ e : (Source ((Float -> Top) -> (Ref Bot))) . (iszero (succ (\ d : B . (\ d : C . c)))))
(iszero (if (case ("apple" as Bot) of < c = b > => (true "apple") | < a = a > => (if 2 then b else a)) then (! 0) else (pred false)))
(< e = (ref (< e = "apple" > as ({ e : Bool , e : Bot }))) > as ((Top -> C) -> (< b : String , e : Unit >)))
(< e = (ref (succ b)) > as (Source (Sink Bool)))
(ref ((b a) . e))
((succ ((inert [ Top ]) (< a = c > as Bool))) := (< b = (! (\ e : ({ b : A , e : Bot }) . (case false of < c = a > => c | < b = a > => b))) > as (Sink (Sink (Ref A)))))
(< a = (! ((! a) as Float)) > as ({ e : (Sink Float) , e : (< d : Top , e : Bool >) }))
(((fix (true := 2)) . d) := (< b = (0 as Top) > as ({ a : B , c : String })))
(((inert [ ((< d : Bot , c : Top >) -> Nat) ]) as (Sink ({ c : C , d : C }))) := ((({ d = c , d = unit }) . b) := (a := (fix c))))
(ref ((if (< a = true > as B) then (\ a : (Ref Unit) . (case "apple" of < b = a > => true | < e = e > => a)) else (! "boy")) ((pred c) . c)))
((\ c : (Bot -> Float) . (let d = (2 "apple") in (if true then "apple" else a))) . d)
({ d = ((inert [ (Sink (Float -> Nat)) ]) . d) , a = (((< d = (succ unit) > as ({ e : Float , a : Bool })) as (Sink (Sink Bool))) (pred (iszero c))) })
(pred (case (fix (! ({ b = c , d = false }))) of < e = c > => (pred (if unit then (inert [ A ]) else ("apple" c))) | < c = d > => (iszero (\ b : C . (fix a)))))
((let c = (ref (< e = true > as B)) in (case (ref false) of < c = b > => ({ b = (< c = true > as Unit) , c = true }) | < e = b > => (let e = a in (let e = c in "boy")))) := (pred (< c = (false . a) > as (Source Bot))))
(case (iszero ((ref "boy") := 0)) of < e = e > => (ref (pred false)) | < b = a > => (({ a = "boy" , b = 2 }) . c))
((inert [ ({ b : A , c : String }) ]) . a)
((fix ("apple" as Bot)) as ((< b : (< b : C , d : A >) , e : ({ d : (Ref C) , e : (Source Unit) }) >) -> (Source (Sink ({ d : Bot , c : Bool })))))
(if ((< d = a > as A) as (< e : (Source A) , d : (({ d : Top , d : B }) -> C) >)) then (case (fix 0) of < b = d > => (\ e : (Sink Float) . a) | < a = e > => (iszero false)) else (\ d : (Ref (Source Unit)) . (fix 1)))
(if (case (iszero a) of < e = e > => (inert [ C ]) | < c = d > => (iszero false)) then (succ (unit as Bot)) else (< e = (fix (ref 2)) > as ((Ref B) -> ({ d : A , d : Unit }))))
(! (fix (< c = 0 > as Unit)))
(< d = ((succ (false false)) as (Bool -> B)) > as (Ref (Source (Sink String))))
({ b = ((let a = false in (0 true)) := (ref 0)) , e = ((2 . a) as (Ref String)) })
((fix (succ true)) as (Source ({ c : Top , d : Bool })))
(< d = (iszero (inert [ Bot ])) > as (Ref ({ b : (Ref Bool) , d : (Sink Bot) })))
(if (inert [ (Unit -> Unit) ]) then ((let e = (if unit then 2 else unit) in (\ b : String . true)) (\ a : Bot . (pred 2))) else ((iszero a) ({ a = "boy" , c = c })))
(case (fix (let b = (< d = 0 > as A) in (\ e : Nat . b))) of < b = d > => ((unit as C) (2 := 1)) | < e = b > => (pred (< c = ("boy" := 2) > as (Bot -> Bool))))
(({ e = ({ c = 1 , e = false }) , b = (< a = (succ 0) > as Nat) }) as (Sink (Ref Bot)))
(ref (< d = (let e = b in a) > as (Nat -> Float)))
(fix (< a = ((unit := "apple") . d) > as (< e : (Sink Unit) , b : ({ a : Bool , a : Bot }) >)))
((< c = (false := b) > as (Sink ({ e : Float , e : Unit }))) := ((2 as (Ref Bool)) := ((fix a) as String)))
(iszero ({ d = ("apple" . b) , e = (let b = b in b) }))
((! (ref 0)) := (< a = (succ (let e = 1 in 0)) > as (Float -> Float)))
(ref ({ d = ((if c then c else 2) as Top) , e = ((fix true) := (< d = "boy" > as Float)) }))
(succ ((case (true := (if true then "apple" else false)) of < a = d > => (< a = (unit . e) > as ({ a : B , c : Nat })) | < d = a > => (iszero (! "boy"))) (inert [ (Source String) ])))
(! (succ ("boy" . d)))
(((< b = ({ c = (< a = c > as Bot) , c = false }) > as (Sink Top)) := (case 2 of < a = e > => (true as Top) | < a = c > => (< e = 2 > as Unit))) . e)
(succ (if (iszero a) then (case (case 0 of < a = c > => "boy" | < d = b > => 1) of < d = c > => c | < a = c > => ({ d = true , e = "boy" })) else (inert [ (Sink Nat) ])))
(((if (\ a : String . 0) then ({ d = b , e = "apple" }) else 2) ({ e = (< a = true > as String) , e = a })) as ({ d : ({ d : B , e : B }) , a : (Source (Sink C)) }))
({ b = (ref (1 := b)) , b = (pred (ref (let b = "apple" in a))) })
({ c = (case (< d = (\ d : C . a) > as (Sink Unit)) of < a = d > => (case (! b) of < b = d > => (fix a) | < b = d > => (< b = "boy" > as String)) | < d = e > => ((let b = unit in b) as (Sink A))) , e = (case (\ c : Top . a) of < c = d > => ({ d = (false a) , b = (< b = unit > as Float) }) | < c = a > => (succ (! unit))) })
(case (if (inert [ Top ]) then (unit := 1) else (let b = (pred a) in a)) of < d = a > => ((fix (case "boy" of < b = b > => 1 | < d = b > => 0)) (inert [ String ])) | < c = e > => (\ d : ({ a : C , e : B }) . (\ d : (Ref String) . (2 as Bot))))
(inert [ (Ref (Sink Top)) ])
(pred (ref (ref unit)))
((succ ({ e = (iszero b) , c = (fix 0) })) as (Source ({ c : ({ c : Bot , e : Top }) , c : B })))
(pred ({ e = (ref unit) , a = (fix (iszero unit)) }))
(succ (let a = (\ e : (Source (Top -> A)) . (inert [ Nat ])) in (inert [ (Ref A) ])))
(fix (inert [ (Ref ({ c : Top , e : A })) ]))
((fix ({ b = "apple" , a = false })) as ({ e : (Sink String) , d : (Ref (B -> Bool)) }))
(if (let d = (iszero 0) in (a := (let d = unit in "apple"))) then ((pred (ref b)) as (Sink (Source B))) else (\ d : (A -> Top) . (if ("boy" . e) then (2 false) else (true false))))
(iszero ((let c = (case b of < c = b > => "apple" | < a = c > => 1) in (iszero a)) . a))
(pred ((unit ("apple" := 0)) as (Source ({ e : Top , c : A }))))
(\ c : ({ e : ({ c : Bool , a : B }) , e : (Sink C) }) . (fix (false . a)))
((((true := c) as ({ a : Unit , a : C })) . e) (iszero (if b then "apple" else a)))
(\ b : (Source ({ a : Bot , c : C })) . (fix (0 := 1)))
(inert [ (Sink ({ d : Bool , e : String })) ])
(! (case (fix (case c of < c = d > => c | < a = e > => c)) of < a = d > => (\ c : A . c) | < e = c > => (c := false)))
(if (inert [ (Ref C) ]) then (let a = (succ "apple") in (({ b = (! a) , b = (false c) }) (let b = (false as Bool) in (b . c)))) else (iszero (({ b = "boy" , d = b }) a)))
((case ((< a = "apple" > as String) . e) of < e = d > => (inert [ (< b : Nat , c : Bot >) ]) | < b = d > => (ref c)) := (fix ((< a = c > as B) (succ false))))
(case (! (a 2)) of < a = c > => (\ d : (Source (Source (Ref Unit))) . ({ c = (true as Nat) , e = true })) | < b = e > => ((succ (b . d)) as (< e : C , b : (Ref B) >)))
(! (fix ((! 1) := b)))
(\ c : ((Sink (Nat -> String)) -> (Ref Nat)) . ((iszero (< d = 1 > as String)) as (Source (Ref Float))))
(succ ((succ true) := (a "apple")))
(fix (case (let d = true in unit) of < e = d > => (1 := b) | < e = c > => (let c = 0 in "apple")))
(case ((succ a) (({ b = false , a = 0 }) as (Sink B))) of < d = b > => (iszero ((ref a) . e)) | < d = a > => (case ((true as String) as (< e : String , d : Unit >)) of < a = c > => (iszero unit) | < c = e > => ((iszero false) . b)))
(iszero (< c = ((c . e) . d) > as (Sink A)))
(let c = (fix (inert [ A ])) in (inert [ ({ c : C , c : B }) ]))
(ref (iszero (((iszero b) := (0 := b)) . b)))
(< a = (\ b : (Sink (Source ({ b : Bot , a : Nat }))) . (succ (succ false))) > as (Ref (Ref Nat)))
(fix (let b = (< e = (ref c) > as ({ a : Nat , d : B })) in (< c = (\ c : String . true) > as Bot)))
(! ((succ (inert [ Bool ])) (ref 2)))
(let a = (ref (pred "boy")) in (if (< c = 2 > as Bool) then (inert [ (Ref Bool) ]) else (pred (< b = (fix "boy") > as (Nat -> Top)))))
(fix (case (true as Bot) of < e = d > => (\ c : (Sink Bool) . (ref unit)) | < d = b > => ((1 unit) . e)))
(inert [ (< a : (Ref Nat) , a : (< a : Nat , e : Top >) >) ])
((pred (let e = 1 in (let b = c in 2))) (let d = ((! b) := (ref true)) in (inert [ Unit ])))
(if (pred (succ (let a = ("boy" as Float) in 2))) then (inert [ (< d : (Ref B) , d : (Sink Float) >) ]) else (succ (if ({ c = 1 , e = true }) then true else (true as A))))
((iszero ((ref 1) . d)) as (Source ({ a : (Sink B) , d : ({ c : Bool , e : String }) })))
(({ a = (let d = b in 0) , c = (! (\ a : Top . b)) }) as (< a : (Ref (Sink Bot)) , d : (Bot -> Top) >))
((inert [ (Sink (Ref B)) ]) as (Ref (< c : A , d : Bool >)))
(case ((pred a) := ({ c = c , a = b })) of < d = a > => (fix (unit a)) | < c = e > => (succ (let c = (inert [ C ]) in (\ c : Nat . 0))))
(inert [ ({ b : (Ref B) , a : (Ref (Source Bot)) }) ])
(fix (if (iszero ({ c = true , c = true })) then (if 1 then ("apple" := true) else (! 0)) else (if true then true else (if 2 then a else 0))))
(iszero ((inert [ (Ref A) ]) as (Ref Nat)))
(let c = ((ref (b as Float)) := (iszero "apple")) in (let c = (((inert [ C ]) . a) as (Sink (Source String))) in ((iszero 0) (fix "boy"))))
(({ a = ((< a = b > as Nat) as (String -> Unit)) , a = ("boy" as (< e : Unit , d : Float >)) }) := ((\ a : (Ref Top) . (iszero false)) (succ (unit := unit))))
(fix (\ e : (< c : ({ a : B , d : Nat }) , e : (Sink Nat) >) . (ref (case true of < e = a > => b | < d = a > => b))))
(ref (< a = ((b . a) as ((Ref Bot) -> Nat)) > as (Source (B -> B))))
(iszero ((case (2 := "apple") of < e = d > => (let d = (! unit) in (case "boy" of < d = d > => true | < c = c > => 0)) | < a = c > => ((fix c) 2)) as (A -> A)))
(pred (ref ((succ 1) . a)))
((if (< b = "boy" > as Float) then (! (\ c : Float . true)) else ((< c = b > as Nat) . a)) := (pred (if (let d = 1 in c) then (2 as ({ b : Bool , e : Bot })) else (pred c))))
(fix (pred ((let e = 2 in "apple") := unit)))
(< b = (< b = (! (if 2 then 1 else unit)) > as (Ref Unit)) > as (Source (Source Unit)))
(\ c : (< c : (Source Bool) , a : (Source (< d : B , c : Nat >)) >) . (inert [ ({ a : (< d : Float , e : Bool >) , a : (Source A) }) ]))
({ c = (iszero (let e = unit in 0)) , d = (pred (\ b : Unit . (b := b))) })
(! ((if (let e = c in a) then (! "boy") else unit) ((\ a : C . true) as (Unit -> Top))))
({ a = (fix ((ref (succ 0)) := (! ({ a = c , b = 2 })))) , c = (\ e : (Sink B) . (ref unit)) })
(succ (inert [ (Sink Float) ]))
(! (({ d = c , c = b }) as (Sink (Source A))))
(iszero (if (if true then a else 1) then (inert [ (< d : Top , d : A >) ]) else (\ b : B . "apple")))
(pred ((case false of < e = c > => (\ c : Bool . b) | < e = b > => (succ 0)) . e))
(ref (case (let d = "boy" in unit) of < b = b > => (iszero (succ a)) | < c = c > => (case false of < b = b > => unit | < a = e > => b)))
(((ref (if a then 0 else false)) := (iszero (b unit))) . c)
(! (inert [ (Ref Nat) ]))
(! (! (succ (pred b))))
(succ (({ d = true , a = (b a) }) as (Source (Sink Bot))))
(< d = ((iszero (inert [ Bot ])) := (case (< d = true > as Float) of < b = e > => (let c = a in 0) | < e = c > => ("boy" false))) > as (< c : (Sink (Bot -> Top)) , d : (Ref (Source Top)) >))
(({ b = (case ((1 as C) := (! 0)) of < d = e > => (\ c : Nat . true) | < e = b > => (0 unit)) , c = (\ b : Bot . 0) }) (ref (let d = (pred c) in (< d = "boy" > as (Float -> Top)))))
(< a = (fix (({ c = 2 , e = 1 }) (inert [ Bot ]))) > as (Sink (Sink ({ d : Bot , b : Float }))))
(let b = (case (unit ({ b = "apple" , a = 0 })) of < e = d > => ((succ (let c = false in "boy")) (< c = false > as Bot)) | < e = b > => (succ (succ false))) in (iszero ({ d = (\ c : B . 0) , b = (let b = false in 1) })))
(! ((b as String) as (Sink (A -> Bot))))
((let e = ((fix false) := (ref (pred b))) in (if (let c = true in true) then (pred unit) else (! "apple"))) := (< e = ((b := 2) . b) > as (Source Top)))
(if (succ ({ b = b , c = b })) then (< a = (inert [ Unit ]) > as (B -> (Ref String))) else (((2 as C) true) := (< a = true > as A)))
(< e = (pred ((iszero "apple") := false)) > as ({ c : (A -> (Ref A)) , d : ({ d : (< a : Float , a : Float >) , d : Float }) }))
({ d = (if (let b = c in false) then (let c = b in b) else (pred c)) , a = (ref (\ b : (Source Nat) . a)) })
(fix ((if (\ c : Unit . 1) then a else ({ a = true , e = "boy" })) as (Ref (Sink (< b : Nat , c : B >)))))
(if (< c = ((succ a) (if 1 then b else "boy")) > as ({ b : Float , c : (Source Nat) })) then (if (succ b) then (fix c) else (let a = false in 1)) else ((let c = (! unit) in ("apple" 1)) := (fix c)))
((pred (iszero "boy")) ((ref (fix false)) as (Source (Source Bot))))
(let c = (\ a : (Bot -> (Sink Nat)) . (if b then c else true)) in (! (iszero ((let b = "boy" in "apple") (true . b)))))
(succ (! (inert [ Float ])))
(iszero (ref (succ 1)))
(< b = (({ b = "boy" , e = c }) := (iszero a)) > as (< b : (Ref Bot) , a : (Sink (Ref String)) >))
(\ a : (< d : ({ c : (Ref A) , c : (< c : A , c : Bool >) }) , e : ({ d : Unit , d : (Ref Bot) }) >) . (case (fix (1 "apple")) of < e = d > => ((iszero unit) (\ e : Top . "boy")) | < b = c > => (iszero (iszero true))))
(< d = ({ a = ((case 1 of < d = c > => c | < b = d > => c) . d) , d = (case (ref 1) of < e = d > => false | < b = d > => (if a then "apple" else 0)) }) > as (Source (Source (Ref Bool))))
((iszero ({ e = (let a = a in c) , a = "boy" })) as (Ref (((Source Nat) -> Unit) -> (Sink C))))
(({ b = (! (succ 0)) , a = (ref "apple") }) as (Source ((Sink Bool) -> ({ c : C , b : Top }))))
((case (! (iszero "apple")) of < e = b > => (succ (ref c)) | < d = b > => (! (2 as (Sink B)))) . c)
((inert [ ({ e : (Ref (< d : A , b : Unit >)) , e : (Bool -> Bot) }) ]) . c)
(case (! (((case 1 of < c = b > => c | < c = a > => "boy") c) (iszero a))) of < e = d > => (\ a : (Ref (< b : Top , c : Bool >)) . (\ d : (Sink Nat) . false)) | < c = c > => (let a = (if ({ a = 1 , d = true }) then (unit as String) else (iszero true)) in (pred (fix c))))
((({ d = (unit true) , a = c }) := ((case c of < d = a > => ({ c = b , b = "boy" }) | < a = d > => 0) := (succ (succ a)))) := (pred (inert [ (Unit -> Bool) ])))
((iszero (iszero ({ c = 0 , a = 0 }))) as (Ref (Source (Source Float))))
((let b = (\ c : A . a) in (let c = false in "boy")) := ({ a = (! b) , c = ({ a = 1 , a = 2 }) }))
(fix (\ e : ((Ref String) -> Top) . (true a)))
(\ a : (< c : (< c : A , c : B >) , a : (< e : B , c : (< c : Nat , e : Bool >) >) >) . (pred (iszero b)))
(fix (let e = (inert [ C ]) in (succ a)))
(inert [ (Source ({ c : (Bot -> A) , a : (Float -> String) })) ])
(pred (! (ref ("boy" false))))
(case (iszero (ref (if false then 1 else true))) of < c = b > => ((c . a) as ({ c : A , c : Unit })) | < d = c > => ((inert [ (Float -> (C -> C)) ]) . c))
(fix (succ ((fix 0) := (iszero (pred unit)))))
({ d = (fix (unit := (! false))) , d = (inert [ (Source C) ]) })
(let e = (let e = (\ b : ({ c : C , c : Bot }) . (let b = c in "apple")) in (< e = (if c then true else 0) > as Nat)) in (if (< d = (fix true) > as ({ d : (Ref A) , d : (A -> String) })) then (a as A) else (! (c . c))))
(< b = (if (! (true := (iszero c))) then (! (case unit of < a = d > => 1 | < b = a > => true)) else (inert [ (Sink String) ])) > as (Ref (Sink (< c : (Float -> C) , e : Float >))))
(pred (let b = (c := 0) in (if (fix "apple") then a else true)))
(if ((2 ("apple" as Bool)) (pred 0)) then ((let b = 0 in false) as (Source (Source String))) else (succ ((pred (a . d)) (inert [ (Ref Bool) ]))))
(! (let a = (pred (case c of < c = b > => 0 | < d = d > => 1)) in (let d = (if c then 2 else true) in (ref "apple"))))
(< c = ((iszero unit) (inert [ A ])) > as (Source (< d : (Nat -> Bool) , a : (< b : Bool , d : String >) >)))
(inert [ (Sink ((< d : Unit , a : String >) -> (Bool -> Bool))) ])
((pred (case (fix a) of < a = c > => 2 | < c = e > => "boy")) := (((fix false) . d) (inert [ (Bool -> Unit) ])))
(if (! (true := (ref true))) then ((! (iszero "apple")) as (< e : (Sink C) , e : ((Ref Top) -> Unit) >)) else ((a (< a = c > as Bool)) as (Source B)))
((succ (let c = (< d = 1 > as C) in true)) as ((Sink B) -> (Sink (< c : Nat , c : Nat >))))
(fix (fix (if false then false else unit)))
((pred (fix (true as Float))) as ({ d : ({ c : (Ref Unit) , c : (Sink Float) }) , b : (({ e : Float , a : C }) -> (Top -> C)) }))
(! (case (unit unit) of < c = b > => (case 1 of < b = e > => 2 | < e = e > => "apple") | < c = c > => (succ a)))
(< b = (! (! (iszero 1))) > as (Sink (< c : (Unit -> Nat) , a : (Sink String) >)))
(ref (! (if 2 then (iszero 2) else (if unit then a else true))))
(inert [ (Source (C -> C)) ])
(succ (< e = (fix b) > as (Source Float)))
(let c = ({ a = (< e = c > as Bool) , b = (ref unit) }) in ((! "boy") (inert [ A ])))
(if (pred (iszero (let c = true in a))) then (< b = (fix false) > as ({ a : Nat , b : (String -> Bot) })) else (\ c : (Source Nat) . (inert [ ({ c : (Ref B) , b : Unit }) ])))
(({ e = (fix ("apple" as Bot)) , b = (< e = 1 > as Nat) }) as (Source (< e : Unit , e : Float >)))
({ d = ((ref b) := (< d = false > as Float)) , a = ((unit := unit) := (< c = (fix a) > as (Ref Bot))) })
({ a = (fix (a 0)) , d = (pred (! "apple")) })
(let a = ((\ d : B . unit) (if false then "boy" else b)) in (pred (let d = (let c = (! "apple") in b) in ({ c = false , e = unit }))))
(< c = (let b = (< b = (inert [ String ]) > as (Ref String)) in (pred "boy")) > as (Ref (Unit -> Top)))
(pred (\ b : ({ e : Bool , b : Top }) . (false := "apple")))
(let a = (pred (let e = ((let c = 0 in 0) . c) in (ref "boy"))) in (fix (fix false)))
(\ b : (< e : (< c : ({ e : Unit , e : B }) , c : (Ref Top) >) , c : (< c : Top , c : Top >) >) . (((< d = unit > as String) (pred false)) . e))
(! (if (case 2 of < d = e > => 1 | < e = e > => true) then (iszero 1) else (let e = unit in 1)))
((inert [ (< d : (Sink Nat) , b : (< c : Top , b : Unit >) >) ]) as ({ d : ({ b : (< b : Top , a : Unit >) , c : (Nat -> ({ c : String , d : C })) }) , a : (< e : (Sink ({ e : B , d : C })) , e : (Sink Top) >) }))
(if (succ ((case a of < a = b > => a | < d = d > => 0) . d)) then (((1 . b) := true) := (inert [ A ])) else ((fix (if "apple" then "boy" else b)) (if false then b else "boy")))
(iszero (pred (let e = (inert [ Nat ]) in (b . d))))
(fix ((({ e = true , a = false }) "apple") (inert [ ({ a : String , e : C }) ])))
(((\ d : (B -> Bot) . "boy") . b) . d)
(pred (< e = ({ e = (pred false) , c = (\ a : B . 1) }) > as ({ a : (Nat -> Float) , c : Unit })))
(case (succ (a := b)) of < a = b > => (let a = (unit as Unit) in (case a of < d = a > => true | < d = c > => "boy")) | < d = b > => (iszero (("boy" := b) ({ c = false , d = b }))))
(inert [ (Source (Ref Unit)) ])
(succ ({ e = (succ unit) , a = (iszero 0) }))
(fix (pred (ref (1 b))))
(succ (! ((< b = a > as String) (2 as Unit))))
(succ (case (inert [ Unit ]) of < e = a > => (! true) | < b = a > => (pred b)))
(< a = (\ c : (Sink (< a : Float , a : Top >)) . (< e = b > as Bool)) > as (Source (Ref C)))
(ref ({ d = (succ (ref (< a = b > as Float))) , b = (inert [ ({ e : Nat , e : Float }) ]) }))
(iszero (succ (case (fix c) of < c = b > => (ref "boy") | < a = e > => "boy")))
(((succ ("boy" "boy")) := ((a := (case 0 of < b = c > => 0 | < d = c > => "apple")) := (iszero (if 1 then false else "apple")))) . b)
(inert [ ((Source C) -> (Sink Unit)) ])
(fix (inert [ (Ref ({ e : Bot , d : Nat })) ]))
(((iszero b) := (b a)) as ((< e : Top , a : A >) -> (Ref C)))
({ e = (((ref (ref 1)) (< b = (let e = "boy" in 1) > as Bot)) . c) , e = (let b = (< a = "apple" > as B) in (succ false)) })
(< c = ({ d = ("boy" . e) , d = (let d = (if "apple" then true else "boy") in (< c = c > as Top)) }) > as ({ d : (Sink (Sink Unit)) , d : (< b : (Bot -> Unit) , d : (Source Float) >) }))
(ref (! (case (0 2) of < a = e > => unit | < c = d > => 1)))
(succ (succ (succ "boy")))
(\ d : ({ d : (< d : B , b : Unit >) , e : (< e : (< e : Bool , d : Nat >) , c : A >) }) . (case (iszero 0) of < d = b > => (pred b) | < b = b > => (case (! 0) of < d = a > => (inert [ Float ]) | < b = d > => unit)))
(inert [ ((({ e : Float , a : C }) -> (Source Top)) -> (< a : (Ref (Sink Float)) , c : ({ a : C , b : Nat }) >)) ])
((if (inert [ (A -> (Sink Unit)) ]) then (pred (ref b)) else (ref (b as (Ref C)))) . a)
((succ (fix 1)) ((case 2 of < c = a > => (let b = 2 in c) | < e = b > => (fix 1)) ({ e = a , d = "apple" })))
(pred (succ (fix (< e = 2 > as (Ref Top)))))
(let b = (! (inert [ Bot ])) in ({ c = ((succ c) . a) , a = (\ d : (Source Top) . (case 0 of < b = c > => "apple" | < a = a > => true)) }))
((\ e : (Source Nat) . (pred false)) := (if ({ b = 2 , e = false }) then (! "apple") else (let a = (case "boy" of < b = b > => a | < c = a > => b) in (case unit of < a = a > => unit | < a = a > => "boy"))))
(case ((ref (ref 2)) . b) of < b = b > => ((case (true as Bool) of < c = a > => (ref 2) | < c = e > => (< d = b > as Unit)) := (case 2 of < c = e > => true | < c = d > => (iszero false))) | < d = c > => ((! 0) . a))
(< c = (! ((! false) (< a = "apple" > as C))) > as (< a : (Source Float) , c : (Sink Top) >))
(\ a : ((Sink ({ a : C , e : A })) -> (Source (Source Top))) . ({ d = (pred (true as Bool)) , c = (ref 0) }))
(< a = ({ c = (! 2) , b = ((succ b) as (< d : Nat , d : B >)) }) > as ({ a : (Sink (Source Bool)) , d : (< a : Unit , c : Top >) }))
(ref (\ b : (< e : (Ref A) , e : (Source Bot) >) . (! (ref a))))
(ref ((inert [ (Sink A) ]) . b))
(pred (fix ((if true then unit else a) . b)))
((iszero (case (pred ("boy" as Top)) of < c = c > => (< b = 0 > as String) | < c = c > => (inert [ (< b : C , a : Unit >) ]))) as (Source ({ d : (Source Bot) , b : (Ref Top) })))
(let e = (inert [ (< c : Nat , c : Bot >) ]) in (let e = (fix unit) in (ref (iszero "boy"))))
(((case true of < e = a > => 2 | < b = b > => c) as (Source (Nat -> A))) := (let e = (let c = (false . d) in "boy") in ({ e = a , b = 2 })))
(let c = (case (c . d) of < d = a > => (inert [ Nat ]) | < c = a > => (if "apple" then "apple" else "boy")) in ({ a = (fix (\ b : Float . unit)) , e = (case (fix 1) of < d = e > => ("apple" := false) | < d = b > => (succ false)) }))
(succ (fix (let b = ("apple" . a) in (fix c))))
((case (fix 0) of < b = e > => (! 1) | < b = c > => (2 := c)) := (fix (({ a = 0 , b = false }) false)))
((ref (fix (succ "boy"))) as (Sink (Sink Unit)))
(\ a : (Sink (Sink (Unit -> String))) . ((! (case "apple" of < e = a > => c | < b = c > => "apple")) as (Ref Float)))
(inert [ (Ref (Ref Bool)) ])
((((let a = false in 2) (let a = false in c)) := (pred (let e = 0 in (inert [ Unit ])))) as (Source (Source (Ref B))))
((\ a : (Source A) . (fix c)) . e)
(< e = (\ c : ({ c : Bot , e : C }) . (1 as C)) > as ({ c : (Ref (Unit -> Bool)) , a : ({ a : Float , b : Float }) }))
(case (fix (\ c : (Source String) . 0)) of < c = b > => ((\ d : String . 0) as (Sink Bool)) | < a = c > => (pred (let a = false in 0)))
((\ e : (Source Bot) . (c := b)) as ((Sink ({ c : Float , d : Unit })) -> (Source (Sink Bool))))
(((("boy" 1) unit) as (< b : (Source B) , d : ((B -> A) -> (Ref Nat)) >)) := ((! "apple") as (Bot -> A)))
(ref (ref (< c = false > as String)))
(inert [ (Source (({ e : Nat , d : Bot }) -> (Source Unit))) ])
({ c = (< e = (< d = a > as Unit) > as (Source (Bot -> Float))) , c = (if (case "boy" of < c = a > => 1 | < e = c > => ("boy" . e)) then (ref (\ a : A . true)) else (succ true)) })
(((\ e : (< c : Bot , a : Unit >) . unit) := (fix 1)) . e)
((if ((inert [ Unit ]) as Top) then (case 1 of < a = b > => unit | < d = a > => 1) else (succ 2)) . a)
(iszero (inert [ (Sink Bool) ]))
(\ c : ((Sink Bool) -> (Top -> B)) . ((succ ({ e = ({ d = true , e = a }) , c = (0 . d) })) := (if (fix a) then (0 as (Sink Bool)) else (pred c))))
(! (! (\ e : (String -> Bot) . (0 as Float))))
({ d = (< b = (let e = c in (iszero 2)) > as ({ b : Top , c : Nat })) , c = (pred ("boy" := false)) })
(iszero ((! (1 . c)) . d))
({ e = ({ b = (succ (< a = unit > as Bot)) , d = ({ e = (\ d : B . 0) , e = (ref true) }) }) , d = (! (case c of < e = e > => (ref 2) | < b = c > => true)) })
(fix ((({ e = "boy" , e = b }) := (! 0)) (c := "boy")))
(inert [ ({ e : (Sink Nat) , d : ({ a : (Top -> Unit) , a : (Ref Nat) }) }) ])
(fix (let c = (\ e : ({ e : String , e : Float }) . false) in ({ d = true , c = true })))
(\ a : ({ c : (Ref (< c : A , c : A >)) , a : (Source Nat) }) . (< a = (fix unit) > as (Source (Ref B))))
(if (inert [ (Sink ({ b : String , c : C })) ]) then (! (inert [ ({ c : Bool , c : Unit }) ])) else (! (pred (pred b))))
(succ (! (succ (pred 0))))
({ c = (inert [ (Bool -> A) ]) , b = (if (pred (inert [ Unit ])) then ((! true) (inert [ Unit ])) else (if a then 0 else "apple")) })
(inert [ ({ d : ({ c : A , d : Float }) , c : (< d : (Source String) , d : (< d : Bool , d : Unit >) >) }) ])
(! (iszero (iszero ((1 := a) as Bot))))
(< d = ({ d = (c as Top) , d = ({ a = unit , c = true }) }) > as (Sink (< d : ({ a : Bot , d : Unit }) , b : ({ e : Nat , c : (Source Bot) }) >)))
(({ c = (case "boy" of < c = c > => false | < a = a > => true) , b = (< b = (let b = "apple" in b) > as (< a : Nat , c : String >)) }) ((! false) . b))
((if ({ c = (case b of < e = d > => 2 | < b = d > => 0) , a = (ref 0) }) then (! false) else (case (inert [ String ]) of < b = a > => (true := c) | < a = c > => 2)) as ({ a : (Float -> Nat) , a : ((Sink B) -> Bool) }))
(pred (pred (inert [ ({ c : Nat , a : Bot }) ])))
(\ c : ({ e : (A -> Unit) , d : ({ e : B , e : (String -> Bot) }) }) . (pred (succ (inert [ A ]))))
(if (< e = (0 := "boy") > as ({ e : B , c : A })) then ((let b = (ref "boy") in (let d = 2 in c)) (\ c : B . ({ c = unit , c = 0 }))) else (if (succ ({ c = 1 , b = unit })) then (fix 2) else ((case 0 of < c = a > => c | < a = c > => "boy") (if 0 then a else (succ "boy")))))
((case (! (let a = (iszero a) in (fix false))) of < c = b > => (let c = ({ c = "apple" , e = "boy" }) in "boy") | < e = c > => (succ (ref 2))) (case ("apple" 0) of < b = c > => (! ("boy" (case 0 of < d = c > => 2 | < b = d > => false))) | < a = b > => (! (if true then (ref b) else (! unit)))))
(ref (((let d = b in unit) as (Ref Top)) . d))
((! ((a := false) . c)) ((let b = (c 1) in (if unit then (\ a : Float . c) else (\ d : Nat . false))) . c))
(ref (ref (case (b 2) of < b = c > => b | < b = b > => 2)))
(iszero ((ref (inert [ A ])) := ({ a = unit , b = (if "boy" then b else "boy") })))
(fix (case (! "apple") of < a = e > => (fix unit) | < b = a > => (false . e)))
(((case 0 of < c = e > => (ref c) | < d = c > => (\ b : Bot . 2)) as ({ d : Float , e : Top })) := ((fix (b := unit)) . b))
((inert [ (Source Unit) ]) . b)
(fix (let a = (\ a : Unit . "boy") in (unit . e)))
(if (if (ref (let b = true in "boy")) then ((case unit of < b = e > => true | < c = e > => 2) := "boy") else (let c = unit in 2)) then (pred (if true then c else (1 := true))) else (if (if 1 then (iszero b) else (fix "boy")) then ({ d = b , b = 0 }) else (pred false)))
(case (< e = ({ c = a , b = 2 }) > as (Ref Float)) of < b = d > => (! (ref b)) | < b = c > => (ref (let d = unit in b)))
((\ d : (Source Top) . (succ c)) . d)
(iszero ((\ d : Float . a) as (B -> (Sink C))))
(case ({ b = (0 a) , a = (pred (let b = c in c)) }) of < b = c > => (inert [ (Sink (Source String)) ]) | < d = c > => (("boy" . a) as ({ e : Bool , b : Nat })))
((if (pred "boy") then (ref unit) else (iszero "apple")) := ((pred (iszero 1)) . b))
((! (pred "boy")) as ((Source ({ a : Nat , b : Bool })) -> ((< c : A , b : Float >) -> (Sink (C -> Unit)))))
(< e = (((ref 0) (if c then "boy" else a)) := (ref "apple")) > as (Ref (Ref Bot)))
(inert [ (Ref (Source (Ref Unit))) ])
(((! (pred "boy")) as (< e : (< e : String , e : Top >) , e : ({ c : Nat , a : Float }) >)) := (succ (ref (case false of < d = d > => 2 | < c = e > => 2))))
(fix (\ c : ((Bool -> Bot) -> (Sink Float)) . (fix (< a = "boy" > as Nat))))
(let a = (let a = (case (iszero "boy") of < e = d > => (iszero 2) | < d = b > => false) in (! unit)) in ({ b = (\ d : String . (iszero false)) , d = (< d = ((1 := 2) (ref a)) > as (Sink Nat)) }))
(iszero (if (if (succ false) then (\ e : Bool . a) else (let d = false in 2)) then ((pred false) := (iszero "apple")) else (if 0 then c else 1)))
(let a = ((if unit then b else unit) (if (if 2 then "apple" else 1) then "boy" else b)) in ((let a = a in "apple") := (ref "boy")))
(! (succ (succ false)))
(\ a : (Source ((Nat -> (Source Nat)) -> (Source Float))) . (case (case (case (case unit of < c = a > => "boy" | < e = e > => 2) of < d = a > => (inert [ String ]) | < a = c > => (ref a)) of < e = d > => (inert [ Top ]) | < c = a > => (\ b : (Ref Top) . unit)) of < e = d > => (pred (fix (< d = "apple" > as Bool))) | < b = b > => (if (false as B) then (! c) else (\ b : String . 0))))
(! (let a = (if c then (iszero unit) else c) in (2 := 0)))
(inert [ (Ref (Source Unit)) ])
((pred (if c then 1 else true)) (ref (fix (< a = true > as Bot))))
({ a = (< c = (! (< d = ({ d = true , d = 1 }) > as B)) > as (Ref ({ a : (A -> Float) , a : (< c : Float , c : B >) }))) , d = ((ref (pred 2)) := ((\ a : A . b) as Nat)) })
(fix (! (if (let d = "boy" in true) then true else (if unit then 1 else "boy"))))
(inert [ (< c : (< b : (Sink Unit) , a : ({ a : Top , e : Top }) >) , e : (Source (Ref String)) >) ])
(inert [ (< d : (Ref Top) , b : (Unit -> Nat) >) ])
(inert [ (Sink (< b : Top , a : Float >)) ])
((! (ref (if 1 then 0 else false))) . c)
(iszero ((ref (! "boy")) as ({ a : ({ a : Bot , a : B }) , e : C })))
((succ (if a then (case 1 of < d = b > => 2 | < c = d > => unit) else unit)) as (({ e : (Source Float) , b : (C -> C) }) -> ((Sink (Sink Unit)) -> (Ref C))))
(((if b then (1 a) else "boy") (pred a)) := (iszero (case (let a = a in 1) of < d = e > => (pred 0) | < e = d > => (unit . d))))
(inert [ ({ d : ({ b : Float , e : C }) , c : (Ref (Source String)) }) ])
(let c = (pred (let b = (\ a : B . unit) in 1)) in (inert [ (Ref Nat) ]))
(fix (if (! (unit 2)) then (0 := b) else (ref unit)))
(\ c : (< b : (Source (Ref B)) , d : (((< c : B , d : Bool >) -> Bool) -> ({ b : String , e : Float })) >) . ((\ c : (B -> Nat) . (\ a : B . unit)) := (\ b : (< a : Nat , a : A >) . a)))
(fix (! (2 := false)))
(case ((ref "boy") := ("boy" "boy")) of < a = c > => ((if false then (inert [ B ]) else (if "apple" then 0 else 1)) := (a (unit := b))) | < a = a > => (! (let b = b in (inert [ B ]))))
((case (fix a) of < d = e > => (let e = (! a) in ({ c = false , c = a })) | < c = a > => (succ 1)) := ((case (a as Bot) of < e = a > => (succ unit) | < c = a > => (if c then (iszero b) else 2)) . d))
(((inert [ A ]) . c) as (Source (Bool -> Bool)))
((ref (succ "boy")) := (iszero (succ (\ d : (Sink Nat) . true))))
({ d = (pred (iszero a)) , d = (\ a : (Source Unit) . ({ b = ({ d = 2 , a = 1 }) , d = (< d = true > as C) })) })
(succ ((pred (iszero "boy")) (unit (let d = c in unit))))
(inert [ (Sink (< c : (Ref String) , b : Float >)) ])
(case (ref (let a = "apple" in (b as C))) of < e = a > => (case ((unit as Bot) . b) of < b = b > => (pred false) | < d = e > => (let d = unit in 1)) | < e = e > => (! (pred (< e = "boy" > as B))))
(inert [ ({ e : (Ref ({ e : (< c : Top , c : String >) , e : (A -> Float) })) , e : ({ e : (Source (Source Float)) , b : ({ d : Float , e : Bool }) }) }) ])
(succ (succ (iszero unit)))
((pred (ref c)) (fix ((fix c) . a)))
((iszero (\ c : (Source Bot) . (ref true))) ((iszero (\ c : String . false)) as ({ d : ({ a : String , a : Unit }) , b : (Source Bot) })))
(let a = (\ d : ((Sink C) -> (< b : ({ b : String , e : Unit }) , e : (< d : Top , b : B >) >)) . (\ b : (Ref Unit) . (if "boy" then c else (ref 0)))) in (pred (let d = (pred b) in (iszero unit))))
(fix (fix (! "apple")))
(ref (({ e = (true as Bool) , d = (! 1) }) := ((case a of < d = b > => "apple" | < a = c > => "apple") as (< b : Top , a : String >))))
(\ d : (({ d : (< b : C , d : (Sink A) >) , e : (Sink Nat) }) -> (Source A)) . (inert [ ({ c : (< a : C , b : Float >) , a : A }) ]))
(fix (ref (case 2 of < a = e > => 1 | < a = e > => (let e = c in "boy"))))
((< d = (a := (! 1)) > as ({ d : (< d : Bool , a : Float >) , c : (Ref Bool) })) (iszero (\ b : (Ref Bool) . b)))
(! (iszero (ref 1)))
(ref (fix (let a = ("apple" as Bot) in (inert [ Unit ]))))
((case (a := unit) of < d = b > => ({ c = false , b = true }) | < b = e > => (false := false)) as (< a : (A -> C) , d : (< e : String , d : Top >) >))
(ref (pred ({ c = (! b) , a = (\ e : A . 2) })))
((if ((1 a) (let a = unit in unit)) then (let d = a in (a "boy")) else (fix (\ e : (Source C) . (inert [ Bool ])))) := (\ b : (Ref ({ c : Float , c : Top })) . (if "boy" then "boy" else (pred c))))
((case ((if "apple" then true else true) := (b as B)) of < c = a > => (succ "boy") | < b = c > => (fix (let d = (! false) in false))) . c)
((case (pred (succ b)) of < a = a > => (({ e = 0 , c = true }) := (! false)) | < d = e > => (inert [ (Bool -> String) ])) := (case (iszero ("boy" true)) of < b = b > => (ref 2) | < a = c > => (case false of < c = c > => true | < d = d > => (fix "boy"))))
(< a = (iszero (a . e)) > as ({ a : (Ref Top) , c : (Bool -> B) }))
(ref ((inert [ (Ref (Unit -> Nat)) ]) . a))
(pred (pred ({ c = (iszero "boy") , e = b })))
(iszero (case ({ d = (let e = (! c) in (iszero 2)) , b = (true 1) }) of < b = e > => (\ b : ({ d : C , b : Bot }) . 0) | < c = c > => (a "apple")))
(< c = ((let c = (inert [ Float ]) in (let d = b in unit)) . b) > as ((Sink (< a : Bool , b : Nat >)) -> ((< b : Nat , d : Bot >) -> (Sink Bool))))
(let b = (\ e : (< d : A , b : Bool >) . (if c then "apple" else 2)) in (let b = (let a = c in a) in (false as B)))
(\ b : (Ref (Nat -> Top)) . (! (false := b)))
(((! true) . d) (case (if (let c = 1 in a) then (pred 1) else ((fix false) as (Nat -> C))) of < c = a > => (if false then "boy" else (2 as Bot)) | < c = d > => (\ e : (Sink Bool) . (fix 0))))
(\ d : (Ref (Sink Top)) . ({ a = ((inert [ Bool ]) . a) , e = (inert [ (Source Top) ]) }))
(succ (pred (< d = 1 > as Float)))
((pred (case 0 of < c = e > => "apple" | < b = a > => a)) as (Ref ((Sink A) -> C)))
(fix (if (fix (ref false)) then ((case unit of < c = c > => 1 | < e = c > => "apple") := 1) else ({ e = unit , a = 2 })))
(pred (((< a = a > as Nat) := (iszero 0)) . a))
(iszero (if (succ (a . b)) then (\ e : (Top -> Float) . (ref c)) else (if (inert [ Top ]) then (succ unit) else (\ e : Bool . false))))
((inert [ ((Sink B) -> (Sink Bool)) ]) := (inert [ (Sink (Sink Bool)) ]))
(ref (let e = ("apple" (case a of < a = a > => b | < c = a > => "apple")) in (iszero 0)))
(succ (succ (false ({ b = "apple" , b = 1 }))))
(iszero (let d = (1 as B) in (iszero "boy")))
((iszero (case ((fix true) as C) of < b = b > => (case "apple" of < a = b > => "apple" | < a = e > => c) | < e = c > => (let b = (iszero c) in b))) . a)
(iszero (((iszero 2) := (inert [ ({ b : B , e : Bool }) ])) as (< e : (Source Top) , d : ((Source Bot) -> A) >)))
(let a = (succ (fix (inert [ C ]))) in (({ e = b , b = true }) . c))
(if (succ (! c)) then ({ c = (if (succ unit) then (! (true as Bot)) else ("apple" (a as Bot))) , e = ((iszero "apple") := false) }) else ({ e = (let c = ({ e = "boy" , d = b }) in (fix "boy")) , d = (\ c : ({ b : C , b : C }) . ({ e = unit , d = 1 })) }))
(< c = (! (fix c)) > as ({ b : (< c : (Source B) , a : Float >) , b : (< b : C , c : Bool >) }))
((iszero (iszero a)) (ref ((! (case "boy" of < d = c > => unit | < c = b > => b)) := (case c of < e = b > => (if unit then b else false) | < c = d > => (succ false)))))
({ e = ((a . c) := (\ a : Nat . c)) , c = (let c = ((let a = a in unit) (2 as Bot)) in (ref a)) })
(ref (fix ({ a = (fix b) , d = a })))
(fix (let e = ((fix 1) := unit) in (pred true)))
(let c = (if (c . c) then (unit . e) else (succ a)) in (case (\ c : (Source Bool) . b) of < c = a > => (case (\ d : Bool . true) of < d = d > => (< a = "apple" > as Top) | < e = d > => (if c then a else c)) | < c = d > => ((fix false) . b)))
((if (({ a = true , a = "apple" }) as (Source Float)) then (inert [ (Sink Bot) ]) else (\ d : Float . 0)) := (< b = (({ d = true , b = 1 }) (pred "boy")) > as ((Ref Bool) -> (< d : Top , e : Nat >))))
(let a = (iszero (! b)) in (inert [ (Sink (Source A)) ]))
(iszero (pred (fix b)))
(let e = (succ ((let e = (let b = "boy" in true) in b) ({ c = 0 , e = "apple" }))) in (fix (< c = true > as ({ a : String , b : Nat }))))
(\ e : (< c : (Source (Ref Top)) , e : (Ref Bot) >) . (case (pred (case 0 of < e = c > => unit | < e = d > => unit)) of < b = a > => (if (ref 1) then (pred 1) else false) | < a = b > => (inert [ (Source A) ])))
(((succ a) := (fix ("boy" := false))) as (< c : ({ a : (Source (Ref Top)) , e : (Source Bool) }) , c : ((< a : Bool , c : Unit >) -> (Source Float)) >))
(fix (inert [ ((Sink A) -> Bool) ]))
(fix (((\ a : C . c) . b) as (Sink Bool)))
(pred (! (inert [ (Top -> C) ])))
((! (pred "apple")) ({ d = (ref "boy") , d = ((\ d : Float . 0) . e) }))
(ref (pred (inert [ (Sink A) ])))
(case (succ ((iszero (c "boy")) (< d = 1 > as String))) of < e = b > => (case (inert [ Bot ]) of < a = e > => (fix (case b of < d = c > => 2 | < e = e > => 1)) | < b = b > => (iszero (pred false))) | < b = d > => (pred ({ b = false , e = "boy" })))
(iszero (\ e : (Source (Ref C)) . (let b = c in unit)))
((< c = ((true as Float) . e) > as (Ref ({ a : A , b : Nat }))) as (Ref ({ e : A , b : Bot })))
(((succ unit) (let b = true in true)) as ((Ref C) -> (Sink A)))
(pred ((let c = true in (\ b : String . "boy")) . a))
(((("apple" as String) as Bool) := (ref (fix 0))) as (Source (Sink (Ref Float))))
(ref ((ref unit) as (Source A)))
({ b = ((fix unit) (iszero "boy")) , d = (fix (ref (< a = unit > as Top))) })
(< e = ((! (let c = "apple" in "apple")) as (Ref ({ c : Float , c : A }))) > as (((A -> B) -> ({ d : A , b : Bool })) -> (Source Top)))
(< e = (succ (< d = true > as (Sink B))) > as (Sink ((< e : Unit , d : String >) -> (Ref A))))
(let c = ({ e = (if ({ c = 2 , b = 0 }) then (1 . e) else "apple") , e = (< b = "apple" > as Unit) }) in (! (\ c : ({ c : A , a : A }) . (! 2))))
(case (< e = (2 . d) > as (Sink Bool)) of < c = e > => (fix (succ (b := false))) | < b = e > => (inert [ (< d : ({ a : Top , a : C }) , d : Nat >) ]))
(< b = (< c = ({ c = (case (ref false) of < e = a > => (case "boy" of < e = b > => false | < a = e > => b) | < b = c > => b) , e = (let a = true in false) }) > as (Ref Top)) > as (Source ({ b : (C -> (Source Bot)) , d : ({ b : Float , d : Float }) })))
(pred (< b = (inert [ (C -> Bot) ]) > as (Ref (Source A))))
(((fix "apple") (< d = "boy" > as Bot)) (ref (let c = true in b)))
((! ((case c of < d = e > => "apple" | < e = a > => a) b)) as ({ a : (< e : (< d : A , a : Unit >) , d : Unit >) , a : ({ e : (< b : A , e : ({ c : C , b : Float }) >) , b : (Source Top) }) }))
(ref (ref (inert [ (Source (Sink B)) ])))
(if (iszero (fix 1)) then (\ a : (< e : Nat , c : Nat >) . ((iszero c) (< a = true > as Nat))) else (iszero (! ("boy" as A))))
(iszero (! (\ a : (< c : C , a : A >) . (! true))))
(let e = ((! (ref (\ e : String . 1))) . a) in (((2 := true) as ({ e : Unit , d : Top })) := (ref ("boy" . e))))
(! (fix (inert [ ({ d : (String -> Unit) , d : A }) ])))
((case (< d = ("boy" . b) > as (Source (Ref B))) of < a = d > => (succ 1) | < d = e > => (pred "boy")) as (Source (Ref A)))
(pred (ref (case b of < b = d > => (0 . d) | < d = b > => (inert [ Nat ]))))
(let d = (fix (ref "boy")) in (iszero ((pred "apple") . b)))
(((if 1 then a else 0) (< c = true > as Bot)) as (Source (Source Bot)))
(< d = (succ (if (succ 2) then (< b = (< c = 2 > as Nat) > as (Ref Bool)) else (case 1 of < e = e > => unit | < b = e > => true))) > as (Sink (Float -> B)))
(((let d = unit in false) (if (\ b : (Source Top) . (succ c)) then (pred unit) else (a (fix "boy")))) := (let d = (\ a : Float . (let e = true in c)) in (if 2 then (false as Unit) else ({ e = true , e = b }))))
(((< a = 1 > as (Sink A)) (unit b)) as (< d : ({ b : (Sink String) , a : (Sink Float) }) , c : (Ref (< d : String , a : Bool >)) >))
(if ((succ true) as (String -> Bool)) then (! (if (pred 1) then c else (0 b))) else ((pred 2) (! 0)))
((! (\ e : (Sink (B -> C)) . (! false))) as (Sink (Bool -> Unit)))
(pred (! (\ c : (Ref Bot) . (ref unit))))
(((! a) (if (2 := 0) then (! b) else (! "apple"))) (case ({ d = (if c then c else false) , c = (1 unit) }) of < e = e > => (pred (if (unit 1) then true else unit)) | < d = e > => (if (if "apple" then (ref a) else "boy") then (let c = "apple" in b) else (fix (ref false)))))
(pred (pred (case false of < a = c > => 0 | < d = b > => unit)))
(\ b : ((Sink Bool) -> (Sink A)) . (let a = (a . d) in (< c = "apple" > as Top)))
(ref (pred (pred (if false then (if 0 then c else c) else (1 . e)))))
(((iszero (inert [ A ])) as (Ref A)) . d)
((! (< a = unit > as Float)) (ref (let b = b in 0)))
((< d = (pred unit) > as (< c : B , b : Unit >)) as (< d : (Ref (Source Nat)) , a : ({ e : (Source B) , d : ({ a : C , a : Bot }) }) >))
(succ (if (unit as (Source Bool)) then (\ a : (Ref Bot) . (c . b)) else (c (true 1))))
(iszero (inert [ (Source Top) ]))
((pred (pred 0)) := (< d = (case c of < e = a > => 0 | < d = a > => 0) > as (Source Nat)))
((inert [ ((Source Top) -> (< a : (< a : B , e : Nat >) , b : (Ref Nat) >)) ]) as ((Sink Bool) -> ({ e : (({ c : Top , e : Unit }) -> (Source Nat)) , d : (Source (Sink B)) })))
(! (\ b : (Sink String) . (< d = (iszero 0) > as (< b : (Top -> Nat) , b : Unit >))))
(inert [ ((< e : A , b : (Sink B) >) -> (Source Nat)) ])
((if (unit false) then (< e = ({ a = true , d = a }) > as A) else ((\ c : B . unit) := (unit as A))) . d)
(case ((\ e : Float . (! 2)) . e) of < b = d > => (\ a : (Source Unit) . (iszero a)) | < a = c > => (< c = (ref false) > as (Ref (< a : (< e : String , d : Bool >) , c : (Source Unit) >))))
(pred (fix (pred (ref unit))))
(pred (! (ref (fix a))))
(({ c = ((iszero 2) false) , c = (\ b : Unit . 1) }) as (< a : (Source ({ b : (Ref Top) , a : (Ref Float) })) , d : (< b : (Ref Top) , c : Unit >) >))
(! (ref (case "boy" of < e = c > => (succ unit) | < c = a > => ("apple" . b))))
(\ b : ({ d : (< c : Bool , e : Top >) , b : (Bot -> Unit) }) . (! (case (inert [ Nat ]) of < b = d > => (case "boy" of < b = b > => 1 | < b = a > => (succ b)) | < d = c > => (true "apple"))))
(iszero (case ((ref 2) . a) of < a = e > => (succ unit) | < d = c > => (inert [ (Sink Unit) ])))
(case (((! true) := "boy") (fix b)) of < b = b > => (fix (\ a : (Sink String) . (\ e : (< b : B , c : Float >) . "apple"))) | < d = a > => ((iszero (iszero unit)) . c))
(fix (< b = ((2 1) "boy") > as (Source Bool)))
(case (iszero (! (pred true))) of < e = a > => (ref (case c of < d = d > => a | < d = c > => 2)) | < e = c > => (pred (\ d : ({ b : Bot , b : B }) . (\ e : Nat . (pred true)))))
(fix (let d = (! "apple") in (pred 1)))
(< d = (pred (let e = (if "boy" then ("boy" . e) else "apple") in (case (succ "apple") of < d = b > => a | < d = d > => (case b of < e = a > => "boy" | < b = c > => "apple")))) > as (Source (Sink (Sink A))))
(\ a : (Sink (Bot -> Bool)) . ((pred unit) as (Ref (< b : Bool , e : C >))))
(ref (let a = (0 := unit) in (succ true)))
(if (if (iszero c) then ({ c = "boy" , d = ("boy" . d) }) else (< e = 1 > as String)) then (pred (case a of < a = e > => 2 | < a = e > => 2)) else (pred (case (! "boy") of < c = d > => (\ e : (String -> Top) . (< b = a > as B)) | < c = e > => (inert [ Float ]))))
(case ((if 2 then (< a = 0 > as Nat) else 2) := (< c = c > as Bot)) of < a = a > => ((if "apple" then "boy" else false) (! a)) | < c = a > => ((fix (inert [ Float ])) as ({ e : (Ref Nat) , c : (Ref Nat) })))
