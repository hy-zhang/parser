"hello"
unit
\x:A. x
let x=true in x
\x:Bool. x
(\x:Bool->Bool. if x false then true else false) (\x:Bool. if x then false else true) 
\x:Nat. succ x
(\x:Nat. succ (succ x)) (succ 0) 
\f:T. \x:Nat. f (f x)
\X. \x:X. x 
(\X. \x:X. x) [All X.X->X] 
{*All Y.Y, \x:(All Y.Y). x} as {Some X,X->X}
{x=true, y=false} 
{x=true, y=false}.x
{*Nat, {c=0, f=\x:Nat. succ x}} as {Some X, {c:X, f:X->Nat}}
let {X,ops} = {*Nat, {c=0, f=\x:Nat. succ x}} as {Some X, {c:X, f:X->Nat}} in (ops.f ops.c)
((succ (if (fix b) then (0 [ Nat ]) else (let b = a in true))) (pred (\ E . "apple")))
(let { D , a } = ({ * (A -> Bool) , (fix (if a then b else c)) } as (({ Some D , ({ Some D , Bool }) }) -> ({ Some C , ({ Some E , Float }) }))) in ({ * ((All D . C) -> (Bool -> ({ Some A , B }))) , (let c = (fix false) in "apple") } as ({ Some D , (All C . (Float -> Nat)) })))
(let { E , d } = (({ * ({ c : Float , c : A }) , true } as (C -> String)) . e) in (fix (let d = "apple" in true)))
(inert [ ({ Some C , ({ Some C , C }) }) ])
(succ (succ ((fix c) [ B ])))
(inert [ ({ c : ({ c : C , d : A }) , d : ((All D . A) -> (String -> Float)) }) ])
(succ (\ d : ({ c : ({ Some E , C }) , a : (All D . C) }) . ((\ e : String . "apple") [ (String -> A) ])))
(succ (\ B . (\ a : ({ Some A , (A -> A) }) . (\ a : Bool . unit))))
(\ a : ({ Some C , ({ Some B , (All B . Bool) }) }) . ((iszero (\ C . b)) as ({ c : ({ Some B , Bool }) , d : (All A . Bool) })))
({ d = (let { A , b } = ((let d = (\ a : Float . "boy") in false) as (Nat -> C)) in (iszero (pred unit))) , a = ((\ D . "apple") . b) })
((\ a : (({ Some A , Unit }) -> (Float -> Float)) . (2 as Float)) [ (({ Some A , A }) -> (Nat -> Nat)) ])
(\ B . (if (\ E . (c . a)) then (inert [ B ]) else (pred "apple")))
({ a = ({ e = (iszero (c [ Bool ])) , a = (let { D , e } = c in (unit . c)) }) , e = ((\ d : ({ Some E , Float }) . (if c then true else b)) (let { A , d } = (\ B . "boy") in ({ d = unit , a = c }))) })
(inert [ ({ Some E , (All D . A) }) ])
((succ (pred "boy")) as (All E . ({ Some E , ({ c : Unit , d : Nat }) })))
({ a = (let d = (a as A) in (false . e)) , e = (let { A , e } = (("apple" . d) (\ A . "boy")) in (b as C)) })
(iszero (({ b = (\ e : Float . a) , e = c }) as (All A . String)))
(let c = (\ c : ({ Some D , (All B . A) }) . (if (\ a : B . true) then 0 else false)) in (inert [ ({ a : Float , a : Unit }) ]))
(fix (fix ((\ D . unit) as ({ d : ({ c : Bool , b : B }) , d : B }))))
(\ C . (\ a : ({ Some C , (C -> B) }) . (let { C , b } = (a "apple") in ({ * A , true } as B))))
((fix (let b = 0 in (iszero true))) [ ((All C . (All A . C)) -> (All D . B)) ])
(succ ({ e = ((let a = unit in 0) "boy") , c = ((c . d) [ (All D . A) ]) }))
(let e = (let c = (pred a) in (pred false)) in ({ * ({ Some C , ((Nat -> String) -> (Nat -> Float)) }) , (succ 2) } as ({ Some E , (All E . Nat) })))
(succ (if (let a = (if "apple" then true else "apple") in (succ (true 2))) then (\ C . (true . d)) else (fix a)))
(let b = (\ A . (\ B . b)) in (inert [ (Unit -> Unit) ]))
(({ d = (if ((fix 2) as ({ c : Nat , b : Bool })) then ("boy" . d) else (iszero 2)) , a = ((c . d) [ (All C . ({ a : Nat , c : C })) ]) }) (succ (pred c)))
(iszero (pred (let b = false in "boy")))
(if (\ b : ({ a : String , b : Float }) . (pred "apple")) then (let { D , d } = (succ (if "boy" then b else unit)) in ((false [ Float ]) (iszero 0))) else (iszero (let { C , e } = (\ A . "apple") in (succ "boy"))))
(\ e : (All E . (({ Some B , String }) -> (Nat -> C))) . ({ d = ({ e = a , e = "apple" }) , c = (let { C , d } = "apple" in a) }))
((({ * Bool , 1 } as C) [ ({ e : Unit , a : ({ c : Nat , a : String }) }) ]) [ ({ Some C , (Float -> B) }) ])
(pred ({ * ((Nat -> B) -> ({ Some E , Nat })) , (if (pred "apple") then (2 . a) else (\ E . false)) } as ((All B . String) -> ({ Some B , String }))))
((pred (\ d : (A -> (String -> Bool)) . (unit [ Bool ]))) (iszero (\ E . a)))
(\ e : ({ Some E , ({ d : C , c : ({ Some A , Bool }) }) }) . (iszero ({ * Unit , 0 } as Nat)))
({ e = ({ a = (fix false) , e = (succ (fix b)) }) , e = ((succ b) as ({ e : C , b : C })) })
(succ ((inert [ A ]) as ({ Some D , B })))
((if (let { B , b } = a in 1) then (let { D , c } = true in (if unit then b else "apple")) else (if false then c else unit)) . a)
(succ (\ a : (A -> B) . (fix unit)))
(((succ (\ c : String . true)) as ({ d : Float , e : Bool })) [ (({ b : Unit , c : Float }) -> ({ Some C , (Bool -> A) })) ])
(((inert [ ({ Some A , C }) ]) as ((String -> B) -> A)) . d)
({ * (({ b : (All B . C) , d : ({ c : Unit , c : B }) }) -> ({ Some D , (Float -> Bool) })) , ({ * ({ c : (B -> Unit) , c : String }) , ((\ B . 2) . e) } as (String -> (All D . A))) } as (All D . ((All B . String) -> ({ e : Float , e : Float }))))
(iszero (\ D . (true as (All D . Float))))
(\ D . (succ (fix 2)))
({ b = ((succ (pred "boy")) . e) , c = ((pred "boy") (let { E , a } = c in (fix false))) })
(\ d : (({ Some D , ({ Some D , ({ e : C , b : Nat }) }) }) -> ({ d : ({ Some A , Unit }) , b : Float })) . ({ e = (\ B . c) , c = (iszero c) }))
(fix ((a 0) [ ({ Some E , A }) ]))
((iszero ((\ c : A . a) as ({ e : Nat , b : String }))) ((\ c : (All A . B) . 1) . c))
(\ E . (if ("boy" false) then (unit . b) else (\ d : (Unit -> C) . 1)))
(succ (succ (\ c : String . true)))
(fix (fix (inert [ Bool ])))
((\ A . (fix (fix false))) (inert [ ({ Some C , Nat }) ]))
(pred (pred (iszero (pred 0))))
(pred (if (let b = (fix "boy") in unit) then (2 [ Nat ]) else (b [ Unit ])))
(pred (if ({ * (String -> Unit) , b } as C) then ((iszero "boy") . c) else ({ d = 1 , a = "apple" })))
(\ a : ({ Some C , ({ Some C , B }) }) . (fix (if a then 2 else c)))
((iszero (c . c)) [ (All D . (All A . Nat)) ])
((\ b : (C -> (Unit -> Nat)) . (b as String)) . a)
(let d = ((\ D . ({ * ({ e : Bool , e : Bool }) , 0 } as (All B . Unit))) (if ({ * Nat , a } as String) then unit else true)) in ({ c = (\ C . 2) , b = (inert [ (All B . (A -> B)) ]) }))
({ * ({ a : ({ d : (Bool -> A) , b : (Float -> String) }) , a : ({ Some E , ({ Some D , Bool }) }) }) , (pred (succ c)) } as ({ b : (({ Some B , ({ a : Unit , b : Nat }) }) -> ({ e : String , d : (String -> String) })) , d : ({ Some D , (All D . Float) }) }))
(inert [ ({ d : ({ e : Nat , b : A }) , d : (A -> C) }) ])
(\ D . (((succ 0) [ ({ Some E , A }) ]) ({ d = (\ a : C . "boy") , b = (iszero true) })))
(let d = (fix ((pred unit) as C)) in ((false [ (String -> B) ]) [ ({ d : ({ Some B , B }) , a : B }) ]))
({ a = (let { A , b } = (let d = (iszero b) in (false "boy")) in (fix b)) , d = (if (pred (succ unit)) then (succ (pred unit)) else ((fix true) (iszero ({ a = 0 , b = 0 })))) })
({ c = ((a [ A ]) (({ * String , 2 } as String) [ (Float -> C) ])) , c = (let { A , d } = (if (0 as B) then (let { D , d } = unit in false) else 2) in (pred (if b then 2 else 1))) })
((fix (let { C , c } = 0 in a)) as ({ d : ({ a : (All D . Float) , b : (String -> ({ e : Bool , b : B })) }) , a : (({ d : C , d : Unit }) -> ({ c : Float , a : String })) }))
(\ c : (({ e : String , d : String }) -> ({ e : ({ Some A , A }) , b : ({ Some D , A }) })) . (let b = (inert [ ({ Some B , A }) ]) in (inert [ ({ Some E , Bool }) ])))
(({ e = (let a = a in true) , c = ("apple" [ Unit ]) }) (let a = ((1 [ C ]) . c) in ({ * Unit , (\ e : Nat . "boy") } as A)))
(fix ({ * (({ a : (All C . Unit) , c : ({ d : String , c : Unit }) }) -> (All E . C)) , ((if false then true else 1) [ ({ a : (All C . Bool) , e : Bool }) ]) } as ({ c : ({ Some A , C }) , c : (All C . Float) })))
(let { D , e } = ({ e = (\ C . false) , c = (if (inert [ (All C . Float) ]) then (\ e : Float . unit) else (if b then (b as A) else false)) }) in (\ D . ((b . c) "boy")))
(if (let { A , e } = (\ A . 2) in (unit . c)) then (pred ((succ 1) . e)) else (fix (let { C , c } = 0 in 1)))
(let b = (iszero (\ C . ((true c) (inert [ B ])))) in (if ((\ D . false) . a) then (("apple" . d) as ((C -> Float) -> ({ a : Unit , b : C }))) else ((if "apple" then 0 else c) [ ({ Some B , C }) ])))
(iszero (iszero (if (\ D . unit) then (inert [ ({ d : Nat , e : Bool }) ]) else (0 as B))))
(let { A , b } = (succ (let { A , a } = b in true)) in (\ E . (\ E . (pred "apple"))))
(let { C , e } = ((unit . c) ({ * C , true } as String)) in (iszero ((\ a : Unit . "apple") [ C ])))
(\ e : (({ c : B , d : Bool }) -> (All E . B)) . (pred ({ * ({ d : A , b : Bool }) , "boy" } as B)))
(let { A , b } = (pred (succ ({ a = false , c = true }))) in ({ * (All B . ((B -> Float) -> ({ a : Nat , e : C }))) , (inert [ ({ Some A , Bool }) ]) } as ({ e : (C -> B) , b : ({ e : (All D . B) , e : B }) })))
(pred (\ d : (({ e : C , e : C }) -> Float) . (2 true)))
((if (fix 0) then (false as ({ Some D , Float })) else ((\ D . 0) unit)) . a)
({ e = (\ d : ((All E . A) -> A) . (\ D . (a true))) , b = (let c = (let { C , e } = 1 in (1 [ Unit ])) in (\ C . (true as (All D . String)))) })
(inert [ (All E . ({ e : (All B . String) , b : (Unit -> String) })) ])
((inert [ ({ Some B , C }) ]) as (({ a : (({ b : C , c : B }) -> Float) , c : ({ Some E , Unit }) }) -> ({ Some A , ({ Some B , (All A . Unit) }) })))
({ * (({ c : Bool , c : A }) -> (Float -> Unit)) , ((iszero c) . d) } as ({ Some D , (All E . Nat) }))
((iszero (inert [ A ])) [ (All E . (B -> (All C . String))) ])
((succ ({ c = b , c = (iszero "apple") })) as ({ Some B , ({ Some E , ({ Some A , B }) }) }))
(\ d : (({ d : ({ c : B , e : C }) , e : (C -> ({ Some E , String })) }) -> ({ Some E , (All D . B) })) . (\ D . ((a "boy") as Bool)))
(\ d : ({ Some E , ({ d : ({ Some C , Float }) , e : ({ Some C , ({ b : Nat , d : String }) }) }) }) . (fix (if (succ (if 0 then b else c)) then (fix 1) else (let { A , b } = 2 in true))))
({ e = ((if 1 then a else false) (1 as Nat)) , b = ({ a = (iszero (\ d : Float . 0)) , a = (if "boy" then 0 else 1) }) })
(({ * (Bool -> A) , (inert [ Unit ]) } as (Float -> Float)) as (All E . ({ e : A , a : String })))
({ d = (let { B , a } = ({ c = (succ b) , b = ({ * (String -> Nat) , b } as ({ b : Bool , b : Unit })) }) in (\ a : ({ a : C , b : C }) . ({ e = (b as Float) , c = 2 }))) , e = (if ((succ b) as (All E . C)) then ((pred "apple") as ((Bool -> Unit) -> Bool)) else (succ (unit 2))) })
(let { B , c } = (inert [ ({ c : (String -> Bool) , e : ({ b : String , b : String }) }) ]) in (let { D , e } = (({ * A , b } as Bool) (let { A , c } = c in false)) in (iszero (0 as B))))
(pred (iszero (inert [ (C -> Float) ])))
(if (succ (pred unit)) then ((\ a : (All D . Nat) . (c [ String ])) as ((B -> Bool) -> C)) else ({ a = (pred (\ c : B . c)) , c = (0 . a) }))
(succ (succ (succ 0)))
(pred (if (let e = (if true then "apple" else false) in (pred b)) then (fix (inert [ (All A . Float) ])) else (fix false)))
(pred (iszero (pred false)))
(({ a = (fix (succ "boy")) , d = (let e = c in (fix c)) }) (inert [ ({ Some C , B }) ]))
(({ * (All E . (A -> C)) , (\ E . (inert [ String ])) } as (Float -> (String -> Bool))) (pred (let a = 0 in "apple")))
(inert [ ({ b : (Float -> (All D . String)) , d : (Bool -> Unit) }) ])
(\ E . (\ a : ({ Some A , ({ Some D , Float }) }) . ({ * Bool , ("boy" b) } as ({ c : Float , c : B }))))
(({ d = (b . b) , c = (fix false) }) ((pred (\ B . b)) . c))
((iszero (let c = true in 2)) . b)
(\ d : (({ Some A , (All C . String) }) -> ({ a : (All D . ({ Some E , A })) , d : (A -> ({ c : Unit , a : String })) })) . (let { D , e } = (\ C . ((c unit) as ({ d : Nat , a : Nat }))) in ((succ a) (succ 1))))
(\ B . ({ * ({ Some B , String }) , ({ * A , 1 } as A) } as (({ Some C , Nat }) -> C)))
((let c = (\ C . (1 false)) in (inert [ (({ Some E , C }) -> ({ Some C , Float })) ])) . b)
(succ (iszero ({ * String , b } as Unit)))
({ * ({ c : (All B . (All B . Nat)) , e : ({ b : (A -> Nat) , c : (Nat -> B) }) }) , (pred (pred ("boy" 0))) } as ({ d : ({ Some B , Float }) , b : ({ Some C , Bool }) }))
(let e = ((pred 2) (fix false)) in (let a = (unit [ Unit ]) in ({ * Nat , c } as B)))
(\ d : ((All A . ({ a : Float , a : Float })) -> ({ a : (All B . C) , c : ({ d : C , b : ({ Some C , A }) }) })) . (let { C , a } = (if (\ B . 2) then (0 as Unit) else (let { E , d } = ({ e = "apple" , b = 1 }) in a)) in ((iszero "boy") [ ({ Some D , Unit }) ])))
(\ C . (fix ((fix 1) . a)))
(let { E , d } = (fix ((fix "apple") as (All B . C))) in ({ a = (0 as C) , a = (if (\ A . "boy") then unit else a) }))
(iszero ({ * (All B . Nat) , (pred (fix 1)) } as (All C . B)))
(succ (\ b : ({ c : ({ e : B , e : B }) , a : (Unit -> A) }) . (\ C . (iszero a))))
(pred (iszero (1 [ Unit ])))
(if (fix ((\ d : B . "boy") [ ({ c : B , e : C }) ])) then ((\ e : (All E . A) . c) as ({ e : ({ Some A , Float }) , c : Unit })) else (inert [ ({ Some B , C }) ]))
(succ (\ A . (fix ({ c = 1 , e = 0 }))))
({ * ({ a : ((All B . B) -> String) , a : (Nat -> B) }) , ({ c = ({ * (All C . String) , (\ a : Nat . 1) } as Float) , b = (((true 0) . d) . d) }) } as ({ e : (All D . A) , e : ((All A . String) -> ({ e : String , b : A })) }))
(if ((unit ("apple" "apple")) . a) then (((let b = true in false) [ Unit ]) as ({ d : ({ Some B , B }) , c : ({ Some A , Nat }) })) else (\ E . (pred ({ * Float , unit } as Unit))))
(succ ((if a then (inert [ Bool ]) else c) as ({ Some A , ({ Some D , Float }) })))
({ d = (inert [ (All A . A) ]) , d = (pred (\ D . "apple")) })
(pred ({ * (A -> Unit) , (iszero true) } as (({ c : B , d : Bool }) -> Unit)))
(inert [ (({ Some D , Unit }) -> ({ Some A , Unit })) ])
(inert [ ({ Some C , ({ e : C , e : B }) }) ])
(let { A , c } = (({ a = (iszero c) , e = true }) [ ({ Some C , (Float -> B) }) ]) in (iszero ({ * B , 1 } as C)))
((((fix unit) as (B -> Unit)) [ (All C . ({ Some D , Float })) ]) as ({ Some C , ({ b : Nat , d : A }) }))
(let e = (iszero ((if "apple" then unit else b) "boy")) in (inert [ ({ Some A , C }) ]))
(\ E . (if (inert [ (All A . Float) ]) then (if a then c else b) else (iszero "apple")))
(let a = (\ D . (pred b)) in (\ d : ({ e : ({ b : C , c : B }) , e : ({ d : C , c : A }) }) . (succ (let { E , e } = "boy" in true))))
((let c = (0 2) in (let { E , b } = b in 2)) [ ({ Some E , (Unit -> Bool) }) ])
(succ (pred (pred 2)))
((inert [ ({ Some D , ({ b : Nat , b : B }) }) ]) ({ * ({ Some D , (Float -> String) }) , (let a = (succ (inert [ Nat ])) in (fix c)) } as ({ Some B , (A -> Bool) })))
(iszero (if ({ * Float , (\ b : Unit . b) } as A) then (fix (0 as C)) else (pred (2 c))))
(fix (let e = ({ a = (unit [ Unit ]) , d = (let { E , e } = b in "boy") }) in ((let { A , b } = (false . e) in ("apple" c)) . e)))
(pred ({ * (({ d : Nat , c : A }) -> (C -> C)) , (succ (if 2 then 0 else a)) } as (All C . A)))
({ d = ((pred a) as ({ Some E , String })) , c = ((fix a) as (({ Some E , Nat }) -> (Unit -> Bool))) })
((iszero (inert [ Float ])) . d)
(\ e : ({ e : ({ Some C , (String -> String) }) , d : ((All C . Float) -> (B -> String)) }) . (fix (iszero (if a then b else true))))
(\ d : ((All D . Nat) -> (Bool -> A)) . ((succ (iszero (false as Bool))) [ (All D . Nat) ]))
({ * ({ b : ({ Some E , ({ Some C , Nat }) }) , c : (All E . ({ c : C , b : C })) }) , (\ C . ((0 "boy") (iszero a))) } as (All B . ({ d : Unit , d : Nat })))
({ b = (let d = ({ c = c , b = 2 }) in (pred c)) , a = (({ * ({ b : String , b : Float }) , (if "boy" then unit else a) } as (All D . Bool)) (false as ({ Some C , Nat }))) })
(let { E , c } = (let e = (iszero (fix "boy")) in (if (1 [ Nat ]) then (\ d : B . 0) else 2)) in (let a = (\ D . 0) in (let d = "boy" in unit)))
(iszero (succ (succ true)))
(iszero (iszero (if (succ 1) then (\ E . 2) else true)))
(iszero (pred (inert [ C ])))
(let e = (pred (fix false)) in ({ * (({ Some D , Bool }) -> (C -> B)) , ((\ C . "boy") [ (C -> C) ]) } as (Float -> ({ a : Bool , d : A }))))
((fix (let e = "apple" in 0)) as (All B . ({ e : Unit , c : Nat })))
({ * (({ Some C , String }) -> ({ Some B , Unit })) , (succ (b [ Float ])) } as ({ Some A , ({ d : (C -> Unit) , b : (String -> Bool) }) }))
(\ d : ({ a : (All C . (All D . String)) , d : ({ Some C , Nat }) }) . ({ a = (let a = ({ * Unit , 0 } as Bool) in ({ * A , true } as C)) , c = ({ * String , (0 as Unit) } as String) }))
(((\ C . (fix false)) [ ({ Some C , Float }) ]) ({ * ({ Some A , ({ Some E , B }) }) , (let a = (pred true) in ({ d = "boy" , c = 2 })) } as ({ e : B , c : String })))
(pred ((pred (pred true)) . e))
(({ e = (\ d : (C -> Nat) . (c (false [ Float ]))) , e = ((0 [ A ]) ({ * A , c } as Bool)) }) as ((({ e : String , d : Unit }) -> ({ Some B , Float })) -> (Unit -> Bool)))
(({ * (All D . ({ b : Float , a : String })) , (0 [ Nat ]) } as (({ a : String , e : Unit }) -> (All A . Nat))) . b)
({ d = (pred ({ c = (unit [ A ]) , a = (inert [ String ]) })) , b = (iszero (iszero c)) })
(if ({ d = (({ * C , a } as B) unit) , e = (c . d) }) then ((inert [ Unit ]) [ (All A . ({ c : String , c : Nat })) ]) else (iszero (2 true)))
(({ * (C -> A) , (let c = 0 in true) } as (String -> Float)) as (((All E . Unit) -> ({ b : (String -> C) , a : Bool })) -> ({ Some C , ({ Some D , A }) })))
(inert [ ((All C . Float) -> (All D . ({ Some D , A }))) ])
(inert [ (All D . ({ a : Float , a : B })) ])
(succ ((fix ({ * Float , (pred 2) } as (Nat -> Bool))) [ (All E . ({ c : String , e : (Float -> Float) })) ]))
({ * ({ Some C , (Bool -> Nat) }) , (pred ({ d = unit , e = c })) } as ((String -> Unit) -> (All D . Float)))
(succ (iszero (\ A . b)))
(({ * ({ b : (All C . ({ Some B , Nat })) , c : (All C . Bool) }) , (inert [ Unit ]) } as (All D . ({ c : B , c : A }))) [ ({ d : ({ Some D , ({ c : Bool , e : Unit }) }) , d : (Nat -> A) }) ])
(((if unit then c else 1) [ ({ a : Nat , e : Nat }) ]) [ ({ Some E , ({ Some C , ({ e : ({ Some D , C }) , b : Nat }) }) }) ])
(\ D . (fix (fix (succ "boy"))))
(let c = (iszero ((b . e) . e)) in (if (let { D , d } = unit in 1) then (succ 2) else (fix a)))
(succ ((pred unit) [ ({ b : Nat , d : Unit }) ]))
(let { A , a } = (let { A , b } = ({ e = (let e = a in "apple") , a = b }) in (pred (c . d))) in ((c as (B -> Float)) as ({ Some C , C })))
((pred (let { E , e } = b in (pred a))) as (({ e : Unit , d : C }) -> (Unit -> Bool)))
(((succ "apple") (inert [ String ])) as ({ e : (All C . ({ c : String , a : (Nat -> Nat) })) , d : (All B . (All C . Nat)) }))
(\ c : ({ c : (Nat -> B) , b : (All D . (String -> Float)) }) . ((if (iszero 0) then false else false) . a))
(({ c = (pred "boy") , c = (succ false) }) . e)
(\ E . (pred ((if c then unit else 0) a)))
(fix (iszero (let a = a in 0)))
({ * ((Float -> (Nat -> Bool)) -> ((All A . Nat) -> ({ Some B , (All B . Nat) }))) , (\ C . (iszero (1 a))) } as (All E . (({ Some D , C }) -> ({ Some A , A }))))
(let { A , e } = ((iszero "apple") as (All A . A)) in (if ({ d = (inert [ Float ]) , c = (iszero 0) }) then (iszero (let e = a in (let b = a in "apple"))) else ((fix 2) (2 as C))))
(let e = (let { C , d } = (\ E . "apple") in ({ * C , 1 } as Float)) in (let e = (let { D , c } = (\ E . 2) in (\ D . true)) in (({ c = false , d = unit }) [ ({ d : B , b : C }) ])))
((let b = (succ c) in ({ e = (inert [ A ]) , a = (if "apple" then 0 else "boy") })) as (All A . (All D . ((Nat -> Unit) -> ({ b : Bool , b : String })))))
(pred (iszero (((pred true) . e) (iszero unit))))
(let { E , a } = (fix (inert [ ({ d : Float , a : (All D . String) }) ])) in ((fix (\ d : Float . c)) as ((Float -> (Nat -> C)) -> ({ Some B , Nat }))))
(succ (iszero (let e = 2 in c)))
(\ e : (All D . ({ b : A , b : Float })) . (fix (if 2 then true else b)))
({ * ({ Some C , ({ a : B , a : Unit }) }) , (({ * A , "boy" } as (All E . Float)) [ (All B . String) ]) } as ({ e : ((All B . C) -> ({ Some D , C })) , a : (All A . (All C . Bool)) }))
(pred (iszero ({ c = (pred (1 b)) , d = (if b then 1 else 0) })))
(inert [ ({ b : (Bool -> Float) , c : ({ Some C , Bool }) }) ])
(iszero ((let d = (pred 0) in (a as ({ Some A , C }))) [ ({ e : ({ Some A , B }) , d : C }) ]))
(inert [ ({ Some E , ({ Some E , A }) }) ])
(inert [ ({ Some B , ({ Some E , A }) }) ])
((succ (let b = (let e = "apple" in "boy") in ({ * Bool , false } as ({ c : String , a : Float })))) as ({ Some B , ({ a : Unit , c : String }) }))
((inert [ ({ a : ({ b : Unit , e : Nat }) , c : (All A . B) }) ]) [ (({ b : ({ a : C , c : Unit }) , c : (All C . B) }) -> (C -> (Bool -> String))) ])
(let a = (((succ true) (inert [ String ])) . e) in (inert [ (String -> Nat) ]))
(\ e : ({ d : (All D . Bool) , b : ({ Some E , Bool }) }) . ((\ c : ({ Some C , Unit }) . (let { B , a } = (a false) in (succ "apple"))) . c))
(let { E , c } = (fix (let e = 1 in "apple")) in ((let b = (fix 1) in (\ d : Unit . unit)) . c))
(\ e : ({ e : ({ Some A , ({ b : Bool , a : ({ Some C , Nat }) }) }) , e : (B -> ({ Some D , Nat })) }) . ((\ c : Unit . false) as (C -> B)))
(\ E . (fix ({ d = ((\ d : Nat . 2) as A) , c = (let e = unit in (let c = false in "boy")) })))
({ b = (fix (inert [ String ])) , d = (\ c : ({ Some E , C }) . (succ (let { B , c } = true in 2))) })
((pred (\ a : Unit . true)) . d)
(iszero (let { D , a } = (let { B , e } = a in "apple") in ({ b = b , e = 2 })))
(inert [ ({ Some B , (({ a : B , b : Bool }) -> ({ c : A , e : C })) }) ])
(iszero ({ c = ((a as Nat) . e) , a = (\ D . 0) }))
(let c = ((iszero (c true)) . c) in (inert [ (All D . String) ]))
(\ D . ((if 1 then (a false) else (if 2 then b else a)) . d))
((\ B . ((\ C . b) . b)) as (({ e : String , a : Float }) -> ({ b : ({ Some D , Nat }) , c : Float })))
(inert [ (({ e : (Float -> Bool) , d : B }) -> ({ Some C , ({ b : A , a : Bool }) })) ])
(if (let d = ({ * C , true } as ({ Some B , Float })) in (succ c)) then (iszero (succ 1)) else (fix (pred (if b then "apple" else 0))))
(if ({ * ({ c : String , e : Float }) , (fix "apple") } as ({ e : C , e : Float })) then (fix (\ e : ({ a : String , a : C }) . (pred 2))) else ({ a = (\ B . false) , b = ("apple" as String) }))
(let { C , a } = (\ a : ({ Some C , (All B . Unit) }) . ("apple" c)) in (let { C , e } = ((if b then unit else b) . d) in (\ e : Nat . 1)))
(pred (pred (b . c)))
((iszero ((b [ ({ Some E , String }) ]) [ ({ d : A , e : Nat }) ])) . b)
({ b = (\ e : ({ Some E , Bool }) . (if c then 1 else (false "boy"))) , a = ((inert [ Unit ]) . c) })
((iszero (inert [ ({ e : String , e : Float }) ])) as ({ Some B , ((C -> Unit) -> A) }))
(\ e : ({ e : (C -> ({ Some E , Bool })) , e : (All C . B) }) . (inert [ (({ a : Float , c : Nat }) -> (All C . Float)) ]))
((let { D , b } = ({ d = (succ true) , a = (let e = false in unit) }) in (succ "boy")) as ((C -> Bool) -> ({ Some A , String })))
((iszero ({ d = (iszero "apple") , b = (\ c : Nat . 2) })) . a)
(((\ B . (inert [ (All D . C) ])) ({ e = (\ E . 0) , d = ({ * A , c } as (All C . Bool)) })) as ((All A . Nat) -> ({ Some C , Bool })))
({ c = (((true as String) as ({ e : Float , a : B })) as ({ e : ({ Some A , C }) , c : (Float -> C) })) , e = (inert [ (All C . B) ]) })
(pred (({ * String , (pred "boy") } as C) . a))
(succ (if (fix false) then (succ (if false then false else c)) else (("apple" [ A ]) [ ({ a : Bool , b : Unit }) ])))
(let b = (\ c : ({ b : String , c : C }) . (if b then 0 else true)) in (iszero (iszero ({ e = b , a = b }))))
(((let b = (iszero ("boy" . c)) in (fix (let { E , e } = unit in 1))) [ ({ Some A , ({ Some B , Unit }) }) ]) (let { D , e } = (iszero (let { A , c } = a in (\ b : Float . 1))) in (\ D . (let b = 1 in 1))))
(let c = (((inert [ String ]) as ({ Some E , B })) . b) in ((pred (0 [ Nat ])) as ({ e : Bool , c : A })))
((inert [ ({ d : ({ b : Bool , d : B }) , e : (Bool -> Float) }) ]) as (All B . (Float -> Bool)))
(pred ({ a = (let { B , a } = (fix "apple") in (let { E , c } = 2 in unit)) , a = ((let { B , b } = "boy" in c) as (All C . (String -> String))) }))
(let d = ((pred a) . c) in ((fix 2) ("apple" . a)))
(pred (iszero ({ e = unit , a = b })))
(({ c = ((fix 0) [ ({ a : Nat , a : String }) ]) , d = (let { D , c } = (inert [ B ]) in (2 . b)) }) as (All D . (All D . String)))
((inert [ (Bool -> Float) ]) (let e = (\ A . ({ b = 1 , b = "boy" })) in ({ a = unit , e = 0 })))
(\ B . (if (\ e : ({ d : Bool , e : Nat }) . a) then (iszero (let b = 0 in false)) else (let { C , b } = ({ * Unit , 1 } as A) in 1)))
((succ (\ D . b)) ({ a = (let c = true in "boy") , b = ({ b = 1 , a = unit }) }))
(inert [ ({ b : ({ Some A , (Nat -> Unit) }) , a : (All C . (All B . (All A . Nat))) }) ])
(pred (("apple" . d) [ ({ Some D , Bool }) ]))
({ c = ({ * (All C . C) , ("apple" as Unit) } as (B -> ({ d : String , a : C }))) , d = (inert [ (All E . ({ c : B , d : C })) ]) })
(inert [ ({ d : ({ Some E , String }) , e : (All A . (Float -> Nat)) }) ])
(\ c : ({ a : ({ Some C , ({ b : Float , b : A }) }) , b : ({ Some C , (All E . Unit) }) }) . (let { D , b } = (\ C . "apple") in (if ("boy" as Nat) then (inert [ String ]) else (\ b : B . b))))
(fix (let a = (if "boy" then c else b) in ((iszero 0) [ ({ c : Bool , b : String }) ])))
(fix ((\ e : (All D . B) . (if "boy" then false else c)) . b))
(succ (\ B . (pred (succ a))))
(iszero (pred (c (if "apple" then 1 else 0))))
(({ b = ((fix unit) [ ({ Some C , Float }) ]) , b = ({ * String , ({ * Bool , "apple" } as A) } as Unit) }) . b)
(({ b = (succ "boy") , b = (inert [ Float ]) }) ((pred 0) as ({ Some A , Float })))
((fix (iszero (let a = c in unit))) (({ b = (let b = true in 2) , c = (inert [ B ]) }) as ({ d : Nat , e : Float })))
(succ (let { D , e } = ((inert [ Float ]) . e) in (succ (fix false))))
(inert [ (({ Some B , String }) -> ((All D . C) -> (B -> String))) ])
({ * ({ b : ({ e : (All D . String) , a : Bool }) , e : ({ c : B , a : Unit }) }) , ((\ C . unit) . c) } as ((All A . (({ Some E , Float }) -> A)) -> (All B . (All A . C))))
((\ C . (if (\ a : Bool . unit) then (succ c) else ({ * (Nat -> B) , (\ b : Bool . unit) } as Nat))) ((b c) (\ b : B . (fix true))))
((inert [ ({ b : Bool , c : String }) ]) [ ({ Some C , ({ a : B , d : ({ b : Float , b : A }) }) }) ])
({ c = ((succ c) as (All E . Unit)) , d = ((if (pred a) then (fix 0) else (inert [ String ])) as ({ Some A , ({ Some D , Nat }) })) })
(\ c : (All E . (B -> Nat)) . ((let d = false in false) [ ({ Some E , Unit }) ]))
((fix (succ false)) [ ({ e : ({ c : ({ Some E , A }) , b : ({ Some C , Float }) }) , b : ({ d : (All D . Bool) , e : (B -> String) }) }) ])
(\ a : ({ Some A , (All E . String) }) . (({ a = unit , a = (if "boy" then true else b) }) [ (({ Some B , Float }) -> ({ Some B , String })) ]))
({ * ({ Some D , (Nat -> Float) }) , (\ b : ({ Some E , Nat }) . ({ e = unit , a = a })) } as ({ a : ({ Some D , C }) , e : (All A . ({ a : C , c : Float })) }))
((\ C . (\ E . (iszero false))) [ (All C . ({ Some C , Nat })) ])
(succ ((succ (fix "boy")) [ (({ d : String , b : Unit }) -> (B -> (C -> String))) ]))
({ * ({ e : ((All B . Nat) -> ({ b : Unit , a : Nat })) , e : ({ c : (Bool -> C) , a : (All C . String) }) }) , (let { C , a } = (fix ({ * C , 0 } as B)) in (\ a : (All C . B) . (iszero c))) } as (({ Some A , (All D . Nat) }) -> (Unit -> String)))
(\ d : ((All E . ((All B . Unit) -> (All C . Float))) -> ({ d : (All D . Unit) , e : (Float -> C) })) . (inert [ ({ Some C , ({ d : (Nat -> A) , d : ({ Some C , B }) }) }) ]))
((pred (inert [ C ])) [ ({ d : ({ b : (Bool -> Unit) , d : ({ Some E , String }) }) , b : (All D . B) }) ])
(fix ((\ e : ({ a : A , e : Unit }) . (\ a : B . a)) as ({ Some B , B })))
(succ ((c [ ({ e : A , a : B }) ]) (iszero (\ A . "boy"))))
((succ (true [ ({ a : Bool , e : Unit }) ])) as (All B . ({ e : Float , e : (C -> B) })))
(if ((unit as (Unit -> String)) as (Nat -> (C -> Float))) then (iszero ({ * ({ Some E , String }) , (iszero false) } as Bool)) else (pred (let { D , c } = (fix 2) in c)))
((\ D . (fix (succ b))) (pred (pred false)))
(\ a : ({ Some A , (C -> B) }) . ((pred ("boy" [ Bool ])) . d))
(let b = (succ (pred b)) in (let { D , d } = (iszero (let b = (\ a : B . 2) in b)) in (\ d : Unit . ({ c = "boy" , b = 2 }))))
({ * (({ b : Float , c : Bool }) -> (All D . Float)) , (\ A . (pred ({ * Bool , unit } as B))) } as (All C . ({ b : ({ Some C , B }) , d : (All E . A) })))
((if (let { C , d } = (let c = a in "apple") in (let a = b in 2)) then (pred "apple") else (succ c)) . b)
(((pred "boy") [ (All A . Nat) ]) . c)
(\ A . (({ * Float , unit } as Nat) . d))
({ d = (pred (succ b)) , c = (fix (b false)) })
(if (pred (if ({ * A , 1 } as Float) then b else (inert [ Nat ]))) then (let { E , d } = (b "boy") in (pred b)) else (pred (fix unit)))
(if (inert [ ({ d : (All D . Bool) , c : B }) ]) then ((\ C . c) as ({ b : String , c : A })) else (if ((\ E . (let d = 0 in unit)) [ (String -> String) ]) then (fix false) else ({ * (All B . C) , (iszero b) } as (All D . ({ b : Nat , b : Nat })))))
(fix (inert [ ({ Some C , Unit }) ]))
((({ d = true , b = false }) as ({ Some B , ({ Some E , Unit }) })) (\ c : (All D . (A -> Nat)) . ((let { D , a } = "boy" in 1) as (All D . Unit))))
(if (let c = (if c then true else 1) in (\ A . 0)) then (let d = (\ B . (b [ A ])) in (let e = unit in a)) else (inert [ ({ d : String , e : (All C . Unit) }) ]))
(pred ({ c = (iszero ({ * (All D . Bool) , 2 } as B)) , e = (iszero (fix true)) }))
({ * ({ Some B , (All A . (C -> A)) }) , (pred (\ E . unit)) } as ({ d : (All A . A) , a : (All C . ({ Some B , Float })) }))
(\ B . ((a 2) (inert [ B ])))
(let c = (\ b : ({ e : (String -> (All A . C)) , e : ({ Some A , Nat }) }) . (succ (a as Bool))) in (pred (iszero (0 [ Bool ]))))
(pred (let c = (if b then 2 else 2) in (c false)))
((inert [ ({ Some A , ({ Some B , Unit }) }) ]) [ (All A . ({ Some A , ({ d : Float , a : B }) })) ])
(if (pred (1 [ A ])) then (let { D , d } = ({ b = unit , a = (let e = "apple" in false) }) in (if 0 then (\ E . b) else "boy")) else (iszero (let { E , c } = 0 in (let { B , b } = c in "apple"))))
(let c = ({ b = (a as A) , e = (\ e : ({ e : Nat , d : Float }) . (fix unit)) }) in (\ b : (All B . (C -> ({ e : C , d : Float }))) . (inert [ (A -> String) ])))
(((fix (succ 2)) as (All A . ({ a : ({ a : Unit , d : Bool }) , d : (All A . Bool) }))) as (All C . ({ Some D , A })))
(\ C . (\ E . (succ (\ a : Nat . false))))
(\ D . (fix (inert [ Bool ])))
((succ (true . e)) as ({ b : (All A . B) , c : (C -> String) }))
(fix (inert [ (All C . B) ]))
(fix (({ a = ({ * C , unit } as B) , b = 0 }) [ ({ Some E , B }) ]))
(pred (\ A . (inert [ C ])))
(({ * ({ Some A , ({ Some D , Float }) }) , (2 as Unit) } as (All C . C)) [ ({ c : ({ e : ({ Some A , Float }) , e : C }) , a : (Float -> ({ a : Bool , a : Unit })) }) ])
(inert [ ({ Some A , ({ b : A , d : (Nat -> C) }) }) ])
((((a true) . e) . d) [ ({ Some A , ({ b : ({ b : String , b : Float }) , d : C }) }) ])
((inert [ (({ c : (All A . B) , a : Nat }) -> ({ d : (Float -> B) , a : ({ Some A , C }) })) ]) (iszero (inert [ C ])))
(\ c : (All E . ({ b : String , d : String })) . ((\ b : ({ Some B , ({ a : C , d : B }) }) . ((iszero true) . b)) [ ({ Some B , ({ Some B , A }) }) ]))
(let { E , e } = ((iszero c) . d) in (inert [ (Nat -> Float) ]))
(let { C , d } = (\ D . ({ d = 0 , e = (true [ Unit ]) })) in ((b "apple") as (All B . ({ e : Float , b : Bool }))))
(iszero (let { D , b } = (1 unit) in (iszero a)))
(iszero ((\ e : C . b) [ ({ Some A , Unit }) ]))
((((succ b) as ({ e : Bool , d : String })) (iszero ({ * C , unit } as Float))) [ ({ d : (All B . (All C . B)) , d : ({ c : A , e : Unit }) }) ])
({ * (({ Some D , ({ e : String , b : Unit }) }) -> ({ Some D , ({ Some B , Bool }) })) , ((iszero 2) as ({ Some C , C })) } as ({ e : ({ Some A , ({ Some E , Unit }) }) , e : ({ Some B , (All C . B) }) }))
(inert [ ({ Some D , ({ c : (Unit -> ({ b : Bool , d : String })) , a : (({ d : A , b : A }) -> C) }) }) ])
({ e = ({ * ({ Some A , B }) , (succ c) } as ({ Some D , Float })) , e = (iszero (if unit then "boy" else 1)) })
(if ({ d = (iszero 0) , d = ((let { D , e } = c in "apple") (pred a)) }) then (inert [ ({ Some C , A }) ]) else (if (fix true) then (let { B , e } = false in 1) else (\ D . "boy")))
({ * ({ b : ({ b : ({ Some A , Nat }) , c : ({ b : A , c : Nat }) }) , b : (C -> Unit) }) , (inert [ (All B . ({ a : Unit , a : Float })) ]) } as (All C . ({ Some D , B })))
(let e = (let { D , e } = (({ * C , 2 } as B) (fix a)) in (0 [ B ])) in ((if (\ A . false) then (inert [ C ]) else ({ e = b , d = false })) [ (All A . (All C . C)) ]))
(let a = ({ b = ({ * Nat , (let a = "apple" in 0) } as Float) , e = (\ C . "apple") }) in (let b = (succ (succ (\ c : A . 1))) in ({ b = (inert [ Unit ]) , a = (let a = "boy" in "boy") })))
(\ e : ({ d : (All E . ({ Some C , (Bool -> Float) })) , b : ({ Some D , (({ Some E , String }) -> Float) }) }) . (fix ({ b = 1 , e = unit })))
(((if (1 unit) then (unit [ Bool ]) else (succ "boy")) as ({ Some E , (Nat -> Nat) })) as (({ c : (Unit -> Nat) , d : Unit }) -> ({ Some D , (All E . Float) })))
(\ A . (pred (iszero (inert [ (Float -> Bool) ]))))
((inert [ ({ Some D , (All D . B) }) ]) as ((All E . B) -> (({ Some E , B }) -> ({ d : Nat , c : B }))))
((iszero (if (let a = 0 in "boy") then (let b = 0 in "boy") else (if "boy" then 2 else b))) . e)
(({ * (All B . ({ e : Nat , e : String })) , (if (\ e : (All C . Float) . (let a = c in 0)) then (b . d) else (\ A . true)) } as ({ e : ({ Some C , B }) , a : (({ Some B , Unit }) -> Float) })) . d)
(inert [ ({ Some E , (({ Some E , C }) -> String) }) ])
(iszero (if ((pred "boy") 1) then (pred a) else (let e = 2 in 2)))
(succ (let { B , c } = (\ a : ({ Some D , (B -> Unit) }) . (\ e : Unit . b)) in (succ (false c))))
(((iszero (pred 1)) ((a [ Float ]) . d)) (inert [ ({ Some D , Nat }) ]))
(let a = (iszero (let { E , d } = (fix c) in (\ C . "apple"))) in (\ C . (\ E . "apple")))
(\ a : ({ Some A , (All E . (C -> (B -> Unit))) }) . (let { C , a } = (\ b : ({ a : String , d : B }) . "apple") in (2 as ({ b : C , c : String }))))
((\ E . (let { D , d } = "boy" in false)) as (All E . ({ e : (All C . (All E . Bool)) , e : (A -> String) })))
(\ B . (if (fix (b false)) then ((succ c) ((inert [ String ]) . e)) else ({ e = (succ a) , d = (iszero a) })))
(pred (let a = (a . e) in (let b = a in unit)))
(let b = (\ B . ((\ b : Unit . false) ("boy" . a))) in (fix (succ ("apple" . d))))
(let c = ((iszero "boy") (iszero "boy")) in (\ B . (iszero a)))
(\ e : ((All C . ({ c : ({ d : Bool , e : String }) , c : A })) -> (({ c : Unit , a : Bool }) -> ({ d : ({ Some E , String }) , c : (Unit -> Unit) }))) . ((\ A . (false c)) [ (All A . A) ]))
((if (let { C , b } = (let c = false in a) in (if unit then (fix c) else 1)) then (\ C . ({ b = b , e = c })) else ({ * Nat , (\ E . 0) } as Unit)) . d)
(pred ({ * (({ Some B , (String -> Unit) }) -> ({ e : Float , a : ({ Some B , A }) })) , (if ({ e = (\ a : Nat . true) , d = (\ B . 2) }) then (2 unit) else (inert [ String ])) } as ({ Some E , ({ Some C , C }) })))
(\ A . (fix (pred (false as C))))
(let d = (pred (fix false)) in (let b = (\ B . false) in (\ E . (\ e : Unit . unit))))
((let { D , e } = (if (\ b : Bool . a) then (succ unit) else (succ 2)) in ((inert [ A ]) (2 as (All A . B)))) [ ({ d : (All C . ({ Some A , Unit })) , c : ({ Some C , ({ Some A , Nat }) }) }) ])
(succ (\ c : ({ Some E , C }) . (let d = (succ "boy") in "boy")))
(\ A . ({ * ({ a : String , d : Unit }) , (if false then (pred 1) else 0) } as (({ Some A , Bool }) -> Bool)))
(let { A , b } = ((true . e) as (All C . ((All C . A) -> String))) in ((inert [ Bool ]) . d))
(iszero (if ({ * String , a } as Float) then (\ b : (All A . B) . false) else (2 . b)))
((succ (fix "apple")) (\ d : ({ a : ({ b : A , e : B }) , a : C }) . ("boy" . c)))
((inert [ ({ Some B , A }) ]) . c)
(((\ b : A . true) as ({ Some B , (All E . B) })) (let { C , b } = (let e = 1 in a) in (a as B)))
(if (((b . a) [ ({ Some D , Bool }) ]) [ (All E . ({ Some A , Bool })) ]) then (\ C . ({ a = "boy" , e = "apple" })) else (inert [ ((All D . Unit) -> (Unit -> Bool)) ]))
(\ D . ((inert [ Unit ]) (iszero 2)))
((inert [ (All A . ({ Some C , Float })) ]) (iszero (inert [ (All A . String) ])))
((let d = ({ a = (succ c) , a = b }) in ("boy" . b)) as (((All B . Nat) -> Float) -> (All A . ({ c : Nat , c : A }))))
((inert [ ({ a : Nat , a : String }) ]) as ((All A . (All B . Unit)) -> ({ Some A , ({ Some D , String }) })))
({ b = (let { E , e } = (let c = (let { D , b } = 2 in c) in (("boy" c) as Nat)) in ({ * Unit , unit } as ({ e : String , d : Nat }))) , b = (fix (let e = 2 in b)) })
(pred (succ (\ C . ({ * String , false } as B))))
(((pred (b as A)) as (Unit -> ({ c : String , b : Unit }))) . d)
({ * (All C . (All E . (Nat -> B))) , (let e = (\ B . a) in (unit true)) } as (All C . (Nat -> Float)))
((\ B . (({ * A , c } as Unit) as Float)) (((succ b) . d) ((1 . d) . d)))
(if (iszero ({ a = true , b = a })) then (fix (pred true)) else ({ * ({ a : B , e : Float }) , (c [ A ]) } as ((All A . Bool) -> Nat)))
(succ (iszero (pred (1 [ Float ]))))
(((if 2 then (1 [ A ]) else b) . a) [ ((All A . Bool) -> (All D . Bool)) ])
((let a = ({ d = ((let e = "boy" in a) a) , b = (let e = 1 in 2) }) in ({ * (All A . Nat) , ((pred 1) [ String ]) } as ({ a : Bool , b : A }))) as ({ Some E , ({ b : Unit , a : A }) }))
(succ (iszero (unit as Float)))
(((succ "apple") as ((A -> B) -> ({ d : Float , b : ({ b : Float , a : Nat }) }))) . e)
({ * (({ Some B , (String -> A) }) -> ({ Some D , String })) , (fix ((let { E , c } = 1 in 0) . e)) } as (All E . ({ Some D , A })))
(\ c : ({ Some C , ({ b : Unit , c : C }) }) . (succ (true . d)))
(fix (\ d : ({ d : Float , b : Unit }) . (\ b : String . c)))
(iszero (iszero ({ * ({ Some D , Unit }) , true } as ({ Some E , B }))))
(inert [ (All B . ({ Some A , Float })) ])
(inert [ ({ e : (All B . ({ Some A , Float })) , e : ((({ b : Unit , a : Nat }) -> C) -> (Bool -> Unit)) }) ])
(fix (let { C , b } = (pred (b . e)) in (\ D . (a as C))))
((inert [ ({ Some B , Unit }) ]) (pred (if unit then b else "apple")))
(pred ({ * ({ Some A , (({ b : String , e : A }) -> (Float -> Nat)) }) , (inert [ (All D . Bool) ]) } as (All C . ({ Some D , Bool }))))
(let { D , a } = ((let { C , b } = (let a = a in b) in (succ a)) . b) in ((let { A , a } = (fix c) in (\ C . (unit [ Bool ]))) . a))
(if (\ c : ({ Some D , (All A . Unit) }) . (succ (let { D , c } = b in (false as Float)))) then (succ (let a = (iszero "boy") in (fix false))) else (pred ({ a = false , b = (a "apple") })))
(pred (inert [ (All A . Bool) ]))
(\ D . (succ (inert [ A ])))
(iszero (\ c : (All A . (A -> B)) . (inert [ (String -> A) ])))
(fix ((c . d) [ (C -> B) ]))
(let a = ({ c = ((iszero "apple") [ (All A . String) ]) , d = (\ C . (fix c)) }) in (iszero ({ d = (2 c) , d = "apple" })))
(pred ({ * ({ Some D , ({ Some D , C }) }) , (fix (inert [ String ])) } as (All D . ({ Some D , Bool }))))
((\ a : ({ Some A , A }) . (unit [ ({ Some B , Bool }) ])) [ (All A . ({ d : (All D . Bool) , a : ({ a : Unit , d : A }) })) ])
(((\ d : A . true) . d) as ({ Some A , ({ b : ({ Some B , A }) , e : (All C . A) }) }))
(let { A , a } = (succ ({ b = (pred (b [ Unit ])) , c = (c [ String ]) })) in (((\ e : A . b) as ({ Some E , (All C . Nat) })) [ (All C . ({ Some E , Bool })) ]))
({ d = (\ c : ({ e : (All A . Unit) , e : ({ c : ({ c : Unit , b : A }) , b : String }) }) . ({ a = a , e = 2 })) , a = (pred (pred a)) })
(let c = (if (inert [ Nat ]) then (succ a) else (pred (\ E . false))) in ({ * ({ a : Nat , c : ({ Some E , A }) }) , (unit b) } as (C -> C)))
(((\ a : ({ Some D , String }) . (pred true)) . c) ({ * (All E . C) , ({ * (Nat -> B) , 0 } as Bool) } as ((String -> ({ b : B , e : Nat })) -> ({ c : C , a : String }))))
(\ B . (fix (fix (succ false))))
((({ * Float , (succ "boy") } as Nat) ({ e = ((pred c) [ C ]) , d = (\ c : ({ Some B , String }) . 0) })) [ ({ Some D , (All E . String) }) ])
(if (((iszero a) . e) (iszero c)) then ({ * ({ Some E , A }) , (succ (unit as Float)) } as (All A . String)) else (iszero ((c as A) as (All D . Unit))))
({ * ({ a : ({ Some B , (All B . Unit) }) , e : ({ b : ({ Some A , String }) , e : ({ Some A , C }) }) }) , (fix (let { A , a } = (let { D , c } = true in "boy") in (succ false))) } as (({ c : ({ Some D , B }) , a : ({ c : Float , d : Nat }) }) -> ({ c : (All A . Unit) , a : ({ Some A , Float }) })))
(let { D , e } = ((succ (pred true)) as (All A . Unit)) in (if (iszero "boy") then ((inert [ C ]) as (All A . Bool)) else (iszero "boy")))
(fix (fix ((inert [ Nat ]) . b)))
(fix ((succ a) as ({ Some B , B })))
((inert [ (String -> B) ]) as ({ d : ({ Some B , Unit }) , e : ({ Some A , ({ d : Float , e : ({ Some C , String }) }) }) }))
((pred (iszero "apple")) (\ e : ({ b : (All B . String) , c : Float }) . ({ a = (let { E , e } = a in a) , c = (2 [ Unit ]) })))
((let c = (iszero ({ d = true , e = (let d = 2 in unit) })) in (\ C . unit)) . e)
(\ d : ({ Some B , ({ e : B , a : Nat }) }) . (let b = (({ e = "boy" , b = true }) (iszero (let { B , b } = 2 in a))) in (succ (c . e))))
(iszero ((("boy" . a) . a) . e))
({ * ({ Some B , ({ Some C , Bool }) }) , (fix (\ a : (Bool -> Nat) . (\ d : (All C . Bool) . true))) } as (All A . (All E . (B -> C))))
({ b = (\ b : (All C . (All D . Bool)) . (0 . c)) , a = ((if b then true else 0) [ ({ a : A , b : Unit }) ]) })
((fix (\ b : (All C . C) . c)) as ({ Some E , ({ Some E , Float }) }))
(let { D , e } = (\ A . (inert [ (A -> C) ])) in (fix (iszero c)))
({ * (({ e : Unit , a : (All C . A) }) -> ({ a : (Unit -> C) , a : String })) , (let { E , c } = ({ a = "apple" , c = (if 0 then a else 0) }) in (\ C . (false . c))) } as (All B . ({ Some B , Float })))
(pred (succ (2 [ ({ d : C , b : Unit }) ])))
(inert [ ({ Some C , (All A . (All D . ({ e : Bool , c : Nat }))) }) ])
(inert [ (All B . ({ a : ({ Some B , Nat }) , a : C })) ])
(((let b = (let { D , b } = 0 in 2) in ({ d = b , b = 0 })) ({ d = b , a = (inert [ Bool ]) })) ({ * (All C . ({ d : ({ Some E , B }) , d : (Bool -> Unit) })) , (let { B , d } = (let e = c in 1) in 2) } as (All C . (({ Some C , C }) -> Unit))))
(fix ({ c = (iszero (fix 0)) , a = (pred ("apple" as B)) }))
(\ a : (({ Some D , A }) -> (All B . Bool)) . (inert [ ((({ Some D , B }) -> Nat) -> ({ a : C , b : A })) ]))
({ d = (pred (\ b : ({ Some A , String }) . (b 0))) , d = (if (fix (pred ("boy" . e))) then (pred (pred c)) else ({ * C , (let { B , c } = b in 0) } as (Bool -> Nat))) })
({ * ({ Some C , (({ Some A , C }) -> Bool) }) , ((fix (succ unit)) (fix unit)) } as ({ e : (All A . ({ Some D , (Unit -> Unit) })) , e : ({ Some B , (All D . B) }) }))
(\ A . ({ a = (2 0) , d = ({ d = (c [ Unit ]) , e = false }) }))
(fix ((let e = false in 2) (iszero ({ * C , 1 } as C))))
(\ A . (((({ * Nat , true } as Bool) as (All C . Nat)) [ ({ a : (All A . A) , e : (All C . String) }) ]) ((iszero unit) as C)))
(pred (let b = ({ b = c , d = (iszero 2) }) in (c . d)))
(let { A , e } = (\ b : ({ Some A , ({ Some D , ({ Some C , B }) }) }) . ((\ d : (All E . Nat) . 1) ({ * ({ Some E , Bool }) , "boy" } as Float))) in (\ C . (c as ({ Some C , B }))))
(succ (fix ({ * String , "boy" } as Nat)))
(let { E , b } = (if ((succ (\ c : Bool . unit)) (pred (true [ Unit ]))) then ({ c = unit , d = b }) else (inert [ (Float -> Nat) ])) in (fix (let { C , a } = a in "boy")))
(((\ A . (2 . c)) ((succ false) . a)) [ (({ Some A , Float }) -> (All C . Unit)) ])
(((succ (let { B , a } = false in a)) . d) . a)
(fix (let { D , c } = ((let b = 0 in c) as Bool) in ((false . a) as Nat)))
((\ C . (let { A , c } = (iszero 2) in (let { A , d } = unit in 1))) ((let c = (inert [ (String -> Nat) ]) in (iszero b)) . e))
(let d = (fix (let e = (if true then (if 0 then 0 else true) else true) in (let d = 2 in (c . c)))) in (succ (fix a)))
(let { A , e } = (\ b : ({ Some A , (All E . Float) }) . ((let d = false in 1) as Unit)) in ((iszero true) as ({ Some C , B })))
((let { A , d } = ((iszero "boy") (pred true)) in (\ e : ({ Some C , Nat }) . (0 as String))) as (({ Some A , Bool }) -> ({ c : String , a : C })))
((({ * (All B . B) , ({ * B , 2 } as C) } as ({ e : (All D . A) , a : ({ Some E , Nat }) })) [ ({ Some B , String }) ]) (fix ({ c = a , a = true })))
(((let d = true in 2) . d) [ ({ Some A , ({ c : C , c : Unit }) }) ])
(pred ((succ (pred 1)) [ ({ Some A , ({ Some E , Nat }) }) ]))
(fix (if (unit [ String ]) then (if a then "apple" else (if "apple" then 2 else 2)) else (let { A , b } = "apple" in ({ c = b , a = a }))))
({ * (All E . ({ a : ((All B . Float) -> ({ a : B , a : Nat })) , e : ({ e : String , e : String }) })) , (fix ((\ C . "boy") (if (succ 2) then (iszero "apple") else 2))) } as ((({ Some C , String }) -> ({ b : Unit , a : String })) -> (({ c : Unit , c : Float }) -> (All B . B))))
({ b = (inert [ (({ d : A , c : C }) -> C) ]) , d = (let b = (inert [ (String -> B) ]) in (iszero (let b = unit in c))) })
(((inert [ String ]) [ (String -> Float) ]) (("apple" [ (All D . Nat) ]) . e))
(let d = (if (1 . e) then (succ ({ b = unit , c = a })) else (inert [ C ])) in ((pred c) (\ A . unit)))
(inert [ ((All B . C) -> ({ e : (B -> Float) , c : (All A . Nat) })) ])
(pred ({ b = ({ a = (pred 2) , e = (iszero c) }) , a = ({ * ({ Some B , A }) , ((inert [ B ]) . d) } as ({ Some B , B })) }))
(let c = (iszero (let { D , b } = (fix 0) in (inert [ String ]))) in ({ * (({ c : B , a : A }) -> (Unit -> C)) , (\ b : (Float -> Bool) . 1) } as ({ c : Bool , c : Unit })))
((iszero (succ (let { E , b } = unit in b))) . a)
(succ ((\ E . (if 0 then unit else 0)) [ (All D . C) ]))
(\ a : ({ b : ({ c : B , c : Unit }) , b : (All B . Float) }) . ({ a = (\ a : ({ Some A , C }) . (pred (inert [ A ]))) , c = ((\ b : A . a) c) }))
(pred (fix (\ B . false)))
(\ b : ((({ b : B , b : B }) -> Float) -> ({ e : B , d : A })) . ({ * ((A -> C) -> Float) , ({ b = unit , e = c }) } as (String -> C)))
(fix (iszero ({ * C , ({ * C , 1 } as C) } as (All E . B))))
({ d = ((pred c) as (All D . A)) , e = ((fix (inert [ Unit ])) ({ * Bool , true } as C)) })
(\ C . (fix (inert [ C ])))
(\ b : ({ b : (Unit -> Bool) , c : (({ b : Float , b : Nat }) -> B) }) . (pred (let a = (inert [ Float ]) in ({ * ({ d : C , e : Float }) , (inert [ Bool ]) } as (Unit -> C)))))
({ c = (succ (if "apple" then (let c = false in "boy") else true)) , e = (({ b = (\ C . 1) , e = (succ ({ * A , 2 } as Nat)) }) (if (succ false) then (1 [ Unit ]) else (true as String))) })
({ d = ((c as Bool) . b) , e = ((\ A . ({ e = unit , a = unit })) . d) })
(({ * (All A . String) , (let { D , e } = false in (succ c)) } as (All A . (String -> C))) (iszero (inert [ ({ c : C , b : Unit }) ])))
(((let { B , a } = unit in ("apple" b)) (((succ unit) 2) as (Unit -> Float))) (\ C . ((\ b : String . "boy") . b)))
((let d = (inert [ ({ Some B , C }) ]) in ((if 1 then a else 2) . e)) . e)
({ * (All E . (({ e : String , b : A }) -> ((Bool -> Nat) -> ({ c : String , d : Float })))) , (({ a = (c [ Nat ]) , e = true }) as ({ Some A , ({ c : String , b : Unit }) })) } as (All D . ({ Some A , Nat })))
({ * ({ Some E , ({ b : ({ Some E , Nat }) , b : Nat }) }) , ((\ A . ({ * Unit , a } as String)) [ (All D . ({ c : Bool , c : Bool })) ]) } as ({ c : (All C . ({ c : Nat , b : Unit })) , e : (Nat -> Bool) }))
(\ d : ({ a : ({ b : (All C . A) , e : ({ Some D , Unit }) }) , e : ({ e : Float , b : (B -> B) }) }) . (let c = ((a [ C ]) as ({ e : Bool , e : Nat })) in ((inert [ Unit ]) [ (All E . ({ c : String , e : Float })) ])))
(pred (((true unit) . c) [ (B -> A) ]))
((\ e : (({ Some E , ({ c : Float , e : A }) }) -> ({ c : Unit , c : Bool })) . (c . d)) (iszero (iszero false)))
(iszero (pred (fix 1)))
((\ C . (let e = (iszero true) in (if c then a else "boy"))) . d)
(inert [ ({ Some C , ({ Some C , ({ Some C , Unit }) }) }) ])
(fix ({ b = ({ c = (\ D . unit) , e = (if 2 then c else unit) }) , e = (pred (1 as String)) }))
({ b = (iszero (succ unit)) , a = (iszero (succ (let a = "apple" in "boy"))) })
((if (if true then 0 else "boy") then ("boy" [ (All A . Float) ]) else (fix (let a = 0 in b))) ((\ A . (iszero c)) . b))
((((succ "apple") [ (A -> String) ]) . b) [ ({ b : ({ Some D , ({ Some D , String }) }) , e : ({ Some A , ({ Some C , Nat }) }) }) ])
(\ C . (iszero (\ A . (\ b : Bool . "boy"))))
(pred (\ E . (pred unit)))
({ c = (\ B . (succ (pred a))) , a = ({ * ({ Some E , A }) , ("apple" as (All C . Unit)) } as ({ Some B , ({ Some D , Unit }) })) })
(\ C . (if (if "apple" then (let a = a in "boy") else (0 false)) then (pred 1) else (\ B . (\ e : Float . 1))))
({ b = (pred (\ D . ({ * ({ c : Bool , b : A }) , b } as Bool))) , c = ((pred false) as (All A . Bool)) })
(fix (let d = (iszero (\ C . unit)) in (inert [ A ])))
(iszero (((\ c : (All B . String) . (let { D , e } = "boy" in 2)) (let { B , e } = true in true)) as ({ Some C , ({ e : Unit , c : (Float -> Unit) }) })))
(\ A . (let c = ({ * (All E . Unit) , (let { C , d } = ({ a = a , d = 0 }) in (true [ Float ])) } as (Unit -> Nat)) in (pred (pred c))))
((((1 [ Unit ]) (inert [ Float ])) . c) . b)
(succ (let e = (if unit then true else (unit as Bool)) in ({ c = ({ * ({ c : B , c : Nat }) , "apple" } as ({ Some A , C })) , b = ((\ a : String . "boy") . e) })))
(inert [ ({ d : (String -> Nat) , d : (All E . A) }) ])
((fix (2 as ({ d : Nat , a : Float }))) . a)
({ b = (fix (if (inert [ Bool ]) then unit else (let { A , d } = true in "boy"))) , e = ((pred "apple") [ (All B . Nat) ]) })
({ * (All E . ({ Some A , ({ Some B , String }) })) , (succ (\ c : B . "boy")) } as (All D . (All C . Bool)))
(succ (let c = ("apple" as (Bool -> C)) in ((a "boy") . a)))
(let { D , b } = (let { B , b } = ((let { A , b } = a in "boy") as Unit) in (iszero a)) in (if ({ * Unit , (\ e : B . false) } as A) then ({ b = unit , c = "boy" }) else (pred b)))
((inert [ ({ e : (Nat -> Nat) , e : ({ Some D , Nat }) }) ]) . e)
(let { D , d } = ((1 [ C ]) . e) in (inert [ (B -> ({ Some C , Nat })) ]))
(\ D . (succ (let e = (let { E , e } = (pred false) in (\ c : Float . c)) in (\ A . (let a = 1 in "boy")))))
(\ E . (\ a : ({ Some A , (All C . C) }) . (if a then "apple" else c)))
(let a = (\ b : ({ b : ({ Some E , A }) , b : C }) . ({ c = (if 2 then false else b) , e = (\ B . (let { A , d } = unit in "apple")) })) in ((let { C , e } = (inert [ B ]) in (iszero true)) (if (let { E , d } = b in 0) then (fix a) else (\ B . c))))
((let { B , e } = (let { A , c } = true in (pred b)) in (iszero ({ * String , c } as Float))) . a)
(if ({ e = (let a = (a [ (Nat -> C) ]) in ((succ "apple") . a)) , c = ({ * (All D . Unit) , (iszero false) } as (All D . ({ Some B , B }))) }) then (if (succ b) then (let d = (fix c) in (inert [ String ])) else (fix ({ b = (\ D . unit) , a = (let a = "apple" in "boy") }))) else (let { A , b } = (\ C . (let c = b in 1)) in ((\ d : ({ e : A , a : B }) . a) . a)))
(pred (fix ({ * String , (let a = b in 0) } as ({ Some E , C }))))
(fix (if (let { C , b } = (c [ Float ]) in (succ true)) then (pred (0 as C)) else (0 ("boy" . e))))
(inert [ (All D . ({ Some A , A })) ])
(if ((0 [ Nat ]) [ ((All B . C) -> Unit) ]) then ((let d = (1 as String) in 1) (inert [ Bool ])) else (\ b : (All C . (All A . ({ d : A , e : Bool }))) . (let { E , b } = ((iszero b) as A) in (\ c : Unit . "apple"))))
(\ C . ((pred (c . e)) . b))
(\ C . (fix ({ * String , "apple" } as Bool)))
((inert [ (All E . (Float -> Float)) ]) [ (({ Some D , (String -> Nat) }) -> (({ a : Bool , d : (All D . C) }) -> (Nat -> Nat))) ])
(({ c = (2 [ ({ Some A , A }) ]) , c = ((fix unit) [ A ]) }) . a)
(if (((c [ Unit ]) [ (Float -> Nat) ]) . a) then (let { E , c } = ({ b = (iszero 1) , a = (iszero "boy") }) in (fix true)) else ({ * (Bool -> Nat) , ({ * B , a } as A) } as (Nat -> String)))
(fix ((let b = 2 in b) . d))
({ * ({ Some A , ({ c : ({ Some A , B }) , d : ({ e : B , d : (C -> C) }) }) }) , (let c = (\ a : Nat . 2) in (fix true)) } as (({ b : Unit , b : A }) -> ({ Some C , ({ d : C , d : Float }) })))
((let a = ({ * (({ Some C , Nat }) -> (All A . Bool)) , (a [ Unit ]) } as ((Unit -> B) -> Nat)) in (pred (inert [ ({ Some B , String }) ]))) . c)
(\ e : (All C . ({ Some A , ({ Some C , Bool }) })) . (((inert [ Nat ]) [ (All B . B) ]) as ({ Some C , A })))
({ c = ({ * (All C . String) , (\ D . "boy") } as ({ Some C , C })) , c = (iszero (false . d)) })
(let a = (\ e : (All A . ({ a : Float , c : B })) . ("apple" as A)) in (\ a : ({ Some C , A }) . ({ c = b , a = (inert [ Nat ]) })))
