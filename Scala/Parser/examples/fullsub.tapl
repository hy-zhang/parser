\x:Top. x
(\x:Top. x) (\x:Top. x)
(\x:Top->Top. x) (\x:Top. x)
(\r:{x:Top->Top}. r.x r.x) {x=\z:Top.z, y=\z:Top.z}
"hello"
unit
unit as Unit
\x:A. x
let x=true in x
{x=true, y=false} 
{x=true, y=false}.x
if true then {x=true,y=false,a=false} else {y=false,x=true,b=false}
\x:Bool. x
(\x:Bool->Bool. if x false then true else false) (\x:Bool. if x then false else true)
\x:Nat. succ x
(\x:Nat. succ (succ x)) (succ 0) 
\f:Nat->Nat. \x:Nat. f (f x)
(if ((\ d : ({ e : C , a : B }) . unit) as (Nat -> Nat)) then (if (iszero false) then (inert [ (({ a : Top , b : B }) -> Bool) ]) else ({ c = "apple" , d = 0 })) else ((iszero "boy") as ({ a : B , c : C })))
(succ (if (let d = (true 2) in (1 false)) then (succ 0) else (inert [ ({ b : A , e : String }) ])))
(pred ({ d = ("apple" . b) , e = (let a = (fix b) in (c "apple")) }))
(let b = (if (let a = (inert [ B ]) in (fix 1)) then (if (1 as Bool) then (if b then false else b) else (pred (pred 1))) else (pred (if a then 2 else true))) in (inert [ (String -> C) ]))
(succ (\ e : (String -> C) . (inert [ ({ c : Top , a : C }) ])))
((iszero (true . d)) as (((A -> B) -> ({ c : C , d : Unit })) -> (B -> Float)))
(pred ((fix 2) (let d = (fix 0) in ((fix false) unit))))
(iszero (iszero (succ (if "boy" then false else 2))))
(if ((iszero (fix "boy")) . e) then (\ d : ({ c : ({ a : Float , d : A }) , e : ({ d : Unit , d : B }) }) . (let c = (fix ({ c = b , d = "apple" })) in (if (if true then 0 else unit) then 2 else false))) else (({ b = true , a = (let a = a in b) }) . e))
(((\ e : B . "boy") as (C -> Nat)) ((pred (inert [ B ])) (fix 2)))
((inert [ (B -> C) ]) as (((B -> A) -> B) -> ((A -> Top) -> ({ d : ({ b : Top , e : Bool }) , c : String }))))
({ e = (let e = ({ e = 2 , e = unit }) in (true . c)) , c = (iszero (fix (let a = unit in c))) })
(succ (if (a as B) then ((fix c) . a) else (fix (fix 0))))
(if (inert [ ({ a : Bool , c : B }) ]) then (\ c : ({ b : (C -> B) , d : ({ a : Nat , d : A }) }) . (let e = 2 in (a as Unit))) else (if (succ (0 c)) then (0 as A) else ((iszero true) as (Nat -> Top))))
((((b as Float) . c) (a . e)) ((inert [ C ]) as (({ c : String , a : A }) -> ({ a : Bool , d : C }))))
(fix (succ (if (if false then 1 else a) then (let a = "boy" in 1) else b)))
((succ (succ (b . c))) (inert [ ({ b : (Nat -> A) , e : (Top -> Float) }) ]))
(let e = (if (1 b) then (\ b : Float . unit) else (a false)) in (succ (true as (Float -> C))))
(fix ({ d = (if (pred c) then (1 as Top) else (inert [ Float ])) , c = ((inert [ Float ]) 1) }))
((succ (if c then unit else (iszero 1))) as ({ c : ({ e : ({ e : ({ a : B , e : Top }) , a : ({ a : String , d : Unit }) }) , e : ({ b : A , b : Nat }) }) , a : (({ c : A , e : Bool }) -> B) }))
(fix (("boy" as ({ a : Nat , b : String })) as ({ b : ({ c : Unit , e : Float }) , a : String })))
(pred ((let d = 2 in (2 "boy")) as ((B -> A) -> (C -> Unit))))
(inert [ (({ a : ({ e : String , c : Float }) , a : Bool }) -> (A -> C)) ])
(iszero (\ d : (({ a : Top , c : C }) -> ({ a : Unit , d : Top })) . ("boy" . c)))
(pred ((let c = c in unit) as (({ b : Unit , a : Nat }) -> ({ a : Top , b : Float }))))
(pred (\ e : (({ b : Bool , e : Bool }) -> (A -> Nat)) . ((\ b : String . 1) (fix 2))))
(succ ((pred "boy") . e))
({ b = (succ (pred (if "boy" then 2 else 0))) , d = (if (inert [ B ]) then (inert [ (Top -> Nat) ]) else ((let c = (inert [ C ]) in c) . c)) })
(fix (if (let b = (b "boy") in (fix 1)) then (succ (iszero (pred unit))) else (iszero c)))
(pred (succ (0 as B)))
(let c = (((\ d : A . b) as (({ d : C , c : String }) -> C)) as ({ a : ({ d : ({ d : Bool , a : Top }) , c : B }) , e : ({ e : A , b : Bool }) })) in (\ b : ({ d : String , a : (Float -> Bool) }) . (fix (let b = 1 in c))))
({ d = (succ (pred ({ e = b , b = "boy" }))) , c = (let a = (succ (if unit then c else 0)) in ({ b = (iszero unit) , a = (2 b) })) })
((fix (pred true)) as ({ c : ({ c : String , e : C }) , e : ({ d : Bool , d : ({ a : Nat , a : A }) }) }))
(\ b : ({ a : ((A -> Float) -> (String -> String)) , b : ({ b : (Float -> B) , c : ({ b : Nat , d : Nat }) }) }) . (iszero (iszero false)))
(inert [ (({ d : (Float -> Nat) , c : (Bool -> Float) }) -> (A -> Top)) ])
(fix (({ d = 2 , b = "apple" }) . e))
(fix (let c = (inert [ ({ c : Bool , d : String }) ]) in (let b = b in b)))
(iszero ((iszero (fix ({ b = unit , e = c }))) (inert [ B ])))
(pred (fix (pred "boy")))
(fix (pred (let b = a in c)))
((pred (inert [ Top ])) . a)
(((\ d : Float . a) as ((Float -> A) -> Unit)) . e)
(inert [ (({ e : (Bool -> Unit) , d : ({ b : B , d : A }) }) -> (Top -> ({ d : Bool , d : Bool }))) ])
({ d = (iszero (\ a : (Top -> Float) . (iszero 2))) , d = (\ e : ({ b : ({ b : Nat , a : C }) , c : ({ b : Unit , c : Unit }) }) . (if (iszero false) then (pred (inert [ String ])) else (1 0))) })
(pred (({ a = (let c = unit in c) , a = (iszero c) }) (\ a : B . (iszero true))))
(iszero ((\ d : B . (succ "boy")) as ({ e : ({ d : Top , d : String }) , a : C })))
(fix (fix (let e = ({ d = 1 , e = false }) in false)))
((if ((inert [ Unit ]) as Nat) then (inert [ A ]) else (fix 2)) as ({ b : (Top -> Unit) , d : ((Unit -> A) -> ({ c : Nat , b : Top })) }))
(inert [ ({ c : (Nat -> Float) , d : ((Nat -> String) -> Bool) }) ])
((iszero (\ b : ({ d : Top , d : A }) . (let d = unit in c))) (fix ({ a = unit , e = "boy" })))
(inert [ (((Float -> (A -> Bool)) -> ({ b : Bool , e : Top })) -> ({ d : (B -> Top) , e : ({ c : ({ c : C , b : String }) , e : ({ c : Nat , b : Top }) }) })) ])
((fix (2 as Float)) as ((Top -> Float) -> ({ d : B , d : Unit })))
(succ (let a = (pred unit) in (iszero "apple")))
(fix (let c = (pred unit) in (({ b = true , e = true }) 2)))
(succ (let a = (let e = false in a) in (let e = (succ 2) in unit)))
(pred (fix (if true then 2 else 1)))
(\ b : ({ a : ({ e : Unit , c : (Unit -> B) }) , b : ({ a : Float , c : Unit }) }) . (succ (fix (let a = ({ c = 2 , d = 0 }) in "boy"))))
((succ (pred (true . e))) . c)
(\ d : ({ a : (({ d : Nat , b : Unit }) -> ({ a : Unit , a : B })) , c : (({ c : Nat , b : Float }) -> B) }) . (inert [ ({ b : ({ e : Nat , d : String }) , a : (Top -> Top) }) ]))
(pred (if ("boy" 1) then ({ e = unit , c = (1 0) }) else (fix true)))
(succ (iszero (2 as ({ c : Bool , e : A }))))
(((let c = (iszero true) in (fix "boy")) as ((Top -> A) -> Top)) . e)
(((pred (\ e : C . "apple")) as (({ e : (Nat -> Nat) , a : (Bool -> Bool) }) -> (C -> Top))) (inert [ ({ c : (B -> Nat) , d : ({ a : Float , c : Nat }) }) ]))
(inert [ ({ a : (Float -> (A -> B)) , a : (Top -> Bool) }) ])
(if ((2 . b) . c) then (({ d = (\ b : ({ b : Bool , b : Bool }) . "apple") , e = ((true as String) 2) }) as ({ c : (A -> C) , b : Unit })) else (succ (if b then false else (pred b))))
((((a . a) . b) . e) . d)
(succ (inert [ ((String -> Unit) -> (Nat -> C)) ]))
(inert [ ({ c : ((Unit -> Float) -> ({ a : Float , d : Float })) , a : ((A -> Float) -> ((Top -> String) -> (Nat -> Bool))) }) ])
((pred (("apple" as C) as (Float -> Top))) (let d = (fix (a as String)) in (pred a)))
({ b = (inert [ ({ d : Float , e : String }) ]) , d = (succ (iszero 1)) })
(succ (\ b : ({ e : (A -> Bool) , c : Float }) . (\ e : Unit . "apple")))
(iszero ({ e = (if c then 0 else "apple") , d = (pred unit) }))
(succ (succ (iszero a)))
(inert [ (({ a : ({ b : Nat , a : C }) , a : ({ b : Float , c : Unit }) }) -> ({ e : B , d : C })) ])
(if (\ c : ({ d : ({ a : Float , a : (Bool -> String) }) , c : ({ a : Bool , c : Nat }) }) . (let b = (let d = (succ true) in (let c = b in 0)) in ({ a = 2 , b = 0 }))) then (fix (fix "boy")) else ((succ 2) as (Top -> Bool)))
(pred (if (succ 0) then ({ e = 2 , e = 0 }) else ({ a = (2 . d) , c = a })))
(\ b : (({ c : Nat , c : Bool }) -> (String -> C)) . (inert [ (Nat -> (A -> B)) ]))
({ e = ({ a = (b as Nat) , d = (if (a as String) then 0 else (2 as Nat)) }) , a = ((fix (0 as A)) (unit as Unit)) })
(iszero (pred (pred (\ c : Top . true))))
(succ (let e = (succ "boy") in (iszero "apple")))
(succ (fix (fix (\ b : Unit . b))))
(pred (if (if (inert [ ({ b : Top , c : B }) ]) then (pred b) else (\ c : Bool . true)) then (iszero ({ c = 1 , e = b })) else (pred (\ c : String . (iszero 1)))))
(iszero (pred (succ ({ a = "boy" , b = 0 }))))
(succ (\ b : ((Bool -> Unit) -> ({ c : B , c : A })) . (iszero (iszero 0))))
(\ d : ({ d : (A -> A) , a : ({ d : (B -> C) , e : Top }) }) . ((let a = (b "apple") in (succ unit)) (\ b : ({ e : Nat , c : Unit }) . unit)))
(\ a : ({ e : ({ e : Float , e : Unit }) , d : (Top -> B) }) . ((((inert [ Float ]) true) . e) . e))
(fix ((c c) (succ (fix 2))))
(inert [ (({ d : ({ b : B , c : Unit }) , a : B }) -> ({ c : B , d : B })) ])
(\ b : ((Nat -> ({ c : Top , c : A })) -> ({ e : ({ a : String , e : Nat }) , d : Top })) . ((fix b) . a))
((inert [ ({ b : ({ e : ({ d : Unit , a : C }) , e : Bool }) , e : (String -> (A -> Bool)) }) ]) as (({ b : C , d : C }) -> ({ b : ({ b : Bool , b : A }) , b : ({ a : String , c : Unit }) })))
(let e = (((\ b : A . true) as C) (fix (if "boy" then 1 else 1))) in ((unit . d) ((true . d) as (Bool -> (Bool -> Float)))))
(iszero ((succ (succ "boy")) as ({ a : ({ c : Nat , b : B }) , b : ((String -> C) -> Unit) })))
(iszero (succ (\ c : ({ b : ({ a : A , a : B }) , e : Float }) . (false a))))
(fix (if (succ 1) then (true "apple") else ("apple" as (B -> Float))))
({ a = (iszero (succ b)) , c = (let e = (pred (if (if 1 then 1 else 1) then (inert [ Nat ]) else 0)) in (pred (succ true))) })
((pred (fix unit)) . c)
(iszero (inert [ ({ c : Nat , c : B }) ]))
(let b = ((iszero (fix false)) as ({ a : Top , d : (Bool -> Float) })) in ((iszero b) . e))
({ e = (\ b : ({ e : Nat , c : Unit }) . (if "apple" then 2 else false)) , c = ({ e = (succ (let d = true in "boy")) , d = (\ e : A . true) }) })
(((pred 0) . b) as ((Top -> (Top -> Float)) -> ({ b : Nat , b : Bool })))
(inert [ ((Top -> A) -> (Float -> C)) ])
(\ e : ((B -> (String -> Nat)) -> (({ e : A , a : A }) -> ({ e : Unit , a : Nat }))) . ({ e = (iszero 1) , b = (pred (pred c)) }))
(\ d : (({ d : (Nat -> Nat) , c : (Nat -> C) }) -> (({ d : String , c : Float }) -> (Top -> Top))) . (if (inert [ (Nat -> B) ]) then (inert [ ({ e : Nat , a : C }) ]) else (fix (fix true))))
((inert [ ({ e : ({ a : B , d : B }) , a : Float }) ]) . e)
(iszero ({ e = (false . d) , b = (if (0 1) then true else (\ b : Unit . "apple")) }))
((succ ("apple" unit)) (\ c : ({ b : C , d : Unit }) . (unit as Nat)))
(if (inert [ (Nat -> ({ a : Unit , b : String })) ]) then (iszero (fix true)) else (iszero (pred false)))
(if ((succ (unit as String)) as (String -> ({ e : Unit , d : B }))) then ({ b = (iszero true) , e = (1 as Top) }) else (fix (pred (inert [ B ]))))
(inert [ ({ c : ({ a : String , a : Bool }) , d : ({ c : Bool , d : Top }) }) ])
(({ a = (inert [ (C -> Nat) ]) , d = (pred (0 . e)) }) as ({ d : ({ d : C , a : Top }) , a : (({ d : Bool , e : C }) -> ({ d : ({ b : Bool , e : Top }) , a : (Nat -> Float) })) }))
(inert [ ({ e : ({ e : C , c : ({ d : Float , a : Top }) }) , b : (({ a : A , e : Top }) -> ({ e : Nat , c : (Top -> C) })) }) ])
((pred (let d = (a 0) in (pred ({ b = true , d = c })))) . e)
((inert [ (B -> B) ]) . d)
(((2 as (Unit -> Unit)) as ({ b : ({ a : A , e : Nat }) , e : ({ e : ({ e : Nat , c : Float }) , d : (A -> String) }) })) . e)
((inert [ (B -> Float) ]) . a)
(inert [ ((Nat -> String) -> (({ c : B , b : Top }) -> Float)) ])
((inert [ ({ c : Bool , c : B }) ]) . e)
((pred (pred a)) as (({ d : ({ b : B , a : Top }) , a : (({ a : Nat , b : A }) -> String) }) -> (String -> Nat)))
({ d = (\ a : ({ c : B , a : (Nat -> String) }) . (let b = 0 in 2)) , b = ((pred ({ e = 2 , b = unit })) ((iszero "boy") as Float)) })
(\ d : (({ d : (String -> Float) , b : ({ e : Bool , a : Float }) }) -> (A -> Unit)) . (\ e : (Float -> Bool) . (if (let c = "apple" in true) then (pred c) else (\ e : A . false))))
((pred (inert [ (Nat -> C) ])) . b)
(\ a : ({ e : (({ e : Nat , b : C }) -> (Unit -> C)) , c : (A -> Unit) }) . (iszero (succ (\ e : B . unit))))
((if ((true as ({ e : Nat , a : A })) (inert [ Bool ])) then ({ d = (if true then unit else "apple") , b = (true as ({ b : B , d : A })) }) else (pred (succ c))) as ({ a : ({ e : (Bool -> String) , b : ({ c : Bool , d : Float }) }) , a : ({ a : (Bool -> C) , a : (Float -> Top) }) }))
((({ b = (0 as String) , c = "boy" }) . a) (if (succ "apple") then (({ c = true , a = a }) . b) else (inert [ A ])))
(pred ((\ c : ({ d : C , b : Float }) . unit) (succ (fix (let b = "boy" in 2)))))
((succ (iszero "apple")) (if (c . a) then (iszero a) else (inert [ Nat ])))
(iszero (inert [ ({ e : (Float -> String) , b : ({ c : Unit , c : ({ d : Float , c : A }) }) }) ]))
(((succ (iszero a)) ({ e = (fix 2) , d = (c 1) })) . b)
(pred (succ ((\ e : Bool . "apple") . d)))
(inert [ (({ e : ({ b : Unit , b : Bool }) , c : (Float -> Bool) }) -> (Float -> (String -> A))) ])
(pred (if (pred (0 2)) then ((succ c) false) else (iszero b)))
((inert [ (({ b : String , b : Top }) -> (B -> Nat)) ]) . b)
(\ c : ({ b : ((Top -> A) -> A) , c : (({ c : Nat , e : Nat }) -> (B -> Float)) }) . ({ c = ({ b = (if (succ "boy") then ("boy" as Bool) else (iszero 1)) , d = (2 a) }) , a = (fix (pred 2)) }))
(pred (succ (\ a : Unit . c)))
(fix ((false . a) ((c . d) as ({ d : Unit , b : Bool }))))
(inert [ ({ c : (C -> A) , b : (A -> Top) }) ])
(pred (((pred a) as (B -> Bool)) . e))
({ b = (\ e : ({ e : (B -> Nat) , d : (Unit -> Unit) }) . (if (let a = c in 2) then c else "apple")) , a = ((\ c : (A -> Unit) . (a as Unit)) as ((Nat -> Nat) -> (Nat -> Bool))) })
(({ d = (\ d : Bool . "apple") , c = (fix a) }) . d)
(iszero (let a = (succ (fix 0)) in (inert [ ({ a : String , b : String }) ])))
((pred (pred "apple")) (inert [ (B -> Top) ]))
(((iszero 1) (0 2)) ((inert [ String ]) ({ b = "boy" , c = 2 })))
(fix (pred (pred (fix true))))
(inert [ (({ d : Float , b : ({ e : Float , d : Bool }) }) -> (({ d : Float , a : Bool }) -> ({ a : Float , d : ({ e : Nat , a : Nat }) }))) ])
(succ (pred (if "apple" then (pred 2) else a)))
(((inert [ C ]) as (Nat -> ({ d : String , e : C }))) (succ (iszero 0)))
(let a = (fix (succ (succ (pred c)))) in (iszero (("apple" as String) . e)))
(let a = ({ e = ((let c = 1 in true) . d) , a = (succ ("apple" . a)) }) in ((true b) . c))
(let c = (\ a : ({ b : (C -> C) , c : (B -> Nat) }) . (\ a : Bool . 2)) in (succ ({ e = 0 , e = false })))
((iszero (2 1)) as ((({ c : Unit , d : String }) -> C) -> (Bool -> ({ d : A , b : B }))))
(iszero (if (fix "apple") then ((iszero true) 2) else (if (let a = 1 in c) then ("apple" . e) else b)))
({ e = (succ ({ b = (iszero (if c then unit else "boy")) , c = ({ a = 1 , b = 2 }) })) , d = (fix ({ b = 2 , b = (succ 1) })) })
(\ c : (({ d : Bool , a : Unit }) -> (A -> Bool)) . (pred (succ b)))
(inert [ (({ b : Bool , a : Nat }) -> (({ d : B , a : A }) -> (Float -> Float))) ])
(inert [ (({ d : A , a : A }) -> ({ c : Nat , d : Top })) ])
((pred (if ({ d = true , a = "apple" }) then (pred 2) else "apple")) . d)
(\ e : ({ e : ({ c : (Unit -> Float) , c : A }) , c : (Nat -> String) }) . (pred ("boy" . a)))
((fix (if (if c then c else a) then "apple" else (succ 2))) (if ((b unit) as (Bool -> Top)) then (fix (succ 2)) else ((unit as C) a)))
(let d = (iszero (if (({ c = 2 , e = c }) b) then (a . d) else (\ e : A . b))) in (succ (if (inert [ Float ]) then 0 else (fix a))))
(fix (pred (pred "apple")))
(({ c = (({ c = "boy" , d = 2 }) as ((B -> C) -> ({ a : Bool , d : Nat }))) , a = ((pred b) . b) }) as ((({ c : ({ c : Float , d : Bool }) , b : Unit }) -> ((Top -> Bool) -> (Unit -> String))) -> ({ e : ({ c : ({ c : C , a : Nat }) , e : String }) , d : (Unit -> String) })))
(pred (((iszero "boy") as B) (let a = (let a = 1 in unit) in (pred "boy"))))
((succ (inert [ B ])) ({ c = ((let b = (a as A) in false) (let c = "apple" in unit)) , d = (false . a) }))
({ a = (if (iszero b) then (false as Unit) else (iszero false)) , e = ((iszero ({ d = "boy" , b = a })) . a) })
(((pred "boy") . a) . d)
(succ ((pred ({ e = c , c = (iszero 1) })) (pred (0 . b))))
({ e = (pred (0 . b)) , e = ({ d = (inert [ (B -> String) ]) , e = ((1 . e) . c) }) })
({ b = (if (inert [ Top ]) then (("boy" as Nat) as (C -> B)) else (\ a : Float . "boy")) , c = (if (\ a : B . false) then (inert [ B ]) else (iszero true)) })
(succ (pred (inert [ String ])))
(iszero (inert [ (A -> Unit) ]))
(if (if (iszero true) then (pred (let c = unit in "apple")) else ("apple" . e)) then (if (if "boy" then c else ("boy" . d)) then (let d = (pred c) in true) else (let d = (iszero (inert [ A ])) in (succ (succ false)))) else (succ (let c = "boy" in false)))
((pred (fix b)) . d)
(fix (((\ b : B . b) . d) . e))
((iszero (if "apple" then unit else 2)) as ({ d : (({ b : Nat , c : (String -> Bool) }) -> ({ d : Top , e : Float })) , b : ((B -> Unit) -> (Top -> Top)) }))
(inert [ (({ e : ({ d : Float , e : String }) , a : (Unit -> B) }) -> ((B -> Nat) -> (Top -> Top))) ])
((\ b : ({ e : ({ b : String , a : Nat }) , d : ({ b : String , d : B }) }) . (if (pred (succ a)) then ({ b = "apple" , e = 1 }) else (if c then false else "apple"))) ((\ c : Bool . false) as (Unit -> Unit)))
({ b = (let e = (true . b) in (fix a)) , c = ({ d = (succ 0) , a = (succ 0) }) })
(pred (fix (iszero a)))
(inert [ ((Unit -> ({ b : B , d : Unit })) -> (Unit -> ({ e : Bool , a : Unit }))) ])
(succ (fix (if 1 then "apple" else (inert [ C ]))))
(((succ ({ e = "boy" , b = "apple" })) . d) ((pred b) as (Float -> Float)))
((succ (\ d : ((Bool -> C) -> (C -> B)) . (iszero "boy"))) (let e = (pred "boy") in (pred (fix "boy"))))
(inert [ ((Bool -> Float) -> (Unit -> Bool)) ])
(let c = (let a = ("boy" as Unit) in (2 as String)) in (((\ d : ({ e : Unit , b : A }) . (iszero c)) as ((B -> Float) -> ({ d : String , b : String }))) . e))
(\ d : ((Bool -> Bool) -> ({ d : ({ c : Unit , a : C }) , c : Bool })) . (pred (\ a : ({ e : Unit , b : String }) . (pred "boy"))))
((succ (fix 0)) as (({ e : Float , b : Unit }) -> ({ e : (Top -> B) , e : (({ d : Float , b : Float }) -> B) })))
(inert [ ({ e : ({ d : Top , a : B }) , c : (Float -> ({ e : Float , c : Top })) }) ])
(\ c : (({ b : (C -> Bool) , c : (Nat -> C) }) -> (({ d : String , b : Bool }) -> ({ e : C , d : Nat }))) . ((iszero (let b = unit in "boy")) . d))
({ c = (let c = (succ c) in (let a = unit in (if 0 then "boy" else true))) , a = ({ c = ({ b = 2 , b = (false as Nat) }) , e = (pred false) }) })
(let c = (inert [ ({ b : (Nat -> Bool) , d : (B -> (Nat -> A)) }) ]) in (\ d : ({ e : ({ c : (A -> Unit) , c : A }) , b : (Unit -> ({ a : Top , c : B })) }) . (succ ({ c = false , b = true }))))
(inert [ ({ c : ({ a : ({ c : Float , d : Bool }) , c : ({ a : B , a : A }) }) , d : ({ c : (Unit -> Nat) , d : ({ a : B , d : (B -> A) }) }) }) ])
(((b as Top) . e) as ((Top -> Bool) -> ({ e : ({ c : Top , d : C }) , b : String })))
((inert [ ({ a : ({ a : String , c : ({ c : Bool , d : B }) }) , c : (({ e : String , e : Nat }) -> ({ d : Nat , d : Bool })) }) ]) . b)
((let d = (let a = b in (a . b)) in (pred "boy")) (iszero (let b = 2 in (inert [ Nat ]))))
((pred (c as String)) . b)
(if (fix (if (succ "apple") then (c . e) else (inert [ Unit ]))) then ({ c = (succ "boy") , b = (if (inert [ Unit ]) then (\ e : B . b) else (false as C)) }) else (fix (if false then 0 else (0 . a))))
(pred (pred (succ ({ d = c , c = (iszero "boy") }))))
((\ e : ((Float -> A) -> Float) . (b as String)) as (({ d : ({ e : Nat , d : B }) , d : ({ a : Nat , b : Float }) }) -> ({ c : B , b : Bool })))
(succ (iszero (if ({ b = 1 , a = ("apple" as A) }) then (fix unit) else (inert [ Unit ]))))
(iszero (inert [ ({ c : Bool , e : Top }) ]))
(({ e = (fix "boy") , a = (iszero c) }) (fix ({ d = true , e = false })))
(iszero (succ ({ e = "apple" , d = (fix false) })))
((((pred false) . c) as (({ b : Unit , d : Top }) -> ({ c : ({ b : B , a : Top }) , d : (C -> B) }))) (inert [ (({ a : Top , e : Nat }) -> (String -> (Bool -> Top))) ]))
((if (\ d : C . (\ c : Top . b)) then ((2 . a) (succ "apple")) else (fix (iszero (\ d : B . 2)))) as ({ d : (String -> Float) , d : ({ b : C , c : (Bool -> Unit) }) }))
((if ((succ b) . b) then (let e = (iszero a) in (\ a : Bool . (true as A))) else (fix (iszero a))) . d)
(if (succ (if c then true else (succ 1))) then ((succ a) . d) else (if ((false as B) . d) then (inert [ Nat ]) else (fix (pred 0))))
(pred ({ d = (iszero unit) , e = ((iszero false) as Nat) }))
(((if b then "boy" else true) (let a = b in (let b = unit in "apple"))) . e)
((((pred true) . b) (\ c : ({ c : B , a : ({ b : Unit , b : String }) }) . (inert [ Top ]))) . b)
(iszero (pred ((pred (iszero false)) . a)))
(\ c : (({ a : Bool , e : ({ c : Bool , c : C }) }) -> (({ e : Top , d : C }) -> C)) . ((succ (succ 2)) . d))
(if ((iszero (pred true)) as ({ e : (Top -> Bool) , e : ({ b : Unit , e : Top }) })) then (pred (inert [ (Nat -> String) ])) else (if (if true then (succ true) else (inert [ Top ])) then (succ (let c = "boy" in a)) else (if (fix true) then (1 as Unit) else (inert [ C ]))))
(let e = ({ c = (if (fix "apple") then (\ e : Nat . c) else ({ a = b , c = "boy" })) , c = (2 b) }) in ((if c then 2 else b) (inert [ A ])))
(let d = ((0 c) as ({ d : ({ b : Unit , a : Top }) , a : (({ b : Nat , e : Bool }) -> ({ b : A , a : Float })) })) in (if (succ unit) then (let a = 1 in unit) else ("apple" as Top)))
((pred (iszero 0)) as ({ b : ({ c : ({ a : (A -> Nat) , e : Float }) , e : ({ b : (Nat -> Unit) , a : B }) }) , d : ((Top -> Bool) -> Nat) }))
(fix (if (fix true) then (2 b) else (inert [ ({ e : B , c : Bool }) ])))
(inert [ ({ d : (({ b : C , b : Bool }) -> Float) , d : (Nat -> ({ e : A , e : String })) }) ])
(fix ((pred false) (iszero b)))
(pred (succ (\ a : (A -> Bool) . (true "apple"))))
(iszero (inert [ (({ d : String , b : Top }) -> (A -> (Nat -> Top))) ]))
(if (pred (pred "apple")) then (pred ((true as Top) (pred 2))) else (inert [ ({ d : (Bool -> Top) , d : (String -> C) }) ]))
(iszero (iszero (succ 0)))
((if (succ (\ e : ({ b : B , e : B }) . c)) then ({ a = (\ d : C . true) , d = (let c = c in (\ c : Unit . "boy")) }) else (iszero (let d = "boy" in a))) (pred (let b = (c c) in (iszero "boy"))))
((if (let c = unit in true) then (c b) else (iszero 2)) (inert [ ({ d : ({ a : ({ a : Bool , e : Top }) , e : ({ d : Nat , b : Unit }) }) , d : ({ e : ({ d : Bool , c : B }) , a : Top }) }) ]))
(if ((unit 1) as ({ b : ({ d : C , d : (Nat -> String) }) , b : ({ a : Top , d : (C -> Top) }) })) then (pred ({ e = false , b = 1 })) else (inert [ (Nat -> Nat) ]))
(let d = (pred ({ c = (pred b) , e = true })) in (if ({ a = a , c = false }) then (fix 2) else (inert [ (A -> Bool) ])))
((succ ({ d = unit , b = (iszero 2) })) (if (fix (fix "apple")) then (inert [ Top ]) else (pred 0)))
(if ((iszero (pred (1 as A))) (inert [ ({ d : Top , b : String }) ])) then (\ a : ({ c : ({ a : Unit , e : (B -> A) }) , e : ({ b : B , e : A }) }) . (inert [ ({ a : A , a : B }) ])) else (if ((\ a : Unit . a) . d) then (inert [ ({ a : Unit , e : Top }) ]) else (if ((b as Top) . a) then (iszero true) else ({ b = c , e = 0 }))))
({ a = (let c = ((\ c : String . 0) as ({ d : Bool , e : Unit })) in (iszero (fix "boy"))) , e = (pred ((unit 1) true)) })
((let d = (\ c : Float . 0) in ({ e = 0 , b = b })) as (({ c : String , c : String }) -> ({ c : Float , a : C })))
(if (pred (c 2)) then (if (let c = 2 in unit) then (iszero c) else (fix 2)) else (succ ((succ 2) (succ false))))
(iszero (inert [ (({ c : Unit , c : Float }) -> A) ]))
((((\ a : Top . b) "boy") . e) . d)
(if ((iszero 0) (succ b)) then ((let b = a in 2) . d) else ({ d = (a as Nat) , e = (let d = (succ c) in 1) }))
((iszero (\ e : ({ c : B , d : Nat }) . (pred "apple"))) (fix (let b = true in 0)))
((inert [ ({ b : ({ e : Bool , e : B }) , c : ({ a : A , d : Bool }) }) ]) as ((({ e : Nat , b : Unit }) -> ({ e : Bool , a : A })) -> (Nat -> Unit)))
(((pred a) . a) (pred (false as Top)))
(iszero (\ c : ({ a : Unit , b : Top }) . (fix true)))
(pred ({ a = (({ d = unit , a = unit }) . b) , e = (iszero (pred unit)) }))
(let c = (fix (inert [ ({ a : (A -> B) , d : Nat }) ])) in ((let c = 0 in "apple") ((a . a) as (A -> Top))))
(let b = ({ a = (1 false) , e = (succ 1) }) in (fix (\ c : (({ e : Top , c : Bool }) -> Nat) . ((let c = 0 in b) . c))))
(\ b : ({ c : ({ b : Unit , d : Float }) , a : (Float -> A) }) . (if (if ("boy" as Unit) then "apple" else ({ b = unit , e = true })) then (let e = (\ e : Bool . b) in (inert [ Top ])) else (fix (succ 1))))
(succ (\ d : ((Nat -> Top) -> ({ c : B , e : C })) . (iszero false)))
((fix (fix "boy")) . c)
({ c = (pred ({ e = 1 , e = "apple" })) , a = (\ c : ({ b : Top , c : Float }) . (false . c)) })
(succ (inert [ ({ c : (Nat -> A) , c : ({ b : Nat , e : A }) }) ]))
(fix (let a = (fix (fix "boy")) in (fix a)))
(succ ((iszero (pred 2)) (iszero (iszero (\ d : C . true)))))
(fix ((if c then "boy" else b) ((pred 0) (pred 2))))
(if ((pred (0 unit)) (succ (inert [ Top ]))) then (let c = (succ (\ d : Bool . unit)) in (let a = (succ 2) in (let c = true in 2))) else (succ (let b = (let b = false in a) in true)))
(\ e : ((({ b : Float , c : Top }) -> ({ e : Unit , e : A })) -> ({ b : ({ c : C , e : B }) , e : ({ d : Float , c : Bool }) })) . ({ c = (pred (\ e : Bool . c)) , d = (if unit then 0 else unit) }))
(pred ((true . b) (if b then ({ d = b , c = unit }) else b)))
(let c = ((fix c) as ({ d : String , c : Nat })) in (fix (let a = (\ b : C . 2) in (if false then c else 1))))
(pred (succ (succ true)))
(iszero ((fix b) . c))
(fix (iszero (inert [ Top ])))
(pred (fix (if a then "apple" else true)))
(inert [ (((String -> Top) -> ({ b : Unit , c : A })) -> ({ c : (String -> B) , d : ({ d : ({ d : B , e : A }) , d : (Unit -> Top) }) })) ])
(succ (let a = (iszero (iszero "apple")) in (let b = unit in c)))
(if (succ (inert [ Top ])) then (succ (iszero (succ c))) else (inert [ (({ e : Top , b : Bool }) -> ({ d : ({ c : String , a : Top }) , b : ({ b : String , c : Bool }) })) ]))
(\ a : ({ a : ({ d : ({ b : (C -> Top) , a : C }) , b : (Unit -> Unit) }) , e : (A -> (Unit -> Top)) }) . (if (inert [ Unit ]) then (succ (pred b)) else ("boy" (fix "boy"))))
(iszero (succ (let b = true in false)))
({ e = (\ a : ({ c : (C -> Nat) , e : ({ a : Unit , b : Top }) }) . ((pred "boy") . c)) , b = (inert [ ({ a : ({ b : Nat , b : B }) , c : (({ d : A , e : String }) -> Top) }) ]) })
(iszero (succ (if 0 then (iszero "apple") else (true b))))
((inert [ ({ a : (Float -> Float) , d : Top }) ]) ({ e = ((1 as String) (b . d)) , a = (true as Bool) }))
(pred ((\ e : (B -> Nat) . c) as ({ c : String , b : A })))
(((succ unit) (pred "boy")) as ({ a : ({ e : Top , c : String }) , b : ({ d : Bool , e : (String -> B) }) }))
(succ (fix (inert [ Top ])))
(pred (\ a : (Float -> Float) . (\ d : B . false)))
({ b = ((inert [ (Bool -> Unit) ]) as ((A -> Float) -> (B -> ({ e : Bool , d : String })))) , a = (let d = ((iszero (fix true)) . a) in ((fix b) as ({ a : String , e : Top }))) })
(\ a : ({ e : ({ e : (B -> Unit) , c : Bool }) , d : ({ b : ({ b : Bool , d : Top }) , b : ({ c : ({ c : String , e : Nat }) , e : ({ c : Bool , c : Bool }) }) }) }) . ({ e = (pred (let e = 0 in c)) , e = (let a = 0 in 0) }))
(((if unit then 1 else unit) (1 (fix unit))) as (((Unit -> String) -> Nat) -> (Unit -> Bool)))
(pred (\ e : ({ b : String , d : Float }) . (0 (b as Top))))
((inert [ ({ d : B , a : (B -> Nat) }) ]) (inert [ ({ e : Float , b : (Unit -> C) }) ]))
(inert [ ({ e : (({ a : Nat , b : String }) -> String) , e : (A -> Top) }) ])
((pred (let b = (iszero 1) in (pred (\ d : Unit . a)))) ((iszero ((fix "apple") as Nat)) . d))
({ e = (if (pred (inert [ Bool ])) then (succ unit) else (true 0)) , c = (pred (\ a : Bool . 1)) })
(inert [ (((B -> Float) -> (Top -> B)) -> ((B -> String) -> B)) ])
(succ ((let a = (let e = "boy" in b) in (c . c)) (true as Float)))
((fix (\ a : String . ({ c = a , b = b }))) . e)
(((\ b : Unit . 2) . a) ({ c = (fix (inert [ Bool ])) , c = ((pred 1) as Nat) }))
(\ b : ({ a : (({ b : Bool , c : C }) -> (Nat -> Bool)) , d : (A -> (Unit -> B)) }) . (\ e : ({ d : Unit , b : A }) . (if 1 then 1 else 1)))
(iszero ((((succ c) as (B -> Float)) as (Unit -> C)) . e))
(iszero ((succ (iszero 0)) (pred (let e = "apple" in "boy"))))
({ e = ((if false then (\ a : Float . 0) else 1) (succ (let b = "boy" in 2))) , d = (iszero ({ c = unit , c = ("apple" c) })) })
(({ b = (if (let d = "boy" in "apple") then (if "boy" then 0 else false) else false) , b = (iszero c) }) as (({ c : (A -> Float) , a : ({ c : Top , c : B }) }) -> (Unit -> (String -> Nat))))
(iszero ({ d = (fix "apple") , c = (\ c : Unit . "boy") }))
((pred (inert [ B ])) as ((Nat -> Float) -> (({ b : B , a : Nat }) -> Float)))
(succ (\ e : (Top -> ({ e : Bool , c : String })) . (let b = ({ b = (inert [ Nat ]) , c = c }) in (let e = "boy" in false))))
(let a = ((if (fix 2) then (a . c) else false) as (Nat -> Unit)) in ((inert [ Bool ]) . a))
(inert [ ((String -> A) -> (Float -> B)) ])
(if (let a = (\ e : ({ b : (C -> A) , d : C }) . (iszero 1)) in (fix (if 0 then 0 else "boy"))) then (inert [ ((B -> A) -> ({ b : Bool , d : Float })) ]) else (pred ((if (inert [ C ]) then (1 as Nat) else false) . c)))
(let a = (inert [ ({ c : ({ a : (Nat -> String) , a : (B -> B) }) , e : (B -> Bool) }) ]) in (pred ((a false) . b)))
(if (inert [ ({ b : Top , b : A }) ]) then ((fix (succ c)) . c) else (succ (pred unit)))
(iszero ((inert [ ({ c : C , d : String }) ]) as ({ c : ({ c : A , d : C }) , b : ({ a : B , a : Float }) })))
(fix (let a = (inert [ ((String -> String) -> String) ]) in (let e = (fix b) in (inert [ Float ]))))
(\ c : ({ b : ({ d : (Unit -> B) , a : (Unit -> String) }) , b : (Nat -> ({ a : Bool , d : Float })) }) . (pred (\ c : (Unit -> Unit) . (\ d : Top . unit))))
(({ e = (fix unit) , c = (inert [ Bool ]) }) . c)
({ d = (succ (\ a : String . c)) , c = (iszero ((iszero b) as ({ c : A , b : C }))) })
((succ (let c = 1 in a)) (("apple" as ({ e : Top , a : A })) (a as Float)))
(fix (if (iszero false) then (unit (fix "apple")) else (\ d : Float . 1)))
(((inert [ ({ a : C , d : A }) ]) . d) (\ c : ({ e : (({ b : Unit , e : Float }) -> (String -> String)) , d : (A -> ({ d : String , a : Nat })) }) . (false as C)))
(((0 . c) (0 (succ "boy"))) . b)
(fix ((succ (inert [ Bool ])) . e))
(if (iszero (succ (unit as A))) then ({ a = (false . c) , d = (pred (let d = c in b)) }) else (iszero (\ d : B . a)))
({ d = (pred (pred (iszero c))) , e = ({ d = (iszero 1) , c = (if (iszero "apple") then "apple" else (let a = a in true)) }) })
(iszero (pred (("apple" . b) . a)))
(iszero (if (let e = (1 "boy") in (inert [ Float ])) then (inert [ String ]) else (if (2 a) then (inert [ String ]) else (false 1))))
({ c = ((iszero 1) ((b (fix 2)) (2 as (String -> A)))) , c = (inert [ (Float -> Top) ]) })
(succ ({ e = (true as Bool) , e = (\ b : ({ b : C , e : C }) . ({ c = false , d = 1 })) }))
((succ (succ "apple")) ((fix (succ c)) (if b then false else (0 . e))))
((let e = (inert [ (String -> Float) ]) in (let c = (let c = (c b) in (pred a)) in ("boy" . a))) . c)
(iszero (if (if b then b else a) then (inert [ Top ]) else (succ 0)))
(((\ b : Nat . c) (pred b)) ((succ unit) as (Float -> C)))
((iszero (if b then 1 else unit)) . e)
(let d = (succ (iszero (inert [ Top ]))) in (fix (if (1 as C) then 2 else "boy")))
(if (if (pred unit) then (iszero a) else (\ b : A . 1)) then ((succ (inert [ B ])) ((inert [ ({ a : A , c : String }) ]) as ({ e : B , a : Bool }))) else ({ c = (a "boy") , e = (true as Top) }))
((({ c = 1 , c = c }) (pred (\ a : Nat . unit))) as ({ b : ((Bool -> Float) -> (Unit -> Top)) , b : ({ b : ({ e : C , b : (Float -> Bool) }) , d : (Top -> B) }) }))
(let b = (fix (pred (if unit then c else 0))) in (let a = (\ a : A . (succ c)) in (iszero (iszero b))))
(((true (iszero 1)) . a) ((if "boy" then (unit . d) else false) as (B -> B)))
((iszero (pred (\ e : Nat . false))) . d)
(\ c : ((C -> Nat) -> (Nat -> Bool)) . ((if c then unit else true) (fix (\ b : A . unit))))
((if (fix b) then (fix true) else (pred b)) (fix (pred (iszero a))))
(\ b : (({ a : ({ c : String , c : Bool }) , b : ((B -> Top) -> Unit) }) -> ({ b : ({ d : Float , b : Unit }) , d : Bool })) . ((\ d : Top . a) . e))
(((fix (\ b : Nat . true)) . a) ((let b = (pred "boy") in c) (unit as Float)))
((({ a = (\ c : Top . c) , d = (succ (inert [ Float ])) }) . e) . c)
(\ d : ({ b : ({ e : ({ e : Float , a : String }) , d : Float }) , a : (C -> Top) }) . (succ (if (2 . b) then (let c = unit in "apple") else (inert [ ({ c : A , b : C }) ]))))
(iszero (fix ({ d = (inert [ Bool ]) , b = ({ d = false , d = false }) })))
(succ (pred (succ unit)))
({ d = (inert [ (Bool -> String) ]) , c = (if (succ b) then ((succ 1) . c) else ("boy" as B)) })
(succ (inert [ (({ b : Unit , d : Top }) -> (Nat -> Float)) ]))
(succ (fix (iszero (pred unit))))
(pred (if (pred (2 as Top)) then (iszero (if b then false else ({ c = "boy" , a = b }))) else ((2 as A) . a)))
({ c = (\ c : ({ a : (B -> A) , e : Float }) . (if (inert [ Unit ]) then (\ a : Top . "boy") else (pred "boy"))) , a = (fix (fix unit)) })
(let d = ((pred 0) . b) in (if ("boy" . e) then (false as C) else (inert [ ({ b : B , e : Bool }) ])))
(succ (succ (\ d : Bool . (\ e : String . b))))
(pred ({ d = (inert [ A ]) , c = (let b = 0 in 1) }))
(inert [ (((A -> Nat) -> Float) -> (({ c : B , a : Top }) -> (Nat -> Bool))) ])
({ b = ((succ b) . e) , b = (let b = ((iszero 1) as ({ a : ({ d : C , d : Unit }) , c : ({ a : A , e : Float }) })) in (iszero (if "apple" then "boy" else 1))) })
(fix (succ (\ a : Bool . 1)))
(\ c : (({ b : Top , a : B }) -> ({ d : C , d : (Float -> String) })) . (iszero (let d = a in (pred 2))))
(inert [ (({ c : ((Unit -> Nat) -> Bool) , a : (A -> Bool) }) -> ({ b : Unit , c : Bool })) ])
(pred ((fix (if 1 then 0 else a)) as ({ c : Nat , c : C })))
(iszero (fix (inert [ Top ])))
(fix ((fix ({ b = "boy" , e = true })) (if 1 then (\ b : Nat . 0) else (fix 1))))
(iszero (let c = ({ e = (fix 0) , c = 0 }) in (iszero (\ e : A . 1))))
(((pred true) ((fix 1) as (B -> Top))) as ((Bool -> Unit) -> (Bool -> Top)))
((let e = (if (if "apple" then a else 0) then 0 else (0 true)) in (let b = (succ c) in (unit 1))) . c)
(inert [ (({ d : ({ d : Top , b : C }) , b : (Bool -> C) }) -> ({ c : String , e : (A -> String) })) ])
(pred (fix (if true then "apple" else c)))
((pred (let e = c in unit)) as ((Top -> Float) -> ({ d : String , b : Top })))
(pred (inert [ ({ c : (Top -> Bool) , b : Bool }) ]))
({ b = (((fix "boy") a) . a) , d = (inert [ (String -> Float) ]) })
(succ (iszero (if (a . c) then (inert [ Nat ]) else (if 2 then ({ d = true , e = 2 }) else (\ c : B . false)))))
(\ a : (({ b : Float , c : ({ c : Nat , b : Top }) }) -> (({ a : Unit , a : B }) -> (Float -> Unit))) . ((iszero (let e = "boy" in true)) . e))
((succ (inert [ C ])) (pred ((let b = false in 2) as ({ c : Nat , d : Bool }))))
(iszero (let b = (fix a) in (let a = a in a)))
(let c = (succ (let a = true in (c as Bool))) in (inert [ (({ e : A , d : ({ a : String , a : Top }) }) -> ({ e : ({ a : B , e : Bool }) , a : A })) ]))
((inert [ (({ a : B , a : A }) -> ({ a : Nat , d : Float })) ]) as ((Bool -> C) -> ({ b : Unit , a : Float })))
((inert [ (({ b : Bool , b : Float }) -> C) ]) . b)
(succ (\ b : ({ c : (Unit -> Top) , c : (Bool -> Nat) }) . ("apple" as Float)))
(\ e : ((({ e : ({ b : String , a : Bool }) , d : ({ c : String , b : Unit }) }) -> ({ e : B , a : Unit })) -> ((Float -> Bool) -> (A -> String))) . (((pred b) (succ false)) . d))
(if ((iszero 1) . d) then ({ b = (let e = (if true then (fix 1) else a) in (iszero 0)) , e = (pred c) }) else (if (fix (b as Top)) then (inert [ Top ]) else (let d = (\ a : Nat . a) in 0)))
(((pred (2 as Nat)) ((fix "boy") . b)) (if ((let d = b in "apple") as Bool) then ((b b) (iszero unit)) else (succ ("apple" . e))))
(succ (fix (let d = (fix 1) in false)))
(\ a : ({ b : ((Nat -> Top) -> Unit) , c : ({ d : ({ e : Bool , e : Float }) , b : ({ e : B , e : C }) }) }) . ((unit . e) . c))
(let a = ((if (if (inert [ Bool ]) then (a as A) else 2) then (if true then false else 2) else ("boy" as Float)) . c) in ((iszero (true "apple")) as ((String -> Float) -> ({ e : String , d : Top }))))
((if (if a then false else 1) then (let d = (let a = "apple" in c) in false) else ((let b = unit in unit) . a)) (inert [ ({ e : (A -> Bool) , a : B }) ]))
((pred (1 as (Float -> Bool))) as (({ c : Bool , e : Bool }) -> (Top -> Float)))
((pred (unit . c)) (\ b : (Top -> C) . (iszero b)))
(succ (inert [ ((A -> B) -> String) ]))
(pred (fix (pred (c as B))))
(\ c : (((Float -> String) -> String) -> ((String -> String) -> String)) . (((iszero c) . a) . c))
(inert [ ({ c : ({ d : B , c : (String -> Bool) }) , e : ({ d : B , d : (A -> B) }) }) ])
(((inert [ B ]) as ({ d : Top , c : C })) ((succ 2) (succ unit)))
(let d = (iszero (succ "apple")) in ((\ b : (Top -> A) . (false . c)) . d))
(iszero ((let e = "apple" in 2) . b))
(pred (iszero ("apple" as Bool)))
(iszero (let e = (c . c) in ("boy" true)))
(iszero (if ({ b = 2 , e = b }) then (\ a : Bool . (false as Bool)) else (let a = (fix (\ e : B . b)) in ({ c = 2 , b = "apple" }))))
((iszero (let b = true in (iszero unit))) as ({ d : ({ d : (C -> Bool) , e : ({ d : (Unit -> Bool) , b : C }) }) , b : (({ a : String , d : String }) -> Top) }))
(iszero (succ (succ true)))
(inert [ (((Float -> Float) -> B) -> ((Float -> Bool) -> (Bool -> Bool))) ])
(\ b : ({ d : ({ e : (String -> Top) , d : ({ d : Unit , b : Unit }) }) , a : (B -> ({ d : Unit , e : C })) }) . ((("apple" as Nat) 0) as (({ c : B , d : Float }) -> Unit)))
(\ c : ({ a : ({ d : B , e : Bool }) , b : (Unit -> A) }) . (pred ({ b = true , a = "apple" })))
(succ (\ d : (({ a : B , b : Unit }) -> Bool) . ({ a = unit , a = 0 })))
(pred (let d = ({ d = (if 1 then unit else "apple") , c = (let d = (if "boy" then 2 else true) in (\ d : String . a)) }) in (iszero ("boy" as A))))
(fix ((2 as Float) as (String -> A)))
(succ (succ (succ ({ e = (1 as Float) , d = 2 }))))
(let c = (let b = ((pred ("apple" 0)) as ({ a : ({ c : Bool , e : Float }) , c : C })) in (iszero (({ d = false , a = 0 }) 1))) in (pred (if (let b = false in b) then ("boy" as A) else (if 0 then "boy" else a))))
(fix (inert [ ({ d : C , c : Top }) ]))
((((\ b : Bool . 0) as ({ d : Float , a : A })) . e) . d)
((fix (pred (unit . a))) ((0 . b) . c))
(iszero (\ a : ({ b : Unit , d : Nat }) . ({ d = b , c = (a as Nat) })))
(inert [ ({ e : ((B -> Nat) -> ({ b : A , c : Bool })) , c : ((B -> String) -> Nat) }) ])
(iszero (let e = (pred (succ unit)) in (let d = (\ a : C . b) in (iszero false))))
(\ c : (({ d : Bool , e : Float }) -> ((({ e : Float , a : C }) -> Top) -> (Float -> String))) . (let d = (\ b : (Top -> C) . (let b = unit in a)) in (succ (unit . b))))
(pred (fix ("apple" "boy")))
((((let d = a in "apple") . e) . e) (pred (inert [ ({ a : Unit , e : Unit }) ])))
({ a = (let a = (let b = "apple" in c) in (fix c)) , c = (iszero ((fix a) (pred "apple"))) })
(if ((inert [ String ]) as ({ c : Float , e : (Float -> Unit) })) then (let e = ({ e = "apple" , a = ({ b = c , c = c }) }) in ({ e = b , c = (if c then "apple" else false) })) else ({ a = ({ a = 1 , c = b }) , e = (\ e : (Unit -> Float) . (succ c)) }))
((((1 as Top) (0 2)) (succ (unit 1))) (fix (fix (succ a))))
(succ (inert [ (A -> String) ]))
(pred (inert [ (Float -> C) ]))
(({ a = (fix c) , a = (fix true) }) ((pred (pred false)) (2 as C)))
(\ a : ({ b : ({ d : Bool , a : Top }) , b : (Bool -> Nat) }) . (succ (pred (pred true))))
(iszero ({ d = (iszero c) , c = (if 2 then b else "boy") }))
(((iszero (b . e)) as ({ c : (Top -> Nat) , a : ({ e : Bool , b : Top }) })) as ({ c : (A -> Unit) , e : ({ c : A , d : Unit }) }))
({ b = ((let e = (iszero "apple") in ({ b = true , e = unit })) . a) , b = (iszero (true c)) })
((inert [ ({ d : ({ e : String , e : ({ e : String , d : Float }) }) , c : (Unit -> Nat) }) ]) as ((Float -> String) -> (Unit -> Bool)))
(inert [ (({ b : ({ a : String , b : Float }) , e : (C -> Unit) }) -> (({ a : A , e : B }) -> (Top -> Nat))) ])
((let b = ((iszero 1) (b . b)) in (let a = (false as A) in (succ b))) . d)
({ a = ({ d = ("apple" . c) , e = (iszero false) }) , e = ({ b = (0 as Nat) , b = (inert [ Bool ]) }) })
(inert [ ((Unit -> Top) -> ({ c : String , e : Top })) ])
(if (inert [ ((({ c : C , d : B }) -> B) -> ({ a : (Top -> B) , c : Bool })) ]) then (if (succ (let c = "boy" in 0)) then (succ (let c = true in "boy")) else (fix (inert [ Float ]))) else (pred ({ a = b , e = a })))
(\ d : (({ a : ({ e : B , c : A }) , a : ({ e : Top , e : A }) }) -> (({ a : A , c : B }) -> ((Unit -> C) -> (A -> Top)))) . (\ d : ({ e : Nat , b : Float }) . ({ d = b , d = (iszero 1) })))
((((succ "boy") . d) as (({ b : C , a : C }) -> (Nat -> Top))) as (({ d : Float , e : Bool }) -> ((Top -> A) -> ({ a : Float , b : Bool }))))
((let e = (let e = ({ d = true , a = unit }) in (let b = 0 in b)) in (fix (iszero unit))) . e)
(pred (if (\ e : Top . unit) then ({ d = unit , e = c }) else ({ a = (iszero 1) , c = unit })))
({ d = (if ((unit as C) (inert [ B ])) then (iszero (pred 0)) else (succ true)) , d = (let e = (if (pred true) then a else 0) in (inert [ (C -> A) ])) })
(succ ({ b = (let e = 1 in (\ b : Bool . a)) , a = (if ({ e = false , c = c }) then (\ e : Float . unit) else (iszero 0)) }))
(pred ((\ c : (Nat -> B) . (\ c : String . unit)) as ({ a : (Nat -> String) , c : (Unit -> B) })))
(inert [ ((Unit -> ({ a : Nat , e : Nat })) -> (Float -> Top)) ])
(inert [ (({ d : Top , b : ({ c : Top , c : Nat }) }) -> ({ c : A , e : Float })) ])
((\ c : (({ c : Unit , c : Unit }) -> ({ c : ({ b : Float , a : Unit }) , b : ({ c : Top , e : Float }) })) . (succ (succ unit))) as ((A -> (Top -> A)) -> ({ d : C , e : C })))
((succ (1 (let c = "apple" in b))) as ({ b : ((C -> Unit) -> Float) , a : ({ b : Bool , b : (C -> Top) }) }))
({ a = (succ ({ c = 0 , d = "apple" })) , b = (succ (inert [ A ])) })
((((let e = 1 in true) ("boy" unit)) as (Nat -> String)) as (({ c : Top , a : Unit }) -> ({ c : (Top -> String) , c : (Unit -> Bool) })))
(fix ({ c = (pred (pred (false a))) , e = (iszero 2) }))
((fix (if c then a else true)) as ({ d : ({ a : ({ b : Bool , a : Top }) , c : (String -> String) }) , e : ({ e : ({ e : String , d : Float }) , e : ({ a : String , d : (Unit -> Float) }) }) }))
(fix ((fix (\ d : Bool . 0)) as (Unit -> Top)))
(({ b = (let e = a in ("boy" . b)) , c = (iszero ({ d = unit , e = true })) }) . b)
(inert [ ((Nat -> Nat) -> ({ e : Bool , c : Nat })) ])
(inert [ ({ c : ({ a : Nat , b : B }) , d : (({ d : Bool , e : Bool }) -> (Unit -> Unit)) }) ])
((inert [ ({ b : (Unit -> A) , e : (String -> Top) }) ]) . c)
(iszero (succ (let b = (fix c) in "apple")))
(inert [ (({ a : Float , b : A }) -> (Unit -> Bool)) ])
(pred ((succ 2) . b))
(iszero (\ b : (((C -> A) -> (Float -> Bool)) -> (A -> Top)) . (iszero (succ "boy"))))
((inert [ ({ b : (Bool -> ({ e : Float , e : Bool })) , c : ({ b : (Nat -> B) , e : ({ a : A , a : String }) }) }) ]) . e)
(pred (("boy" a) (if ({ a = "boy" , e = 0 }) then (\ e : A . unit) else (inert [ (Nat -> Top) ]))))
(\ b : ((A -> Unit) -> (({ a : ({ e : String , d : Bool }) , b : ({ d : Bool , e : String }) }) -> (C -> Float))) . (((let b = true in a) as ({ a : (String -> Top) , a : C })) . a))
(inert [ ((A -> Nat) -> ((Unit -> Float) -> ({ b : Bool , c : (Nat -> Top) }))) ])
(({ d = ({ b = 0 , e = unit }) , a = (pred false) }) ((inert [ B ]) . d))
(let c = (({ b = c , e = 0 }) . a) in (((inert [ ({ b : C , a : C }) ]) . b) . b))
(let a = (inert [ ({ e : ({ c : A , d : C }) , a : (Nat -> Unit) }) ]) in (iszero (pred "boy")))
(\ c : ({ d : ({ a : (Nat -> (C -> C)) , d : (C -> ({ e : Nat , e : String })) }) , e : ({ b : Bool , a : ({ a : A , d : String }) }) }) . (let c = (fix b) in (if (false . a) then 2 else (a as Unit))))
(({ b = (if (succ false) then ("boy" 1) else 0) , c = (\ e : Float . "apple") }) (fix (\ c : Bool . "apple")))
(if (((inert [ String ]) . c) . a) then (fix (inert [ (({ d : Float , e : B }) -> ({ d : Unit , c : Unit })) ])) else (iszero (inert [ Float ])))
(\ a : ({ a : (Top -> String) , b : (C -> Nat) }) . ({ b = (pred false) , c = (("boy" as String) . b) }))
(if (fix (pred (inert [ Nat ]))) then (if (false as Nat) then (1 . c) else (pred 1)) else (iszero ((succ b) as (String -> (Float -> Top)))))
({ b = (if ((pred a) as (Top -> C)) then (fix 1) else (succ a)) , e = ({ a = (if (2 as C) then ("boy" as Unit) else (let b = 2 in (succ 2))) , a = (\ b : ({ c : Bool , c : String }) . (0 1)) }) })
(succ ((inert [ A ]) as ({ e : Float , e : A })))
(((succ (inert [ Nat ])) . d) as ({ d : (B -> Top) , b : (Float -> Float) }))
(iszero ((if "boy" then b else "boy") as (A -> String)))
(let b = ({ e = (if "apple" then 0 else a) , e = (let d = 0 in (let d = "boy" in 1)) }) in (iszero ((unit . b) 2)))
({ c = (\ c : ({ a : ((Unit -> A) -> String) , b : ({ e : C , d : (Top -> C) }) }) . (inert [ (A -> Top) ])) , b = (inert [ ({ a : ({ a : Nat , e : Nat }) , b : (Nat -> Nat) }) ]) })
((inert [ (String -> A) ]) as ({ c : (({ d : String , d : Bool }) -> (A -> Unit)) , e : ({ a : A , e : (Float -> B) }) }))
((\ a : ((Nat -> Float) -> (Nat -> Bool)) . (iszero c)) . a)
((\ a : ({ a : B , d : Bool }) . (let b = (let c = a in 1) in (inert [ Bool ]))) as ((A -> Top) -> ((String -> A) -> ({ d : Bool , e : String }))))
(fix ((\ c : Bool . 0) (let b = "apple" in unit)))
(if (fix ((pred a) (pred (0 . b)))) then (if ((if false then "boy" else false) (1 as A)) then (succ c) else ({ d = (fix a) , c = (c . c) })) else ({ b = (succ 1) , e = (fix 1) }))
(if ({ b = (let a = a in "boy") , e = (2 false) }) then ((iszero (inert [ String ])) (fix (inert [ C ]))) else (pred (\ c : C . false)))
(let b = (inert [ ({ a : ({ d : String , a : C }) , d : (Float -> (Float -> Nat)) }) ]) in (succ (true unit)))
({ a = (\ b : ({ e : ({ e : Bool , e : Bool }) , b : Unit }) . (inert [ (({ b : A , e : Float }) -> ({ c : Nat , e : Unit })) ])) , b = ((fix false) (iszero (inert [ Nat ]))) })
(if (pred (\ b : Float . false)) then (("apple" as C) (let d = (\ b : Bool . unit) in "boy")) else (pred (iszero 0)))
(let e = (if (if (2 as Top) then (true "apple") else (succ (if a then 1 else 2))) then (succ 2) else (succ (iszero a))) in (if (iszero (succ "apple")) then (if ("apple" true) then (succ "apple") else (pred (if "boy" then a else c))) else (pred (2 . c))))
((if (if true then 1 else 0) then (let e = 1 in "boy") else (pred 1)) . c)
(fix (inert [ (B -> C) ]))
({ e = ((let e = ("boy" as String) in (\ d : ({ e : B , b : Top }) . (iszero "boy"))) (if (fix (if 0 then a else false)) then ({ c = "boy" , b = a }) else (0 0))) , a = (succ (inert [ Top ])) })
((pred (iszero (b ("boy" as String)))) . b)
(({ c = (succ ("boy" . a)) , d = (\ c : Unit . (\ e : Nat . false)) }) as ({ c : (Unit -> Nat) , d : ((Float -> Unit) -> (Float -> String)) }))
(((0 (2 . b)) (pred 2)) . a)
(succ (inert [ (Bool -> Float) ]))
(inert [ (({ b : (Top -> A) , a : (A -> Float) }) -> ({ d : (Top -> Top) , d : ({ d : A , a : C }) })) ])
((let e = ((c false) as (Unit -> B)) in (\ c : ({ e : (Unit -> B) , e : A }) . (if "apple" then c else (true . e)))) (let e = (fix 2) in (succ 1)))
(inert [ (({ a : String , c : A }) -> ({ d : ({ b : B , d : Top }) , a : (Top -> Bool) })) ])
((\ d : ((Float -> Bool) -> (A -> Top)) . (\ d : (String -> Float) . (if false then (iszero unit) else "apple"))) as ({ a : ({ a : (Top -> C) , b : ({ c : Bool , a : ({ c : Top , d : String }) }) }) , e : ({ e : (Float -> ({ a : B , d : Bool })) , b : (String -> C) }) }))
(fix (({ c = unit , c = 0 }) . d))
(\ d : (({ d : ({ d : (A -> Unit) , d : A }) , c : ({ a : B , a : B }) }) -> (C -> C)) . (inert [ (({ d : Nat , a : String }) -> String) ]))
((inert [ ({ e : (C -> Unit) , d : ({ d : B , c : Float }) }) ]) ((let e = false in (2 . e)) (\ d : B . false)))
(\ b : (((C -> Unit) -> ({ d : B , c : Unit })) -> (Nat -> Nat)) . (fix (if (if "boy" then 2 else unit) then b else c)))
(inert [ ((C -> C) -> ({ c : B , c : C })) ])
