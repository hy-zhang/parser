"hello"
unit
\x:A. x
let x=true in x
{x=true, y=false} 
{x=true, y=false}.x
\x:Bool. x
(\x:Bool->Bool. if x false then true else false) (\x:Bool. if x then false else true) 
\x:Nat. succ x
(\x:Nat. succ (succ x)) (succ 0) 
\x:<a:Bool,b:Bool>. x
\t:Rec P. {get:Nat, inc:Unit->P}.unit
let create = fix (\cr: {x:Nat}->Counter.\s: {x:Nat}.fold [Counter] {get = s.x, inc = \k:Unit. cr {x=succ(s.x)}}) in create {x=0}
(unfold [Counter] p).inc unit
(unfold [Counter] p1).get
\f:Nat->Nat. \x:Nat. f (f x)
p
(unfold [Counter] p)
(fix (unfold [ ({ c : B , b : C }) ] (inert [ String ])))
(fix (succ (case 2 of < d = a > => unit | < a = d > => 2)))
(pred (fix (inert [ (Rec E . Nat) ])))
(unfold [ ({ e : (Rec A . A) , a : (Float -> Unit) }) ] (succ (0 . a)))
(\ a : (Rec C . ({ c : (< c : C , c : Bool >) , b : (Rec D . ({ b : A , d : C })) })) . ((fold [ (Nat -> A) ] (case c of < d = d > => 0 | < d = c > => 2)) ((fix 0) . e)))
((< e = (fix "boy") > as (Rec C . Bool)) (\ e : ({ c : String , d : Float }) . (pred (succ 2))))
((if (case 1 of < e = a > => true | < c = d > => 2) then (if b then unit else a) else (a as ({ b : Unit , e : Unit }))) (succ (case (false as Bool) of < e = c > => (0 a) | < e = b > => (fix 2))))
(unfold [ (({ b : String , b : B }) -> ({ d : (< a : String , d : C >) , b : Bool })) ] (< b = ((\ d : B . true) . e) > as (Rec C . ({ b : String , c : B }))))
({ e = ((inert [ String ]) as (Rec C . Unit)) , a = ({ c = (unfold [ (Rec A . Float) ] true) , a = ((if 1 then unit else b) as (Rec C . ({ d : Unit , d : Unit }))) }) })
(let b = (succ (succ "boy")) in (if (pred 1) then (c as B) else (unfold [ B ] b)))
(let d = (fix ((a false) unit)) in ((iszero (succ false)) (< d = unit > as Nat)))
(let e = (let a = (1 as A) in (fix "boy")) in (case (unit (fix b)) of < e = b > => (fold [ (Rec D . A) ] (fix false)) | < a = c > => (succ b)))
(succ (\ d : (< a : (Unit -> A) , d : ({ c : Unit , c : Unit }) >) . (inert [ ({ d : Unit , d : C }) ])))
(\ d : ((< e : Nat , a : Unit >) -> (Rec C . Unit)) . (if (case "boy" of < e = a > => a | < a = b > => unit) then (fold [ B ] false) else (case b of < d = b > => (< a = b > as C) | < e = e > => ({ c = true , c = a }))))
(pred (unfold [ (Rec D . (C -> A)) ] ({ b = ({ e = (case 0 of < a = c > => 1 | < e = c > => false) , d = false }) , b = (if "apple" then false else (let a = b in "apple")) })))
(inert [ (Rec E . (Rec E . (< e : Nat , a : B >))) ])
(pred (case (false as A) of < b = c > => (if 0 then (unfold [ Nat ] 1) else (fix "boy")) | < c = d > => ({ a = 1 , a = 2 })))
(< d = (({ c = (inert [ (Rec B . Bool) ]) , e = (fold [ (Rec C . C) ] 1) }) (case (true . b) of < b = d > => (iszero unit) | < a = c > => (if a then (a a) else (let b = a in b)))) > as (Rec B . (String -> Bool)))
(let a = (succ (false as B)) in (iszero (2 as ({ c : C , d : B }))))
(inert [ ({ c : (< e : Unit , e : B >) , e : (< e : Float , d : Float >) }) ])
(fold [ (< e : ((String -> Nat) -> Bool) , d : (Rec B . Bool) >) ] (inert [ ((Rec D . Unit) -> Float) ]))
(case (iszero (< a = (fix a) > as Float)) of < a = d > => ((inert [ Unit ]) (iszero a)) | < e = c > => (fold [ ({ c : (Rec A . String) , c : (< a : Float , d : Bool >) }) ] (fold [ String ] "boy")))
(succ (if (inert [ String ]) then (\ d : A . "boy") else (succ unit)))
((succ (pred "boy")) (fold [ (Nat -> (< b : Nat , a : Bool >)) ] (\ a : C . 2)))
(if (iszero (< c = "apple" > as (Rec D . Unit))) then (unfold [ (< c : B , a : A >) ] ("apple" as Float)) else (if ((let d = a in "boy") as B) then (pred "apple") else (iszero "apple")))
(succ (if (succ b) then (case false of < e = a > => a | < c = b > => a) else (case 0 of < a = e > => false | < a = b > => 0)))
(unfold [ ({ d : (Rec C . A) , d : (Rec B . Unit) }) ] (iszero (succ (succ 2))))
(fix ((iszero c) as ({ a : (Float -> Nat) , b : ({ c : Unit , b : B }) })))
(< e = (< c = (iszero (inert [ String ])) > as (({ a : Float , c : ({ e : Float , e : Float }) }) -> ({ e : Bool , c : String }))) > as (Rec C . (({ b : Bool , c : Float }) -> ({ b : Nat , a : C }))))
(let c = (iszero (((if "boy" then 1 else "boy") ({ b = "apple" , d = a })) . b)) in ((fix (let e = "boy" in true)) (succ (fold [ C ] true))))
(case (fold [ (Rec D . (< d : Bool , e : (Rec A . String) >)) ] (< d = ((0 . d) . c) > as ({ b : String , d : A }))) of < b = a > => (iszero (unfold [ String ] 1)) | < a = c > => (fold [ (Rec E . ({ d : Nat , a : B })) ] (\ a : (< d : (Rec C . Float) , e : (< e : B , a : A >) >) . (let a = "apple" in 2))))
({ a = (fold [ (C -> Float) ] (iszero (case "apple" of < e = e > => c | < c = b > => 1))) , b = ((fold [ ({ e : A , e : Unit }) ] (\ c : (< c : B , c : Bool >) . "apple")) as ((C -> Float) -> C)) })
((fold [ (({ a : String , a : Unit }) -> ({ e : Float , a : Bool })) ] (unfold [ (< a : C , a : String >) ] (if unit then a else 0))) as ((Rec D . A) -> (Rec D . (< e : Nat , e : Float >))))
(succ (succ (c . e)))
(iszero (unfold [ (Rec E . (Rec C . B)) ] ((succ unit) as A)))
((({ d = 2 , d = (false . d) }) as (Rec A . Nat)) (succ (fold [ (Rec E . Unit) ] unit)))
(if (\ d : (String -> C) . (succ true)) then ({ a = ("apple" (pred "boy")) , d = (< c = a > as (A -> Nat)) }) else (pred (unfold [ Bool ] a)))
(unfold [ ({ d : (Rec C . Unit) , c : (< a : (Rec E . C) , d : (< c : Float , c : B >) >) }) ] (pred (0 . e)))
({ b = ({ a = (< e = false > as Float) , b = (iszero 1) }) , b = (inert [ (A -> ({ b : Nat , d : String })) ]) })
(< a = (succ (succ 1)) > as ({ c : (< d : ((< c : Unit , a : B >) -> (Rec A . A)) , e : ({ e : ({ a : Unit , e : Unit }) , b : (Rec D . Nat) }) >) , a : ({ e : (Rec B . Nat) , a : ({ b : String , e : String }) }) }))
(case (\ d : ({ d : Float , c : String }) . (unfold [ ({ b : Bool , e : String }) ] (1 b))) of < d = b > => (inert [ ({ a : ({ b : Unit , b : A }) , b : Float }) ]) | < e = b > => (unfold [ (Rec C . (Rec D . A)) ] (fix (if "boy" then c else unit))))
(< b = (inert [ ({ d : (< b : A , d : (< a : Bool , d : String >) >) , b : (Rec E . (< b : Nat , e : A >)) }) ]) > as ({ b : ((< e : B , b : Nat >) -> (< a : (< a : Float , d : B >) , e : B >)) , c : (Rec D . Bool) }))
(< d = (fold [ (({ a : (Rec E . Bool) , e : Bool }) -> ({ c : B , b : Float })) ] (fix ("boy" as C))) > as (Rec D . ({ a : (Rec A . String) , a : (Rec A . Bool) })))
(\ e : ({ e : ({ c : Nat , e : C }) , a : (< d : C , c : Float >) }) . (inert [ (Rec B . (Rec C . Nat)) ]))
(fold [ ((< c : ({ a : Unit , b : C }) , a : (Rec A . Nat) >) -> ((Float -> String) -> (Float -> B))) ] (if (fix (unfold [ String ] 1)) then (fold [ (String -> Unit) ] 1) else (\ a : C . b)))
(iszero (pred (\ a : (Rec D . String) . (if 0 then c else b))))
(fix (pred (pred (< b = (succ 0) > as Unit))))
({ e = (if ({ e = "apple" , e = a }) then (unfold [ B ] true) else (< e = a > as C)) , d = ({ d = (inert [ (< c : Unit , e : C >) ]) , a = (fold [ (Nat -> B) ] 0) }) })
(fold [ ({ e : ({ d : A , a : Float }) , a : ({ a : Float , d : C }) }) ] (if (2 a) then (let e = false in 1) else (unfold [ B ] false)))
({ a = (iszero (inert [ Bool ])) , b = (pred (inert [ Bool ])) })
(({ e = (pred (< e = (succ c) > as A)) , e = (pred (< a = unit > as Float)) }) as (Rec C . ({ d : B , a : Float })))
(if ((pred b) as ({ b : A , b : A })) then ((case (fold [ C ] false) of < e = d > => unit | < c = c > => (iszero c)) . d) else ((< c = "apple" > as (Rec E . C)) . e))
((inert [ (Rec D . Unit) ]) ({ c = (succ (false . e)) , d = (< e = ({ d = true , c = unit }) > as Unit) }))
((case ((fold [ (Rec A . Nat) ] unit) as ({ e : Nat , a : Unit })) of < c = a > => (< e = (c as B) > as (Nat -> A)) | < e = b > => (pred ({ c = 1 , e = (if "boy" then "boy" else c) }))) . a)
((if (< a = 0 > as B) then (< e = 1 > as Nat) else (pred unit)) as (< a : (< d : (Rec E . A) , c : ({ b : String , d : (B -> Nat) }) >) , c : (Unit -> (Nat -> Nat)) >))
((unfold [ ({ a : (Bool -> Float) , e : Unit }) ] (inert [ ((B -> Nat) -> Nat) ])) . a)
((fold [ (Rec B . (Rec A . String)) ] (fix a)) ({ c = (succ (let c = unit in c)) , e = (succ "apple") }))
(fix (< d = (case "boy" of < c = a > => unit | < c = a > => a) > as ({ a : A , a : Nat })))
((if (pred false) then (fix 0) else (if (let e = unit in b) then (unfold [ B ] "boy") else ({ e = b , d = "apple" }))) (fix (succ "boy")))
((inert [ (< e : Unit , a : Bool >) ]) . a)
({ e = (pred (let e = 0 in a)) , b = (unfold [ (Rec B . String) ] (let c = (pred 1) in (unit "apple"))) })
(iszero (succ (let b = (fold [ Nat ] b) in (fix (false "boy")))))
(\ b : (Rec D . (Rec A . Bool)) . (fix ((fix false) 1)))
(if (succ (inert [ C ])) then (< a = (succ (fix "boy")) > as (< b : A , e : String >)) else (iszero (unit a)))
(< d = (unfold [ ({ e : A , b : ({ b : Float , a : Unit }) }) ] (if true then "boy" else 1)) > as ({ e : (Rec E . ({ c : Nat , a : C })) , c : (C -> ({ b : A , d : String })) }))
(pred (if (b (inert [ Nat ])) then (fold [ Nat ] (iszero a)) else (let a = (pred true) in 0)))
(unfold [ (({ b : (A -> (< b : B , b : Float >)) , a : ({ d : C , a : (< e : A , d : A >) }) }) -> (B -> ({ d : Bool , b : Bool }))) ] (((b . a) "apple") . e))
(unfold [ (Rec A . ((< e : A , c : Unit >) -> (Rec E . String))) ] (if (let d = 1 in 0) then (case "boy" of < e = b > => true | < b = b > => b) else (fix c)))
(pred ({ e = (< c = (if "boy" then 1 else a) > as (Rec B . C)) , e = (if (fold [ C ] "apple") then ({ d = unit , a = "boy" }) else a) }))
(fold [ ({ b : (A -> Unit) , a : ({ a : (Nat -> C) , e : C }) }) ] ({ b = (case (unfold [ C ] c) of < b = d > => (unfold [ B ] 0) | < b = c > => (iszero c)) , b = (case (iszero "apple") of < e = b > => (\ a : Float . "boy") | < b = c > => (iszero "boy")) }))
(< b = (\ b : (Nat -> (String -> Bool)) . (fix ((true b) b))) > as (Rec A . (Rec B . C)))
(succ (\ c : (Rec E . (Rec D . B)) . (if (unfold [ Unit ] 2) then ({ a = 0 , c = a }) else 0)))
(pred (< b = ((fold [ A ] (fold [ Unit ] 2)) (pred a)) > as ({ d : ({ a : (Rec B . Unit) , b : Float }) , c : ({ c : Nat , e : String }) })))
((succ (let b = (< e = true > as B) in (case c of < e = b > => (let d = 1 in b) | < d = c > => b))) ({ d = (case (iszero true) of < d = a > => "boy" | < b = d > => true) , b = (if "apple" then (fold [ Float ] 2) else "apple") }))
(pred ((fix (< d = c > as Bool)) . b))
(< c = (inert [ (< b : (B -> Nat) , d : (< a : Nat , c : A >) >) ]) > as ((< c : (Bool -> Bool) , d : ({ b : Bool , a : C }) >) -> (Nat -> (< a : Bool , a : Float >))))
(let c = (fix ((case "apple" of < b = a > => a | < b = e > => a) . e)) in ((iszero c) . e))
(let a = (< e = ((case 0 of < b = c > => false | < e = a > => "apple") as (< c : Float , a : (A -> B) >)) > as (< b : ({ b : Unit , b : ({ d : Float , d : A }) }) , b : (Bool -> Bool) >)) in (if (1 b) then (< c = unit > as A) else (1 false)))
((fix (fix 0)) (\ c : (Rec E . ({ b : String , b : Nat })) . (iszero 2)))
(inert [ (({ c : (A -> Float) , a : Nat }) -> ({ d : B , b : ({ b : Bool , b : Nat }) })) ])
(if (if (if ({ d = (a unit) , a = a }) then (let c = (succ b) in 2) else (true as String)) then (pred ((fix 2) . a)) else ((if (inert [ Unit ]) then (if 2 then 0 else c) else false) (unfold [ B ] false))) then ((case (< e = c > as Unit) of < d = d > => b | < e = c > => c) ({ d = (< e = false > as Nat) , c = "apple" })) else (if (if (inert [ B ]) then (fold [ Unit ] ("boy" . e)) else (({ e = c , b = b }) as Unit)) then (case (iszero true) of < b = a > => (unfold [ B ] (unit as Nat)) | < a = a > => (\ a : B . c)) else (succ ((\ e : Nat . false) (let b = true in 1)))))
((unfold [ (Nat -> Unit) ] (\ e : (Nat -> String) . "boy")) as (({ e : Nat , b : (Rec D . Bool) }) -> ({ c : (Rec B . Nat) , a : (< a : Nat , b : C >) })))
(if ((case (let e = (inert [ Float ]) in (< b = c > as Bool)) of < a = a > => (unfold [ C ] 1) | < a = d > => (succ 1)) . b) then (inert [ (< d : ({ b : Unit , a : String }) , b : ({ b : Nat , b : String }) >) ]) else (succ (inert [ B ])))
(< b = (if (iszero (< e = (\ c : Bool . c) > as (C -> Nat))) then (fix (fold [ C ] 1)) else (inert [ (Rec D . Nat) ])) > as ({ c : (< b : Nat , a : Bool >) , b : (C -> B) }))
(iszero ((succ 2) (pred (iszero 2))))
(\ e : (< a : (< b : (Rec E . B) , a : (B -> Float) >) , c : (< a : (Rec A . C) , b : ({ c : (Rec E . B) , e : String }) >) >) . (unfold [ (Rec E . A) ] (case (pred a) of < b = a > => (let b = 1 in b) | < a = b > => (1 as C))))
(case (if (\ c : Nat . true) then (succ c) else (pred c)) of < d = b > => (let b = (unfold [ (< e : Unit , c : Nat >) ] (inert [ String ])) in (case (fold [ B ] a) of < a = a > => (fix c) | < c = c > => (< a = c > as Float))) | < e = b > => (fold [ (< e : C , e : Unit >) ] (case 2 of < a = a > => 1 | < a = c > => "boy")))
(case (fix (unfold [ Bool ] true)) of < e = e > => (fix (if b then 1 else false)) | < c = d > => (succ ((iszero c) . b)))
((succ (unfold [ B ] 0)) as (({ a : A , a : String }) -> (< e : (B -> Float) , d : String >)))
((fold [ ((Rec E . A) -> Nat) ] (inert [ (Rec C . B) ])) (if (\ e : A . "apple") then (fix true) else (a unit)))
(fix (succ ({ e = false , a = ({ c = 2 , c = 2 }) })))
(< b = (\ a : (< d : (< d : Unit , a : ({ d : Nat , d : Float }) >) , c : (String -> (Unit -> Float)) >) . (inert [ Bool ])) > as ({ c : (< e : ({ b : (Rec A . C) , e : (Rec C . String) }) , e : (A -> A) >) , b : ((< b : Bool , b : String >) -> ({ c : ({ c : B , a : Unit }) , b : Bool })) }))
((iszero (iszero c)) as (< d : ((< b : (< c : B , d : C >) , a : ({ d : B , b : A }) >) -> (Float -> C)) , d : (Rec A . Nat) >))
(let e = ((case b of < d = c > => true | < d = e > => (pred a)) . d) in (fold [ (({ e : ({ a : String , e : Unit }) , e : (< e : Float , a : A >) }) -> (Rec E . Float)) ] (succ (iszero a))))
(fold [ ((< e : Bool , d : String >) -> (Bool -> Unit)) ] (let c = ((< a = unit > as C) as (Rec D . B)) in (let d = (case 1 of < a = c > => 0 | < c = d > => unit) in (unit false))))
((iszero (pred b)) ({ a = (if (fold [ Bool ] "boy") then false else 0) , e = (iszero false) }))
({ e = (iszero (({ a = "boy" , c = a }) . a)) , a = ({ b = (iszero ({ c = a , b = c })) , a = (unfold [ (Bool -> B) ] (succ 2)) }) })
((succ ((iszero "apple") (fold [ C ] 1))) ({ b = (iszero (case 1 of < d = e > => true | < e = d > => 2)) , e = (case (inert [ C ]) of < e = b > => (succ (iszero 2)) | < d = e > => ({ a = a , e = 2 })) }))
(unfold [ (< a : ({ c : (B -> Float) , e : (< c : String , a : Float >) }) , d : ({ e : C , b : String }) >) ] (\ c : ((< d : C , d : B >) -> ({ d : (< e : B , a : B >) , e : String })) . (inert [ (Nat -> Bool) ])))
(iszero (let a = (1 true) in (< a = 2 > as C)))
(let a = (< c = (fix (case b of < d = b > => c | < e = b > => c)) > as (< e : ({ d : Unit , b : B }) , e : (< c : C , d : Float >) >)) in (succ (\ b : ((A -> Bool) -> C) . (case (case true of < b = d > => 0 | < a = e > => 2) of < a = d > => 2 | < d = c > => 0))))
(let a = (fold [ (< d : (< a : C , c : Nat >) , d : (< c : (Rec E . B) , c : (< b : Float , e : B >) >) >) ] (inert [ Unit ])) in (let b = (< e = (inert [ C ]) > as (Rec D . Unit)) in (("apple" as B) (fold [ (< e : Bool , b : A >) ] 0))))
(iszero (iszero (let c = (< e = (iszero 0) > as (Rec E . B)) in (if (0 false) then (pred false) else (if false then b else b)))))
(if (unfold [ (Rec B . C) ] (pred 0)) then (pred ((unit as C) . e)) else ((succ false) (fix ("boy" . d))))
(if (inert [ (< c : ({ a : Bool , e : B }) , c : ({ e : B , c : Bool }) >) ]) then ((\ b : Unit . (fix unit)) (inert [ (< a : String , a : String >) ])) else (< a = ({ b = (inert [ String ]) , d = (true as A) }) > as (Rec B . Nat)))
(< e = (inert [ ({ b : Bool , d : B }) ]) > as ((Nat -> B) -> ((Rec D . B) -> (< a : A , b : C >))))
(case (let c = (let a = ({ a = unit , b = (case 2 of < c = a > => unit | < d = a > => unit) }) in (false . d)) in (pred ((case "apple" of < c = e > => c | < a = d > => 2) . c))) of < d = b > => (({ e = b , a = false }) . c) | < c = e > => (inert [ (Rec D . (C -> B)) ]))
(succ (pred (inert [ String ])))
(if (pred (case false of < e = a > => "boy" | < b = b > => "apple")) then (case ((case c of < e = d > => c | < b = d > => b) . d) of < d = d > => (pred (if 1 then 1 else "apple")) | < d = c > => (fix (< a = "apple" > as Bool))) else (unfold [ (({ e : (Float -> String) , e : Float }) -> (< e : (< d : Float , b : A >) , b : Nat >)) ] ((\ b : B . unit) (if a then "apple" else "boy"))))
(case (fold [ ({ c : String , a : String }) ] ({ c = true , c = "boy" })) of < c = d > => (case (true false) of < c = d > => (b . c) | < a = a > => ({ a = (succ 2) , e = unit })) | < c = a > => ((unfold [ A ] "apple") . a))
(fold [ ((Nat -> ({ e : B , e : Bool })) -> ({ e : A , d : Float })) ] (iszero (pred (if "apple" then b else "apple"))))
(fold [ (Rec C . (Unit -> Nat)) ] (fold [ ((Rec D . A) -> ({ d : A , a : Nat })) ] (iszero ({ c = true , a = "apple" }))))
(succ ((fold [ Bool ] (iszero a)) . c))
({ d = (case (pred "apple") of < e = e > => ((iszero "apple") (if unit then 2 else "apple")) | < c = c > => (case (1 "apple") of < c = a > => (fold [ A ] b) | < b = c > => (inert [ (Bool -> C) ]))) , a = (\ c : ({ d : C , e : C }) . (if b then 1 else ("apple" as Bool))) })
(fold [ (Rec C . (({ b : Float , c : Nat }) -> (A -> Bool))) ] (if (2 . e) then (case (case (fix 0) of < c = a > => b | < d = c > => (c "apple")) of < e = a > => (c as Bool) | < d = b > => (inert [ Float ])) else (pred 2)))
(iszero ((let b = (unfold [ Unit ] b) in (pred 1)) as (({ b : Float , c : (Bool -> Bool) }) -> (Rec C . String))))
(succ (pred (pred false)))
(inert [ (< d : (< c : (Rec C . Float) , e : ({ b : A , e : Nat }) >) , e : (Rec D . Unit) >) ])
(fix (pred (< d = (case (pred 2) of < e = a > => "boy" | < a = d > => c) > as (< c : A , d : A >))))
(inert [ ({ a : (Bool -> C) , a : (< a : ({ e : String , b : C }) , c : A >) }) ])
(unfold [ ({ e : (< c : ({ e : A , b : B }) , c : Unit >) , e : (Nat -> Unit) }) ] ((inert [ (Unit -> C) ]) (let e = (iszero a) in false)))
(fix (inert [ ((Rec D . B) -> ({ a : Unit , c : Nat })) ]))
((fix (< c = (pred unit) > as (Rec C . Bool))) ((let e = unit in 0) (succ 0)))
(fix (\ a : ({ e : Unit , d : C }) . ("apple" as B)))
((case (\ a : A . 0) of < e = b > => (< d = (pred true) > as ({ a : Unit , e : Float })) | < d = c > => (1 0)) ({ e = ("boy" as Nat) , c = (if c then 1 else false) }))
(fix ((let e = (if "apple" then "boy" else c) in ((0 as B) as (String -> String))) as ({ a : Unit , e : (Nat -> Bool) })))
((inert [ (A -> C) ]) as (({ b : (Rec D . Nat) , b : Nat }) -> (A -> Float)))
(\ a : (Rec A . (< e : (< e : B , c : String >) , b : (B -> ({ d : Unit , b : A })) >)) . (let a = ((fold [ B ] b) as Unit) in (unfold [ (< a : A , e : Bool >) ] (2 . c))))
(fold [ (< a : (< d : (Rec E . Bool) , c : (A -> A) >) , b : (Rec C . (< c : Float , b : String >)) >) ] ((fold [ B ] "boy") (fix 2)))
(inert [ (({ c : String , b : Nat }) -> (< e : String , d : A >)) ])
(succ ((fix (1 as C)) as ({ a : ((Rec E . C) -> Float) , a : (Rec C . Float) })))
({ d = (fix (fold [ ({ a : Float , d : A }) ] ("apple" false))) , c = (if (fix true) then (succ (\ a : Bool . (pred 2))) else (inert [ (< c : String , b : (Rec C . Nat) >) ])) })
(< c = (fold [ (Rec D . String) ] (< e = 0 > as (A -> String))) > as ((< c : B , e : Float >) -> (Float -> Nat)))
(inert [ (< a : ({ d : A , a : (C -> B) }) , d : (< b : String , c : (< b : C , b : String >) >) >) ])
(< d = (succ (fold [ Unit ] 1)) > as (< c : (< a : C , c : B >) , c : (Rec E . ({ e : C , c : Unit })) >))
(unfold [ (< c : (< e : B , e : Bool >) , b : ({ b : Nat , e : Float }) >) ] ((iszero ("boy" . d)) (fold [ Unit ] false)))
((< b = (fix (\ e : B . c)) > as (Rec C . B)) as ({ e : (({ a : B , e : Bool }) -> ((< e : Unit , d : Bool >) -> (Rec E . String))) , c : (Rec C . (Rec B . Bool)) }))
(unfold [ (Rec D . (< d : (Bool -> B) , b : (Rec A . A) >)) ] (("apple" as Nat) as (Rec C . Unit)))
((< a = (pred a) > as (A -> (< a : String , d : Unit >))) . a)
(((fold [ (Rec D . C) ] false) (c as (Unit -> B))) . e)
(fix ({ b = (case 0 of < a = a > => "boy" | < d = b > => b) , b = ({ a = (inert [ Bool ]) , e = (fix b) }) }))
(\ e : ({ a : ((Rec A . Float) -> B) , b : (< e : (Rec E . B) , b : (Rec B . C) >) }) . (let a = (iszero (fix unit)) in (unfold [ (Bool -> A) ] (iszero 1))))
({ b = (if (let b = "apple" in 1) then ({ a = "apple" , e = unit }) else (iszero c)) , d = (fix (fix (iszero (2 . a)))) })
(iszero ((c . c) . d))
({ b = (inert [ (Rec C . Nat) ]) , d = (fold [ (Rec A . Unit) ] (fold [ ((Rec A . C) -> (Float -> C)) ] (let d = "apple" in 1))) })
((\ c : (Rec D . Unit) . (fix ("boy" . e))) ((unfold [ Nat ] 0) as (Rec E . B)))
({ a = (({ e = (unfold [ Float ] unit) , d = (case (fold [ Unit ] 2) of < c = d > => (unit b) | < d = d > => (inert [ Bool ])) }) (b false)) , b = ((pred false) . c) })
(\ d : ((< a : (B -> Bool) , e : ({ d : B , b : A }) >) -> (Rec B . Float)) . (let b = (unit as Float) in (if "boy" then (unfold [ C ] true) else 1)))
((inert [ (Rec D . (Rec E . C)) ]) (unfold [ (Rec A . (< d : Bool , c : Unit >)) ] ((\ a : (Rec D . B) . (succ 0)) as (< c : B , e : Bool >))))
(succ (pred (fix unit)))
(inert [ (({ d : C , c : A }) -> (Unit -> B)) ])
((let a = (pred "boy") in (2 . b)) ((succ ({ e = (a 0) , b = (fix false) })) as ({ e : (< e : C , d : (Rec B . C) >) , b : (B -> ({ c : Float , c : Float })) })))
(\ c : (Rec E . ((< a : A , e : B >) -> ({ c : C , b : Float }))) . (let e = (let b = (< e = (pred b) > as Float) in (pred "apple")) in ((fold [ ({ d : A , d : String }) ] a) as (< b : Float , e : Nat >))))
((if (fold [ ({ c : (Rec E . Float) , e : (C -> Nat) }) ] (inert [ (Rec B . B) ])) then (iszero false) else ((inert [ Nat ]) as ({ d : (Rec C . Bool) , c : ({ e : Float , a : Float }) }))) . e)
(fix (\ b : (< d : C , c : B >) . (unfold [ Nat ] "boy")))
(\ b : ({ b : (Nat -> Nat) , e : (< b : Bool , d : String >) }) . (iszero (let e = false in 2)))
(let b = (fix (iszero (fold [ Float ] a))) in ((2 as Unit) as (Rec C . ({ c : Float , a : Bool }))))
(if (inert [ (< c : ({ b : A , b : Bool }) , a : ({ a : Bool , c : Float }) >) ]) then (\ b : (Rec D . C) . (if "boy" then ({ c = 1 , b = a }) else a)) else (pred (case (let c = "boy" in b) of < e = e > => (unfold [ Bool ] 1) | < e = e > => (< c = (1 as Unit) > as Unit))))
(inert [ (Rec E . ({ b : C , b : B })) ])
((< e = ((\ d : Nat . "apple") . c) > as (Rec A . (({ a : Float , c : A }) -> (< a : A , d : Float >)))) . c)
((< d = (succ false) > as (Rec E . Float)) (succ ((succ b) . e)))
(succ (iszero (fix unit)))
(fix (let e = ((fix "apple") as ({ a : Unit , e : String })) in ({ a = (\ a : Nat . c) , a = (fix true) })))
(fix (case (a . b) of < a = d > => (iszero (if "apple" then 0 else 2)) | < a = a > => (let a = b in ({ c = c , e = "apple" }))))
((inert [ (< d : (Rec C . (Rec A . String)) , b : (Rec B . String) >) ]) ((< b = (succ false) > as (Rec C . B)) . b))
(if (\ d : (Unit -> Nat) . (iszero c)) then (fold [ ((Rec A . (Rec D . A)) -> ({ c : B , c : (< a : Float , e : String >) })) ] (case 0 of < a = d > => (let c = a in b) | < e = a > => "boy")) else ((pred true) . e))
(pred (pred (< d = b > as B)))
(inert [ ({ a : (Rec A . Bool) , a : (< c : A , a : (A -> Float) >) }) ])
(fold [ (Rec E . (Rec B . (Rec A . B))) ] ({ d = (c as Bool) , c = (if b then unit else c) }))
(({ b = (pred 2) , a = (a as Bool) }) (case (< a = 2 > as Float) of < c = e > => (fix 0) | < b = b > => (succ "apple")))
(((let b = a in b) (succ (1 . e))) ((iszero 2) as ({ c : (Rec A . A) , d : ({ d : Nat , a : (Rec C . B) }) })))
({ c = (iszero (pred (\ d : String . 2))) , a = ({ b = (iszero 0) , a = (pred ({ a = 0 , e = true })) }) })
(unfold [ ((< c : C , a : C >) -> (B -> C)) ] (let a = (inert [ C ]) in (succ 1)))
(case (fix (if "apple" then 2 else false)) of < c = a > => (case (\ d : ({ e : Unit , a : C }) . b) of < e = e > => ((\ c : C . "boy") "boy") | < b = a > => (if (a as Unit) then (inert [ ({ d : Float , d : Float }) ]) else (inert [ B ]))) | < c = b > => (succ (pred 0)))
(fold [ (Rec B . (< e : (A -> C) , c : (Rec B . Unit) >)) ] (fold [ (< d : (< a : B , e : Bool >) , a : ({ d : B , e : C }) >) ] (iszero (case "apple" of < b = e > => b | < a = e > => "apple"))))
((iszero (case b of < d = a > => a | < a = c > => (fix 2))) (iszero (pred 0)))
(if (iszero ((true as Float) 2)) then (succ ({ e = 0 , b = 2 })) else (\ e : ({ c : B , e : Bool }) . (iszero (unfold [ B ] a))))
(pred (case (fix ({ d = 0 , e = false })) of < d = a > => (succ ({ a = b , b = false })) | < a = c > => (let c = (let c = true in (pred 0)) in (({ c = c , c = "apple" }) as (Rec D . B)))))
((if (if b then "apple" else 1) then (\ b : Nat . (< c = "boy" > as C)) else (fold [ Bool ] true)) (if (iszero (unfold [ A ] true)) then (pred ({ e = (case 0 of < b = b > => 2 | < a = e > => false) , e = (let d = a in a) })) else (if (unfold [ Unit ] unit) then (pred 0) else (c 0))))
({ c = (pred ((succ "boy") as ({ e : Nat , d : C }))) , d = (< d = (< a = "boy" > as Nat) > as (< e : C , d : Nat >)) })
(inert [ ({ c : (Rec B . ((Unit -> A) -> (< c : A , c : Float >))) , e : (({ d : A , b : String }) -> (Rec A . Unit)) }) ])
((case (fix (case "boy" of < e = a > => 1 | < e = c > => unit)) of < a = d > => (case 1 of < c = b > => "boy" | < d = b > => 2) | < e = d > => (inert [ (< c : C , c : C >) ])) (pred ((\ a : C . true) as ({ e : B , b : C }))))
(iszero ((iszero 2) as ((Rec B . C) -> ({ e : Nat , d : A }))))
(iszero (succ (if (case 2 of < e = e > => 1 | < d = a > => 1) then (fold [ A ] c) else (succ unit))))
(unfold [ ((C -> ({ e : B , a : Float })) -> (Rec D . (< c : (< b : Float , c : B >) , a : ({ e : A , d : Float }) >))) ] (if (iszero true) then (iszero unit) else (if (fix 2) then (iszero "apple") else 0)))
(fix (fold [ (< a : (String -> C) , d : B >) ] ({ e = ({ a = unit , d = 0 }) , b = (iszero (let d = "boy" in "boy")) })))
(if (fold [ ({ e : (Rec C . C) , a : (< b : ({ e : Unit , b : B }) , a : A >) }) ] (case (iszero unit) of < b = b > => (fold [ A ] "boy") | < a = b > => (fold [ Nat ] 1))) then (if (fold [ ({ b : Unit , d : A }) ] (inert [ A ])) then (fold [ (Rec A . String) ] unit) else (case c of < b = a > => "boy" | < e = e > => unit)) else (let e = (iszero (\ b : C . (pred a))) in ((< c = b > as Nat) (< b = 0 > as String))))
(< b = (< a = (unit (iszero "boy")) > as (({ c : B , d : Nat }) -> (< a : Bool , d : Nat >))) > as (Rec E . ({ a : (< a : Bool , a : A >) , b : ({ d : (< e : B , a : B >) , d : String }) })))
(succ (\ b : ({ e : (< e : C , d : Float >) , b : C }) . (\ e : ((Rec A . Bool) -> (< b : Nat , c : Unit >)) . (iszero 2))))
(case (let c = ({ c = c , e = b }) in (\ c : Nat . unit)) of < c = c > => (let d = (fix 1) in (< c = 2 > as B)) | < c = a > => (if (if 0 then "apple" else b) then (case (inert [ B ]) of < e = d > => (if unit then 0 else 1) | < c = d > => 0) else (< c = (b . d) > as (Rec D . Float))))
(({ d = (iszero (if 0 then a else a)) , a = (pred ({ a = (if 1 then 1 else false) , c = unit })) }) . c)
(case (inert [ ({ e : A , a : (< c : String , c : Float >) }) ]) of < c = e > => (fix (let e = true in b)) | < e = a > => ((< b = c > as A) as (< a : (Rec D . Bool) , e : (A -> String) >)))
(fix ((case true of < e = b > => a | < d = c > => "boy") (case (if unit then true else 1) of < d = d > => (inert [ A ]) | < e = b > => 2)))
(< a = ((inert [ (Nat -> Bool) ]) as ({ d : Float , c : Unit })) > as (< c : (Rec E . C) , a : (< a : Unit , d : Unit >) >))
(unfold [ (< b : ({ e : String , a : Unit }) , d : ({ e : (< b : Nat , c : B >) , d : B }) >) ] (case (fold [ (Rec B . Nat) ] b) of < d = a > => (succ true) | < b = c > => (\ c : String . (let d = "boy" in unit))))
(fix (fix (iszero (fix "boy"))))
(let e = ({ b = (pred c) , e = (< e = (\ a : C . "boy") > as (Unit -> A)) }) in (< c = (< e = b > as (C -> Bool)) > as (Nat -> String)))
((pred ({ b = "boy" , e = (a as B) })) . e)
((unfold [ (< b : (Unit -> Bool) , a : (< c : A , d : Unit >) >) ] ({ d = (inert [ Bool ]) , e = (1 as Bool) })) . d)
(fix (if (pred (fold [ A ] 0)) then ((< c = a > as Unit) as Float) else (\ d : Unit . 2)))
(fold [ (< d : ({ b : ({ d : (< e : Unit , c : Bool >) , a : A }) , d : ({ d : Nat , a : C }) }) , b : ({ b : ({ e : (Rec A . Unit) , d : Nat }) , e : (Rec A . String) }) >) ] (pred (let b = (< e = 0 > as (< b : Float , b : Float >)) in (iszero (succ false)))))
(fix (unfold [ (Rec A . String) ] (let c = 0 in 0)))
(\ c : ({ d : ({ b : (B -> Float) , b : (Rec B . Unit) }) , c : ((Rec D . Nat) -> Bool) }) . (inert [ (< a : C , b : Bool >) ]))
((inert [ (A -> Bool) ]) (\ e : (< b : Nat , e : Float >) . ({ b = (pred (succ unit)) , c = (iszero unit) })))
(if ({ c = ({ d = (b true) , d = (1 . e) }) , c = (\ b : Unit . 2) }) then (case (fold [ (< d : Bool , d : Unit >) ] (unfold [ Bool ] false)) of < a = b > => (case (inert [ Float ]) of < e = e > => (if c then a else 0) | < a = b > => (let a = (\ e : Unit . 0) in (pred "apple"))) | < a = a > => (iszero (if true then unit else (case c of < b = c > => 2 | < a = d > => "boy")))) else (unfold [ ((C -> Float) -> ({ a : Float , b : Float })) ] (\ d : B . false)))
(((iszero (iszero a)) ((let e = a in 2) (case true of < e = b > => 0 | < d = c > => "boy"))) . e)
((fix (if (\ d : Nat . 2) then (inert [ (Bool -> B) ]) else (unfold [ Nat ] false))) . a)
(fix ((< a = (a as String) > as (< b : Bool , e : Float >)) as (Rec C . C)))
(unfold [ ({ c : (< e : (Rec A . Nat) , d : (Rec E . A) >) , c : (A -> String) }) ] (\ b : ({ d : (Rec D . String) , e : (Bool -> A) }) . (fold [ B ] a)))
(fold [ (Rec D . (< b : Unit , b : (< c : B , a : String >) >)) ] (case (fix (unfold [ Bool ] "boy")) of < b = d > => (if (fold [ String ] true) then (unit . a) else (inert [ String ])) | < c = b > => ({ e = (succ 2) , d = (fold [ A ] b) })))
(iszero (pred (\ e : C . (case c of < c = a > => "apple" | < d = e > => 0))))
(\ e : (({ a : (({ d : Unit , c : A }) -> ({ d : A , c : Bool })) , e : (Rec B . Float) }) -> ((< a : B , c : A >) -> (Rec A . Unit))) . ((iszero true) as (Rec C . B)))
(fold [ (< c : (Rec E . B) , e : (< d : B , c : Bool >) >) ] (inert [ ({ d : (Nat -> B) , b : ({ c : C , e : Bool }) }) ]))
(unfold [ (({ e : Nat , b : B }) -> (< b : Unit , a : C >)) ] (pred (let c = 0 in 0)))
(((pred (case c of < b = d > => 2 | < d = b > => c)) . e) (< c = ((< b = c > as Bool) as ({ e : Float , c : Float })) > as (< c : C , e : (Bool -> Unit) >)))
(inert [ (< c : (Nat -> Float) , b : (Rec E . B) >) ])
(unfold [ (({ b : ({ c : B , d : Float }) , b : (Rec E . (Bool -> Nat)) }) -> (Rec D . Bool)) ] (\ b : ({ b : Bool , a : ({ c : Float , e : B }) }) . ({ b = (unit as A) , b = 0 })))
((if (true . d) then (b as A) else (let b = false in 2)) (if (inert [ Unit ]) then (iszero 2) else (\ d : Nat . 2)))
(if (case (if c then b else (inert [ A ])) of < b = a > => (b a) | < b = e > => (inert [ (< d : C , b : Nat >) ])) then (pred (fix "boy")) else (if (fold [ ({ a : B , b : A }) ] true) then (inert [ String ]) else (pred c)))
(\ e : (Rec D . (< c : B , a : String >)) . (let c = ({ d = ((pred "apple") as (C -> B)) , c = (case c of < b = d > => "boy" | < e = a > => "boy") }) in (succ (succ 2))))
(fold [ (Rec B . (< e : (A -> Bool) , d : String >)) ] (if ("boy" as Bool) then (< b = (unit as Float) > as String) else (case 0 of < b = c > => (fix "apple") | < c = e > => (succ c))))
(\ a : (Rec B . (< e : Float , b : String >)) . (unfold [ (< b : String , b : B >) ] (case (fold [ Nat ] "boy") of < e = d > => a | < e = b > => unit)))
((pred (let a = (if c then a else 0) in (b 1))) . d)
(let a = ((let c = "boy" in b) ({ e = true , d = 0 })) in (fold [ (< c : (< d : Float , c : B >) , d : ((< a : A , a : Bool >) -> (C -> C)) >) ] ({ c = (false . e) , d = ((false "apple") 2) })))
(\ b : (< a : (Rec E . B) , e : ({ a : A , e : String }) >) . (iszero (pred b)))
((succ (unfold [ Nat ] (true . a))) ((fold [ String ] "apple") . c))
((< b = (({ e = 2 , c = "boy" }) c) > as (Rec B . (< a : Bool , c : Unit >))) . a)
(if (fix (\ c : ({ c : C , b : Float }) . c)) then (inert [ (({ e : Bool , a : C }) -> (Rec A . A)) ]) else (if ((if 0 then a else 1) as Unit) then (unfold [ ({ b : A , a : String }) ] (if "apple" then 2 else 1)) else (fold [ (Rec D . (String -> A)) ] ("boy" . c))))
((succ (fold [ Nat ] (let d = 1 in "apple"))) as ({ c : (< d : (Rec B . (C -> A)) , b : ({ a : Unit , a : Nat }) >) , e : (< d : ((< e : Float , a : C >) -> (String -> B)) , a : (Rec C . (Rec D . Unit)) >) }))
(iszero (if (fix (if 0 then (succ unit) else (iszero a))) then (fold [ (A -> C) ] "boy") else ((pred a) . d)))
(unfold [ ({ c : (< b : (< e : A , d : C >) , b : ({ d : B , c : Float }) >) , b : (Rec C . Unit) }) ] (case (unfold [ (Nat -> C) ] a) of < c = b > => ((pred 1) . d) | < b = d > => (inert [ (Bool -> Unit) ])))
(pred (iszero (fold [ Nat ] (succ a))))
(unfold [ (< c : ((Rec A . ({ d : String , e : Bool })) -> (< c : (A -> String) , a : (Float -> A) >)) , a : (< d : Float , d : (Unit -> C) >) >) ] ({ b = ({ b = (let a = "apple" in unit) , a = "boy" }) , e = (if (let c = 0 in 0) then a else (< a = 2 > as Float)) }))
(({ d = (iszero false) , d = (pred false) }) as ({ a : (Rec C . Nat) , a : (< e : C , a : (Rec A . A) >) }))
((\ a : (({ e : Bool , c : Float }) -> (Rec C . (B -> Unit))) . (unfold [ ({ a : B , c : Float }) ] b)) (fix (if (\ e : Nat . true) then (false as Nat) else b)))
(succ (succ (iszero (inert [ Bool ]))))
(pred (pred (fix "boy")))
(< c = (inert [ (< b : String , e : Bool >) ]) > as ({ d : ({ d : (Rec B . (Rec D . Unit)) , c : (< e : C , a : C >) }) , a : (Rec B . (Rec C . B)) }))
(fix (succ (a . e)))
(iszero ({ b = (let a = b in (succ 2)) , a = ({ a = false , e = "apple" }) }))
((case (unfold [ Float ] c) of < a = d > => (iszero (pred b)) | < b = e > => (inert [ (< e : String , b : Float >) ])) as (Rec E . ((Rec C . Nat) -> (String -> ({ e : Float , c : B })))))
(fix (((fix false) as (({ a : Unit , a : Bool }) -> Float)) as (< c : ((C -> Nat) -> (A -> C)) , b : (< a : B , c : (Rec D . A) >) >)))
(fix (< c = (< a = a > as Nat) > as ({ d : (Rec B . A) , b : (Nat -> B) })))
(\ c : (< d : ((Rec C . B) -> ({ b : Nat , b : Bool })) , a : ((< c : A , b : Bool >) -> ((Rec A . A) -> (Bool -> C))) >) . ((if b then b else a) (\ c : Bool . a)))
(((succ 2) . c) (({ e = (inert [ A ]) , e = (pred false) }) . a))
((succ (case (inert [ A ]) of < b = c > => (\ a : A . "boy") | < e = d > => 1)) . d)
(let b = (iszero (succ (iszero "boy"))) in (< c = ((fold [ Float ] true) . c) > as (({ a : B , d : A }) -> Nat)))
({ c = (\ e : ({ c : A , e : String }) . (fix (unit as Bool))) , c = ({ d = (< d = (fix false) > as (< d : Unit , a : Bool >)) , d = (unfold [ Bool ] b) }) })
(< c = (if (succ 0) then (inert [ Nat ]) else ({ a = (if unit then 0 else 2) , e = false })) > as ({ a : (Rec D . Bool) , d : (< c : A , e : (Float -> C) >) }))
(if (pred (case (inert [ String ]) of < e = c > => (let b = b in ({ b = "apple" , c = 1 })) | < e = c > => (succ unit))) then ((false . a) (let b = (let a = c in 1) in (succ true))) else (unfold [ (Nat -> Float) ] (succ "boy")))
(pred (fold [ (String -> String) ] (inert [ (< b : Bool , b : Unit >) ])))
(fold [ (Rec C . (Rec B . Nat)) ] (unfold [ (({ a : Float , a : A }) -> C) ] (< d = (succ a) > as (< e : A , d : C >))))
(\ d : (({ a : (Rec E . C) , e : (Rec A . Nat) }) -> (< e : (Nat -> Float) , e : (Bool -> Bool) >)) . (\ b : (< d : A , b : A >) . ({ b = "boy" , d = (< e = false > as B) })))
((< d = (unfold [ ({ d : Nat , d : String }) ] false) > as ({ b : A , c : (< d : Bool , a : Unit >) })) as ((Rec A . ({ b : C , e : Bool })) -> (Rec C . Bool)))
(unfold [ (< e : (Rec A . (< e : Bool , b : Bool >)) , d : (< e : ({ e : Bool , b : B }) , e : (A -> C) >) >) ] ((inert [ (< e : B , a : ({ b : Nat , e : Bool }) >) ]) as ({ a : (Nat -> (Rec C . Nat)) , a : (Rec A . A) })))
(({ e = (let e = "boy" in "apple") , d = (fix c) }) . e)
(let b = (inert [ ({ e : (Nat -> Bool) , e : (Rec D . Float) }) ]) in (iszero (({ d = ({ e = false , c = c }) , d = 0 }) . a)))
(case (unfold [ (Rec C . B) ] (unfold [ String ] "apple")) of < c = b > => (succ ({ c = 1 , e = a })) | < a = a > => (let a = (pred (\ b : B . (unfold [ C ] "boy"))) in (0 as (A -> A))))
((let c = ({ e = (2 as A) , c = (2 . e) }) in (fold [ (B -> Float) ] (pred 1))) (pred (if (pred (let c = 0 in "boy")) then (\ c : Unit . unit) else (iszero unit))))
((inert [ (Rec E . String) ]) as (< b : (Rec E . A) , a : (Rec A . C) >))
((fix (false as (< d : Float , b : Nat >))) (fold [ ((Bool -> Float) -> ({ a : Nat , e : Bool })) ] (fold [ (Rec C . (A -> Bool)) ] (succ false))))
(unfold [ (((< e : String , c : C >) -> (Rec D . B)) -> (< a : Nat , d : ({ a : Nat , d : Unit }) >)) ] (succ (false . d)))
(unfold [ (< b : (A -> Float) , a : ({ d : (Bool -> A) , c : (A -> Nat) }) >) ] (\ d : (< e : (< c : (Rec C . A) , a : (Float -> C) >) , b : (Float -> Bool) >) . (inert [ ((< e : C , a : Nat >) -> (String -> Float)) ])))
(fold [ (< a : (Rec B . Nat) , c : (< e : Bool , b : Bool >) >) ] (inert [ (Bool -> String) ]))
(let a = (((pred 0) (case b of < e = c > => a | < a = d > => unit)) . b) in (let b = (case (1 "apple") of < c = b > => (fix "apple") | < b = b > => (2 a)) in (unfold [ Unit ] (iszero b))))
(case (if (inert [ ({ e : C , b : Float }) ]) then (case (2 "apple") of < d = e > => (succ a) | < a = d > => (fix "boy")) else (fold [ Nat ] (iszero unit))) of < a = e > => (\ d : ((Rec E . Unit) -> (Rec E . A)) . (unfold [ (Rec B . A) ] (unfold [ Bool ] "apple"))) | < b = e > => ((b . a) (unfold [ ({ e : Nat , b : A }) ] (\ c : String . false))))
((let d = (case "boy" of < c = a > => 0 | < a = e > => 0) in (pred (unit as Float))) . d)
(iszero (< d = ("apple" . d) > as (Rec D . ({ a : Unit , d : Bool }))))
(let e = (inert [ (Rec A . String) ]) in (case (< a = unit > as Nat) of < a = e > => ((fix c) as (< a : ({ d : A , d : C }) , e : C >)) | < e = b > => (let d = (iszero "boy") in (false as Bool))))
(iszero (succ ((unfold [ (< d : Unit , c : String >) ] (< d = false > as Bool)) . e)))
(< d = ((pred (iszero 0)) . d) > as ((< e : A , a : Unit >) -> (Rec C . A)))
(succ (fold [ ({ c : (< a : ({ b : B , b : B }) , b : (Float -> Float) >) , e : (({ c : String , a : Bool }) -> (< d : Unit , b : Bool >)) }) ] ((< a = "apple" > as B) as Nat)))
(let d = (let d = (succ 1) in ({ e = true , c = "apple" })) in (fix (let e = false in a)))
(pred (inert [ (< b : Unit , a : C >) ]))
(\ b : ((Float -> Unit) -> ({ c : B , e : Unit })) . ((unfold [ Unit ] 1) . d))
(unfold [ (< d : (< d : String , b : A >) , a : ({ e : String , b : B }) >) ] (< d = ((unfold [ B ] c) (fold [ (< c : Float , c : B >) ] a)) > as (< d : Float , d : Nat >)))
((fold [ (String -> A) ] (iszero 1)) ({ d = (< c = a > as Float) , d = (pred "boy") }))
(pred (succ ((< a = b > as Unit) (inert [ Float ]))))
((iszero (case c of < c = b > => "boy" | < c = e > => c)) . b)
((pred (< d = (fix "apple") > as Bool)) as (Rec B . ({ a : ({ b : B , e : Bool }) , e : (Rec D . C) })))
(< b = (iszero (succ ((case 1 of < c = e > => a | < c = b > => unit) . a))) > as (Rec C . (< b : Nat , c : B >)))
((inert [ ({ d : (Unit -> Bool) , b : (Unit -> String) }) ]) . a)
(< b = (fold [ (Nat -> String) ] (\ a : Unit . 0)) > as (< c : (Rec E . (< c : Float , e : Nat >)) , c : ({ d : Nat , e : (< d : B , d : B >) }) >))
(unfold [ ({ d : (Rec D . String) , a : (A -> String) }) ] (if (case (\ d : String . a) of < a = e > => (pred 0) | < c = e > => ((let b = a in b) . a)) then (succ (true as A)) else (unfold [ (< e : A , e : A >) ] (fold [ Unit ] true))))
(iszero (inert [ ({ d : (< c : String , e : Bool >) , d : C }) ]))
(fix ((< a = c > as (< e : B , b : Nat >)) as (Rec A . Unit)))
(fix (iszero (unfold [ (Rec E . Bool) ] 0)))
(< a = (((let d = b in 1) as Nat) . e) > as (< c : (Rec E . (< d : Bool , e : Float >)) , b : (Rec B . Unit) >))
(inert [ (({ c : (Rec D . A) , c : Float }) -> (A -> A)) ])
(({ c = ((unit . d) as ({ d : C , b : Bool })) , a = (\ b : (({ e : A , c : Bool }) -> ({ e : Float , b : B })) . (iszero 1)) }) as (< c : (< a : (< b : A , c : (< d : A , c : Bool >) >) , c : (Rec E . Nat) >) , e : (Rec A . (({ a : Nat , c : A }) -> C)) >))
(case ((inert [ (Rec E . B) ]) (if ({ e = false , c = 0 }) then b else (let d = unit in c))) of < c = b > => (if (b as Unit) then (unit as Bool) else (inert [ Float ])) | < a = b > => ({ b = (0 . a) , e = ({ c = (\ b : A . unit) , a = (\ c : String . b) }) }))
(fix (((iszero 0) (fold [ B ] "boy")) (succ "apple")))
(iszero (succ (unfold [ Nat ] b)))
(let a = (\ b : (({ c : B , d : Float }) -> ({ b : Nat , e : B })) . (case true of < a = b > => "apple" | < c = a > => a)) in (inert [ (Rec A . ({ a : C , b : A })) ]))
(pred (fold [ ({ b : (Nat -> Unit) , d : (Float -> B) }) ] (if 2 then 1 else 1)))
(inert [ ({ a : (B -> ({ d : String , b : B })) , d : (Rec A . B) }) ])
(iszero (if ({ c = unit , e = (succ "boy") }) then (< d = (\ d : Float . "boy") > as (Nat -> Unit)) else (case (succ (pred c)) of < e = b > => (if (\ c : B . true) then (1 "boy") else 2) | < a = a > => (case b of < c = e > => true | < c = c > => a))))
(< b = (case (fix (\ d : C . "apple")) of < c = a > => (iszero (0 . d)) | < a = a > => (pred (unfold [ Nat ] unit))) > as (((< a : C , a : (B -> Unit) >) -> (Unit -> A)) -> ({ e : (< d : Nat , a : String >) , e : String })))
((let d = ("apple" false) in (c . c)) ({ e = (fix true) , e = (let c = 0 in c) }))
(fix (iszero (\ d : Bool . (if a then "boy" else a))))
({ e = ((inert [ (String -> C) ]) (fold [ (< c : String , c : Unit >) ] (iszero (2 as C)))) , d = (succ ((fold [ Bool ] a) . c)) })
(iszero (pred (inert [ String ])))
(((< b = b > as Bool) . e) . d)
(succ (let b = ({ e = "apple" , d = 0 }) in (unfold [ Bool ] 1)))
(succ (inert [ ((< b : B , c : (Rec C . Nat) >) -> ({ d : B , e : Nat })) ]))
(((if (true as Bool) then (fold [ Bool ] false) else (if (case c of < a = e > => false | < c = d > => c) then (succ true) else a)) (inert [ Float ])) ((case (fix false) of < d = c > => (< a = false > as Nat) | < d = c > => unit) (fix false)))
(pred (inert [ (< e : String , b : B >) ]))
(let d = (pred ((fold [ Nat ] "boy") . d)) in (iszero (\ d : Unit . "apple")))
(iszero (if (\ b : (< d : (Unit -> Float) , b : (Nat -> Nat) >) . (unfold [ Bool ] unit)) then (fold [ (Rec C . Nat) ] "apple") else (if ("apple" as ({ d : Unit , c : A })) then (let d = b in c) else (succ true))))
(({ a = (\ a : Unit . 0) , d = (inert [ ({ a : Nat , b : Unit }) ]) }) (pred ((inert [ Nat ]) as (< a : A , e : C >))))
(({ a = (\ b : (Rec D . Unit) . (fix a)) , c = (pred (iszero (case unit of < e = c > => "apple" | < b = e > => true))) }) as (< c : (({ d : C , b : (Unit -> Unit) }) -> (< d : Bool , d : String >)) , b : (< e : ({ a : Float , d : A }) , a : (Rec E . Bool) >) >))
((pred (fold [ B ] (let c = 2 in true))) . a)
(({ a = (\ e : ((Rec C . A) -> String) . (b . d)) , a = (true as (< a : Unit , a : Unit >)) }) . b)
(fold [ ({ e : (Rec D . ({ d : Unit , c : Float })) , c : ({ e : (< d : C , a : Nat >) , d : (Rec E . B) }) }) ] (case (c as C) of < e = b > => (inert [ Bool ]) | < b = c > => (case "boy" of < d = c > => 2 | < c = a > => false)))
(pred (iszero ("boy" a)))
(\ e : (< a : (Rec D . Unit) , c : (< e : C , e : (Rec B . Float) >) >) . (if (case 1 of < d = b > => c | < b = a > => b) then (0 as C) else (inert [ C ])))
(iszero (pred ("boy" . d)))
(\ e : ({ b : (< e : Bool , e : C >) , a : (Nat -> Unit) }) . (pred (case (fix b) of < d = c > => 2 | < a = a > => 0)))
(\ d : (({ a : C , a : B }) -> (< a : C , e : ({ d : B , c : C }) >)) . (case (let e = 0 in 1) of < c = c > => (case 2 of < e = c > => 0 | < e = d > => true) | < d = b > => (fold [ B ] unit)))
(((fix a) . e) ((inert [ Bool ]) as (Rec C . A)))
((iszero (< e = (unfold [ A ] c) > as A)) . b)
(fold [ ((Rec C . C) -> (B -> Nat)) ] ((succ (if b then "apple" else "apple")) as ((Rec A . B) -> ({ c : A , b : Float }))))
(iszero (if (b . c) then (succ false) else ({ c = (let d = false in b) , c = b })))
(pred (iszero (fold [ B ] 0)))
(< e = (let d = (b . a) in (if false then unit else 0)) > as ({ c : ({ d : (Bool -> B) , e : String }) , d : (Rec A . (Rec C . String)) }))
(if ((1 as C) (if (if unit then 2 else 2) then ("apple" . a) else (fold [ Bool ] a))) then (unfold [ (Rec D . A) ] (inert [ ({ d : Nat , d : Unit }) ])) else (case (2 as B) of < a = b > => (\ c : String . c) | < c = c > => (pred 2)))
(iszero (inert [ ({ a : (Unit -> Bool) , e : (< c : B , c : Bool >) }) ]))
(pred (unfold [ ({ c : Nat , c : B }) ] (succ 1)))
(iszero (let a = (\ e : ({ e : A , b : B }) . false) in (inert [ Nat ])))
((inert [ (Float -> C) ]) ((fix a) (succ (iszero 1))))
(case (if (pred (false true)) then (if (fix a) then (pred a) else (succ a)) else (pred (false . b))) of < e = b > => (\ b : ({ a : Float , a : Unit }) . (unfold [ (Rec E . C) ] false)) | < c = a > => (pred ("boy" as String)))
(succ ((iszero ({ d = unit , c = (iszero "apple") })) (iszero "apple")))
(inert [ ({ c : (Float -> (String -> Float)) , e : (Rec B . ({ c : Bool , e : B })) }) ])
(\ e : ({ c : (< e : Bool , c : Nat >) , a : (< a : B , b : Nat >) }) . (fix (inert [ Unit ])))
(case (fold [ (< d : Bool , c : Bool >) ] (fix a)) of < a = b > => (\ b : (Rec B . ({ a : B , b : Bool })) . (< a = "boy" > as (Float -> Unit))) | < b = e > => ((("apple" (fold [ B ] true)) . a) . d))
((< c = (fold [ (Rec A . Nat) ] ({ c = 2 , a = "apple" })) > as ((Float -> Bool) -> (Rec B . Float))) as (< c : ({ b : (< c : Bool , a : Nat >) , c : (C -> Nat) }) , a : (Rec B . (Rec D . String)) >))
(inert [ ((< c : (< d : C , c : C >) , c : (B -> C) >) -> ({ a : ({ e : Bool , a : Nat }) , c : ((A -> A) -> (C -> Unit)) })) ])
(fix (unfold [ (({ d : Float , e : String }) -> (Rec A . B)) ] (pred (iszero 1))))
(inert [ ({ a : (Rec D . Bool) , c : (< e : String , e : Bool >) }) ])
(inert [ (Rec A . (< a : B , e : (< d : String , c : A >) >)) ])
(inert [ (Rec E . (Rec D . (Rec A . A))) ])
(unfold [ ({ c : ((A -> Nat) -> (< c : Nat , b : B >)) , b : ({ e : (Rec A . A) , d : Bool }) }) ] (\ d : (< e : Nat , b : B >) . (< c = unit > as Bool)))
(fix (succ (fix false)))
(if (\ e : ({ c : Bool , b : Nat }) . (\ d : C . b)) then (({ d = true , a = false }) . b) else (inert [ (< d : (Rec D . A) , c : (Rec C . String) >) ]))
(if (let b = (< b = (inert [ Float ]) > as (({ a : Float , b : Unit }) -> A)) in (case "boy" of < d = c > => (let b = 1 in false) | < d = c > => (inert [ A ]))) then ({ a = (if 2 then unit else (iszero true)) , c = (fold [ String ] false) }) else ((unfold [ Float ] (c . b)) (fold [ (Nat -> A) ] (fold [ Float ] a))))
((if (iszero unit) then (if "apple" then c else a) else (unfold [ (Bool -> Nat) ] (let b = 1 in "boy"))) . e)
(pred ((fold [ (< e : Bool , c : B >) ] (fold [ Float ] (iszero a))) (pred (2 a))))
(fold [ (< d : (Float -> Nat) , a : (Float -> (< c : Float , b : B >)) >) ] (unfold [ ({ d : (< a : A , a : A >) , a : ({ c : Bool , e : Nat }) }) ] (case (fix 0) of < e = c > => ((iszero "apple") as B) | < c = a > => (case "apple" of < c = a > => false | < d = c > => unit))))
({ c = (\ c : (Rec C . B) . (unit b)) , e = (case (("apple" . c) as (Bool -> (Float -> B))) of < b = d > => ((succ "boy") . c) | < b = e > => (if ({ b = "boy" , d = false }) then (case (let b = 2 in unit) of < d = a > => (if "apple" then b else true) | < c = c > => (unfold [ Unit ] "apple")) else (b 0))) })
(fix ((< e = true > as (Rec E . C)) . b))
(inert [ (< c : ({ e : Float , d : (< a : A , a : B >) }) , a : (Float -> A) >) ])
(inert [ (Rec C . (Rec B . ({ e : Bool , d : A }))) ])
(inert [ ({ d : (Rec B . String) , e : (< a : Bool , a : Unit >) }) ])
((pred (fix (if b then "apple" else true))) as ({ e : (Rec B . (C -> Nat)) , a : (({ e : Unit , a : B }) -> ({ e : Unit , c : B })) }))
(succ (if (pred (succ unit)) then (< c = 0 > as Nat) else (pred (unfold [ C ] unit))))
((< e = ((fix (unfold [ Float ] unit)) . c) > as (({ a : String , e : Unit }) -> (Rec C . String))) . e)
((iszero (b . a)) . a)
(succ (< a = ("boy" (b 1)) > as (((< a : C , a : Bool >) -> Nat) -> ({ d : Float , b : Bool }))))
(if ((fix (false . a)) . e) then (unfold [ (Rec E . (< b : Float , d : B >)) ] (if (pred b) then (fix a) else (fix false))) else (pred (iszero unit)))
(if (fix (fix 0)) then (pred (succ 2)) else (fix (iszero (case 2 of < d = d > => "apple" | < a = a > => 0))))
(fold [ (< a : ((Rec C . C) -> (Rec B . String)) , e : ((C -> A) -> (Rec E . C)) >) ] (inert [ ({ b : ({ d : Bool , a : A }) , b : (Unit -> A) }) ]))
(fold [ (< a : (< e : Unit , a : B >) , a : (({ b : Float , e : Nat }) -> (Rec C . A)) >) ] (inert [ ({ e : A , d : (< d : Bool , c : Bool >) }) ]))
(case ((unfold [ (Rec A . (< d : B , e : String >)) ] (\ c : String . ({ d = c , a = b }))) (if ({ c = 2 , b = a }) then (case (let e = true in c) of < a = d > => (inert [ Bool ]) | < d = d > => (0 . a)) else (fold [ Unit ] c))) of < e = b > => (< b = (b . a) > as (Rec D . Float)) | < c = d > => ((pred b) ({ e = c , e = (case unit of < b = e > => b | < e = d > => 1) })))
(< c = (succ (if (if 1 then 0 else b) then (fix (fold [ C ] 0)) else (fold [ Bool ] 2))) > as ((Rec D . Unit) -> (< b : Bool , e : Bool >)))
(succ (\ b : ({ c : (Nat -> Bool) , a : String }) . ((\ b : Nat . c) as (Rec E . A))))
(let c = (iszero (\ c : A . 1)) in (case ({ a = "apple" , c = b }) of < e = a > => (let d = false in b) | < b = e > => (< c = 1 > as C)))
({ e = (fold [ ((Rec A . C) -> Bool) ] ((fix unit) (let e = unit in "apple"))) , a = (if (< e = unit > as A) then (iszero false) else (inert [ C ])) })
({ e = (\ b : ({ b : C , b : C }) . (succ (false as C))) , c = (pred (succ true)) })
(pred (succ (fold [ (A -> String) ] (let a = 1 in "boy"))))
(inert [ (< e : ((< d : Unit , e : Unit >) -> ({ b : (< e : Unit , c : B >) , c : (B -> Nat) })) , b : (< d : (< b : (C -> A) , d : (< d : Float , b : B >) >) , b : (Rec D . Float) >) >) ])
(fix (fix ({ a = 1 , d = false })))
((iszero ({ d = 1 , e = false })) as (< d : (< a : C , e : Unit >) , c : (Float -> Unit) >))
(succ (< d = (inert [ ({ a : String , b : C }) ]) > as (Unit -> C)))
((< b = (fix true) > as (Rec E . Float)) . b)
(< e = (< b = (1 as ({ b : Float , d : Bool })) > as (< d : B , b : (Rec A . Float) >)) > as (Rec D . (B -> Bool)))
(((2 (pred b)) . b) as (< e : (Rec D . (< a : Nat , c : Bool >)) , a : (Rec A . (Bool -> C)) >))
(unfold [ ((< c : (String -> Float) , e : B >) -> (< d : (Unit -> B) , c : (A -> A) >)) ] (iszero (pred (< d = c > as String))))
(unfold [ (< b : ({ e : ({ a : String , a : Unit }) , e : (Rec E . Bool) }) , e : (< c : (< d : Float , e : Nat >) , e : (Float -> (B -> Unit)) >) >) ] (case (pred (let e = 1 in "apple")) of < a = e > => (fold [ Bool ] false) | < c = c > => (unfold [ Nat ] true)))
({ e = (let e = (fold [ ({ d : Nat , a : B }) ] (inert [ C ])) in (iszero (succ b))) , d = (case ({ d = (pred 0) , a = (2 . c) }) of < c = d > => (succ (\ c : Float . 0)) | < b = e > => (unfold [ String ] "boy")) })
(iszero (inert [ (({ a : String , a : C }) -> ({ c : A , d : Nat })) ]))
(case ({ e = (pred 2) , c = ({ c = (b true) , d = (iszero true) }) }) of < b = d > => (pred (succ (case true of < e = e > => (< b = 2 > as Nat) | < a = b > => (case a of < e = a > => 0 | < a = a > => false)))) | < d = b > => (< a = (c (false as A)) > as ({ e : A , a : A })))
((unfold [ (< d : C , a : C >) ] (pred (a as Float))) . e)
(< e = (fold [ (Rec E . (Rec C . Float)) ] (inert [ (Rec E . A) ])) > as (Rec B . (< d : (Rec A . Float) , b : ({ e : Nat , d : A }) >)))
(pred (let a = (inert [ Nat ]) in (inert [ (< c : C , d : Unit >) ])))
(({ a = (iszero (a 1)) , c = ((unfold [ B ] unit) b) }) (inert [ (< c : (Rec D . C) , e : (< a : Nat , e : Nat >) >) ]))
(inert [ (< e : (< a : A , d : A >) , a : (Unit -> Float) >) ])
((inert [ (< c : (A -> Bool) , a : C >) ]) as (< e : (Rec A . ({ e : Float , c : (Rec A . C) })) , c : (< a : (< b : Unit , a : C >) , d : (< d : Float , a : B >) >) >))
(case (((b as A) . c) . b) of < c = b > => (succ ((if false then unit else 0) . b)) | < a = d > => (case (fold [ ({ e : C , c : (< b : Float , c : C >) }) ] ({ c = (2 "apple") , b = (inert [ C ]) })) of < a = a > => (("boy" as (B -> Nat)) . d) | < d = b > => (inert [ Bool ])))
(pred (unfold [ (String -> (Rec E . Float)) ] (iszero (< d = 1 > as Float))))
(unfold [ ({ b : (< c : (C -> B) , c : ({ e : Bool , a : Bool }) >) , d : (A -> A) }) ] (succ (({ a = unit , d = 0 }) as B)))
(if ((fix a) (iszero (unfold [ A ] 1))) then (unfold [ (Rec B . (C -> Float)) ] (fix c)) else (fold [ ((Unit -> Unit) -> (< e : Bool , d : B >)) ] (fix unit)))
(pred (fix ({ c = a , a = 1 })))
((pred (1 . b)) ((false . b) (fold [ A ] (fold [ String ] 0))))
(((\ b : B . "boy") as ({ e : ({ c : C , a : C }) , e : B })) (fix (< b = "apple" > as String)))
(succ (succ ("apple" . d)))
((\ b : (< a : (< a : A , a : Nat >) , a : Bool >) . (iszero ({ b = (if 2 then a else 1) , b = ({ b = "boy" , b = c }) }))) . e)
(case (let b = (< e = (0 . a) > as A) in (succ (\ c : (< a : B , e : Nat >) . (inert [ B ])))) of < b = e > => (< e = ({ e = c , a = a }) > as (Rec A . Float)) | < a = e > => (let d = (fix 1) in (let e = b in 1)))
({ b = (fold [ ({ e : A , a : C }) ] ({ c = c , a = c })) , e = ({ e = (case 2 of < e = c > => 1 | < b = b > => "apple") , c = ((2 (succ a)) as (Float -> Nat)) }) })
(pred (pred (fix false)))
(inert [ ({ b : ({ d : (Rec D . String) , b : (< b : B , d : Unit >) }) , b : ({ c : (Rec C . B) , a : (Rec E . (< a : Unit , b : Nat >)) }) }) ])
({ c = (pred (succ (b as String))) , a = (fold [ ({ d : B , e : (Rec B . Bool) }) ] (case (case (0 a) of < a = e > => ({ b = 0 , b = c }) | < d = c > => (\ c : Nat . 0)) of < b = c > => (if c then c else 0) | < d = d > => ((pred "boy") as (Rec C . String)))) })
(pred (iszero (iszero (1 c))))
(< a = ((let c = (case "apple" of < a = b > => (unit as C) | < b = d > => (case "boy" of < a = c > => "boy" | < d = b > => true)) in (false c)) as ({ e : ({ e : ({ e : Bool , a : Float }) , b : String }) , a : (Rec D . Unit) })) > as ({ d : (Rec B . Unit) , d : (Nat -> (Rec C . Bool)) }))
(inert [ (({ c : String , a : (< e : Bool , b : Nat >) }) -> (Float -> String)) ])
(< e = (\ a : (Rec D . A) . (let b = 2 in "apple")) > as ({ a : (Float -> Unit) , e : (< c : B , a : (Float -> Nat) >) }))
(\ a : ({ b : (< e : (< c : Bool , d : String >) , d : (< e : Nat , c : C >) >) , a : (A -> A) }) . (unfold [ ({ e : Bool , c : Nat }) ] (if "boy" then true else false)))
({ a = (succ (unfold [ String ] false)) , b = (pred (succ (b unit))) })
(inert [ (< d : (Rec B . ({ b : String , c : String })) , e : (Rec C . Float) >) ])
(< b = ((succ ({ b = "boy" , a = true })) as (Rec E . (Unit -> Unit))) > as ((< b : (Float -> C) , a : ({ b : Nat , d : B }) >) -> ((Rec A . A) -> (Float -> String))))
(if (fix ((unfold [ A ] 1) as ({ c : String , a : A }))) then (fix (if (inert [ (Rec B . Float) ]) then (iszero 0) else ("boy" as A))) else (unfold [ (Rec E . (Rec B . (Float -> String))) ] (iszero ({ e = false , e = a }))))
(let e = (let d = ("apple" false) in ({ b = "apple" , a = unit })) in (case (fold [ A ] 2) of < c = a > => (let d = b in 2) | < b = b > => (2 b)))
(iszero (succ (inert [ A ])))
(({ e = (case "boy" of < b = c > => ({ e = a , d = a }) | < b = c > => (pred false)) , a = (fix true) }) . a)
(\ d : ((String -> B) -> (Rec E . Float)) . (pred ({ c = (inert [ B ]) , a = b })))
(let b = (({ e = (unfold [ B ] "apple") , c = (a c) }) as ({ e : Unit , e : C })) in (< e = (< c = true > as (Rec B . B)) > as ((String -> Nat) -> (Nat -> Nat))))
(fix (unfold [ (< c : (< c : C , a : C >) , e : (Rec B . Nat) >) ] (iszero (succ "apple"))))
({ c = (fix (\ b : C . 2)) , e = (iszero (case (true as Unit) of < d = b > => (b as Bool) | < c = c > => c)) })
(fix ((fold [ (Rec D . String) ] 2) ((case unit of < b = e > => c | < e = e > => "apple") . c)))
({ d = (if (if (succ 2) then true else 0) then (unfold [ ({ a : Unit , d : Float }) ] 1) else (a . c)) , d = (unfold [ (< c : Unit , e : (Unit -> B) >) ] (fix (case true of < b = a > => "boy" | < d = e > => (iszero unit)))) })
(case (case (< b = (fold [ Bool ] b) > as (Bool -> (Rec E . String))) of < b = a > => ("boy" as A) | < c = b > => ((succ a) as (< a : String , d : Nat >))) of < a = a > => (iszero (unfold [ (Bool -> B) ] (let e = 0 in true))) | < b = a > => (inert [ (< d : (Rec E . A) , d : ({ d : A , b : C }) >) ]))
(< c = ({ d = (b . d) , b = (case c of < e = d > => (let e = b in unit) | < a = e > => a) }) > as (Rec A . (Rec D . (< b : C , a : Bool >))))
(unfold [ ({ e : ({ a : A , b : String }) , e : ((Rec B . Nat) -> ({ b : Float , c : Bool })) }) ] (< b = (< a = unit > as A) > as (Rec C . Bool)))
(inert [ ({ a : (Rec C . Unit) , b : (Unit -> Unit) }) ])
(pred (iszero (inert [ String ])))
(\ b : (< a : ({ b : ({ a : A , b : Bool }) , a : String }) , a : ((Rec C . Unit) -> (String -> String)) >) . ((fold [ String ] b) (fold [ Unit ] b)))
(iszero (let c = (case "boy" of < c = a > => 0 | < d = a > => b) in ({ c = unit , a = true })))
((\ b : ((< b : Nat , b : (Unit -> Nat) >) -> (Unit -> A)) . ((succ true) (succ "boy"))) . a)
(case (inert [ (Rec C . String) ]) of < b = b > => (if (iszero (case b of < d = a > => "apple" | < b = d > => 2)) then (iszero 2) else (< c = (case (unit as C) of < c = d > => a | < a = c > => "apple") > as ({ c : Nat , d : Unit }))) | < d = d > => (((c as (B -> B)) . c) (iszero (inert [ Bool ]))))
(fix (pred (if (iszero "apple") then unit else (2 . c))))
(let b = (iszero (let b = 1 in 2)) in (unfold [ ((String -> String) -> ((A -> A) -> Float)) ] (fix (< a = (\ c : A . "apple") > as Unit))))
((fix ((< b = (if b then 2 else c) > as (C -> Nat)) . b)) as (< b : (< a : (Rec D . C) , d : (A -> A) >) , b : (< e : String , e : Bool >) >))
(\ c : (({ b : ({ c : Unit , e : Bool }) , d : A }) -> (Float -> Bool)) . (iszero (\ b : (Rec C . (Rec D . Float)) . (b . a))))
(succ (unfold [ ((< e : String , b : String >) -> (Rec E . Bool)) ] (\ d : Float . "apple")))
(inert [ ({ a : ((B -> B) -> (Unit -> C)) , d : (< c : (Rec A . C) , c : ({ c : C , e : Float }) >) }) ])
(fold [ (Rec B . (Rec B . (Nat -> A))) ] (succ (if (a as A) then c else (succ c))))
({ b = (\ c : ((B -> A) -> (< d : C , b : B >)) . ((0 . e) . a)) , b = (iszero (if (if unit then 0 else c) then (fold [ Float ] c) else (\ a : Unit . true))) })
(\ c : (< c : (< d : B , c : Float >) , e : (< d : C , a : Bool >) >) . (inert [ ((Nat -> B) -> (Bool -> A)) ]))
({ a = (iszero (< d = 0 > as (Rec B . String))) , d = (succ ((let a = 0 in b) . e)) })
(case (< d = (pred "boy") > as (Rec D . (< d : Nat , d : (Unit -> C) >))) of < d = d > => (\ c : (Rec C . (Rec D . B)) . (fold [ Unit ] false)) | < c = b > => (\ a : ({ e : (Rec E . A) , c : C }) . (unfold [ C ] "boy")))
(fold [ (Rec B . ({ e : ({ e : (< d : Unit , d : Unit >) , b : C }) , a : (Nat -> Nat) })) ] (case (if false then true else 0) of < c = e > => (case unit of < c = a > => (if 1 then 1 else "apple") | < b = e > => b) | < b = a > => (fold [ A ] ("apple" as A))))
(succ (< b = (fix ({ d = "boy" , e = "apple" })) > as ((< e : Float , a : Unit >) -> (< c : B , d : String >))))
({ e = ({ b = ({ b = "apple" , b = true }) , e = (1 as String) }) , b = ((< c = true > as Unit) . d) })
(fix (fix ((< b = 0 > as A) . b)))
((succ ((< e = (unfold [ C ] a) > as (< b : Nat , e : Nat >)) as (Rec D . C))) . e)
(iszero (inert [ (Rec D . (({ d : C , e : C }) -> (< c : Unit , e : B >))) ]))
(pred ((fix (fix 2)) . d))
(\ a : (Rec E . ({ c : Float , e : String })) . (fix (fix (fold [ B ] "boy"))))
(< b = (fix (< d = 2 > as Float)) > as ({ b : (Rec C . (< a : Unit , e : Unit >)) , e : (< a : Unit , d : Float >) }))
(case (pred (pred ({ d = true , b = unit }))) of < d = a > => (fold [ (< a : ({ a : Bool , c : Bool }) , b : (Rec B . String) >) ] (case (fix false) of < e = d > => (\ a : Bool . c) | < c = e > => (unfold [ (< b : A , b : Unit >) ] (false . b)))) | < d = c > => (iszero (\ c : A . 1)))
(\ d : ({ b : ({ e : String , b : Nat }) , a : (Float -> Float) }) . (case (false unit) of < d = a > => (\ b : Nat . 2) | < a = c > => (fold [ Unit ] 0)))
((({ d = unit , d = a }) (fold [ C ] a)) (((unfold [ String ] false) (if b then a else 0)) as (Rec E . (Rec B . Unit))))
((unfold [ (Float -> String) ] ((2 as Unit) ({ a = 2 , b = c }))) . a)
(succ (fold [ (Rec E . Float) ] ((succ false) as Bool)))
(pred (\ c : ((< d : Bool , a : A >) -> (< a : Bool , b : Unit >)) . (< c = (inert [ Float ]) > as (Bool -> A))))
(unfold [ ({ a : (Rec D . Float) , d : (Rec A . Unit) }) ] (unfold [ ({ c : (< d : B , b : (Rec D . Bool) >) , d : (< a : (Rec E . String) , a : Nat >) }) ] ((unfold [ (A -> Nat) ] (fold [ Nat ] "apple")) as ((< e : Bool , e : String >) -> A))))
(inert [ ({ c : (B -> Bool) , e : (String -> Bool) }) ])
(succ ((succ (inert [ C ])) . b))
(pred (fix (case (case false of < d = c > => unit | < b = a > => c) of < a = e > => 2 | < b = e > => (succ "apple"))))
((inert [ (< b : C , a : A >) ]) as ({ e : (B -> Float) , c : (Rec B . (Unit -> Bool)) }))
(case ((if 2 then 1 else (fix false)) . c) of < d = c > => (let a = (let e = unit in (pred "boy")) in (let b = "boy" in (let c = a in b))) | < e = b > => ((< b = ({ d = a , d = 0 }) > as Nat) as ({ c : Nat , b : Bool })))
(fix (let a = (fix ({ c = (< e = "boy" > as C) , c = (fix false) })) in (\ c : String . unit)))
(case ((pred (fold [ Bool ] b)) . b) of < b = c > => ({ c = (iszero (fold [ C ] "boy")) , d = (inert [ B ]) }) | < b = e > => (fix (let a = (unfold [ String ] false) in (false as A))))
(let a = ((unfold [ (String -> Unit) ] (fold [ A ] b)) ({ d = ({ b = b , c = ({ d = true , e = "boy" }) }) , c = (1 "apple") })) in (unfold [ (< a : String , c : (Float -> Nat) >) ] (1 as (Rec C . A))))
(pred (iszero (case false of < d = c > => (\ d : String . "apple") | < c = b > => 2)))
(\ a : (< c : (Rec B . String) , c : (Rec D . (Rec D . Bool)) >) . (succ (unfold [ B ] (let e = 0 in false))))
(< e = (pred (\ a : (A -> String) . a)) > as (Rec B . (Float -> Nat)))
(< c = (\ a : ((< a : Nat , d : Bool >) -> ({ a : C , b : A })) . (if false then (let a = "apple" in 0) else a)) > as ((< c : C , b : Nat >) -> (A -> Bool)))
(< b = (fold [ (< c : (({ e : Bool , c : String }) -> Bool) , b : ({ d : A , c : ({ b : C , c : B }) }) >) ] ((fix false) (fix 1))) > as ((< e : (Nat -> Bool) , d : (Rec A . Unit) >) -> (Rec C . (< b : Unit , a : Float >))))
(((case (pred 1) of < c = e > => (fix "apple") | < d = b > => (< e = a > as Bool)) as (< c : (< c : String , a : C >) , b : (Bool -> B) >)) (inert [ (Rec A . Nat) ]))
(if (unfold [ ({ b : A , b : C }) ] (let a = b in unit)) then (iszero (fold [ C ] c)) else ((case "boy" of < c = b > => "apple" | < c = d > => unit) . c))
(case ((pred (unfold [ C ] b)) (\ b : C . true)) of < c = a > => (unfold [ ({ a : (Unit -> Unit) , e : (< c : Float , d : ({ a : C , b : Float }) >) }) ] (pred (pred false))) | < d = c > => (case (inert [ (C -> C) ]) of < a = c > => (unfold [ (Bool -> Float) ] (pred true)) | < d = d > => (inert [ C ])))
(succ (inert [ (< d : (Rec A . C) , c : (< c : C , a : Unit >) >) ]))
(< d = (\ b : ((B -> Nat) -> ({ a : Nat , d : Bool })) . (inert [ (Rec B . A) ])) > as (Rec E . (< a : (Rec B . String) , d : ({ d : (Float -> String) , e : ({ b : Bool , a : A }) }) >)))
(let d = ((unfold [ Float ] ({ b = 0 , e = unit })) . a) in (if (case ({ d = a , c = c }) of < a = b > => false | < c = b > => unit) then (unfold [ ({ d : A , e : Nat }) ] (case b of < d = b > => 1 | < e = b > => "boy")) else ((pred (1 as C)) as (Rec B . B))))
(if ({ d = (inert [ Nat ]) , a = (inert [ (Rec B . Bool) ]) }) then (fold [ ({ a : Float , d : C }) ] (unit . a)) else (< a = ((\ e : (< e : B , b : Float >) . 0) (case unit of < a = a > => (case "apple" of < c = b > => true | < a = e > => 0) | < a = d > => (c "boy"))) > as ({ b : (Rec A . A) , e : (Nat -> B) })))
(case (case (succ ((let d = "apple" in b) (let a = 1 in "boy"))) of < e = a > => (\ a : (String -> Float) . c) | < d = e > => (< c = (case "apple" of < b = c > => true | < d = a > => 0) > as Float)) of < d = e > => ((iszero ("apple" 1)) (case (fold [ ({ b : String , d : Nat }) ] (unfold [ Float ] false)) of < a = a > => ({ d = 0 , d = ({ d = "apple" , b = 0 }) }) | < e = c > => (inert [ (Unit -> Bool) ]))) | < d = a > => (< a = (iszero (< b = true > as C)) > as (C -> (B -> Float))))
(< d = (iszero ("boy" as (< e : C , e : B >))) > as ((Rec E . String) -> (< a : A , a : C >)))
(if (pred (let b = false in false)) then (fold [ (< a : ({ c : Bool , b : (< a : A , c : String >) }) , d : (< c : Float , d : B >) >) ] (unfold [ Float ] b)) else (iszero (iszero 0)))
(iszero ((\ d : (Rec B . (< d : Float , b : A >)) . (pred "apple")) ((fix unit) (true a))))
(inert [ (Rec E . ((({ e : Unit , a : C }) -> C) -> (Rec D . B))) ])
(succ (case (fix 2) of < c = a > => ({ c = b , a = false }) | < b = b > => (fix 1)))
((\ c : ({ d : B , b : (< e : A , e : Unit >) }) . (unfold [ (String -> C) ] (succ "boy"))) as (Rec D . (< c : B , a : Bool >)))
